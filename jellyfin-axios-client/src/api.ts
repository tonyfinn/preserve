/* tslint:disable */
/* eslint-disable */
/**
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An entity representing a user\'s access schedule.
 * @export
 * @interface AccessSchedule
 */
export interface AccessSchedule {
    /**
     * Gets or sets the id of this instance.
     * @type {number}
     * @memberof AccessSchedule
     */
    Id: number;
    /**
     * Gets or sets the id of the associated user.
     * @type {string}
     * @memberof AccessSchedule
     */
    UserId: string;
    /**
     * 
     * @type {DynamicDayOfWeek}
     * @memberof AccessSchedule
     */
    DayOfWeek: DynamicDayOfWeek;
    /**
     * Gets or sets the start hour.
     * @type {number}
     * @memberof AccessSchedule
     */
    StartHour: number;
    /**
     * Gets or sets the end hour.
     * @type {number}
     * @memberof AccessSchedule
     */
    EndHour: number;
}
/**
 * 
 * @export
 * @interface ActivityLogEntry
 */
export interface ActivityLogEntry {
    /**
     * Gets or sets the identifier.
     * @type {number}
     * @memberof ActivityLogEntry
     */
    Id?: number;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Name?: string | null;
    /**
     * Gets or sets the overview.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Overview?: string | null;
    /**
     * Gets or sets the short overview.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    ShortOverview?: string | null;
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Type?: string | null;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    ItemId?: string | null;
    /**
     * Gets or sets the date.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Date?: string;
    /**
     * Gets or sets the user identifier.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    UserId?: string;
    /**
     * Gets or sets the user primary image tag.
     * @type {string}
     * @memberof ActivityLogEntry
     * @deprecated
     */
    UserPrimaryImageTag?: string | null;
    /**
     * 
     * @type {LogLevel}
     * @memberof ActivityLogEntry
     */
    Severity?: LogLevel;
}
/**
 * 
 * @export
 * @interface ActivityLogEntryQueryResult
 */
export interface ActivityLogEntryQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<ActivityLogEntry>}
     * @memberof ActivityLogEntryQueryResult
     */
    Items?: Array<ActivityLogEntry> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof ActivityLogEntryQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof ActivityLogEntryQueryResult
     */
    StartIndex?: number;
}
/**
 * Add virtual folder dto.
 * @export
 * @interface AddVirtualFolderDto
 */
export interface AddVirtualFolderDto {
    /**
     * 
     * @type {LibraryOptions}
     * @memberof AddVirtualFolderDto
     */
    LibraryOptions?: LibraryOptions;
}
/**
 * 
 * @export
 * @interface AlbumInfo
 */
export interface AlbumInfo {
    /**
     * Gets or sets the album artist.
     * @type {Array<string>}
     * @memberof AlbumInfo
     */
    AlbumArtists?: Array<string> | null;
    /**
     * Gets or sets the artist provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof AlbumInfo
     */
    ArtistProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {Array<SongInfo>}
     * @memberof AlbumInfo
     */
    SongInfos?: Array<SongInfo> | null;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof AlbumInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof AlbumInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof AlbumInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof AlbumInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof AlbumInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof AlbumInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AlbumInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AlbumInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AlbumInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface AlbumInfoRemoteSearchQuery
 */
export interface AlbumInfoRemoteSearchQuery {
    /**
     * 
     * @type {AlbumInfo}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    SearchInfo?: AlbumInfo;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface AllThemeMediaResult
 */
export interface AllThemeMediaResult {
    /**
     * 
     * @type {ThemeMediaResult}
     * @memberof AllThemeMediaResult
     */
    ThemeVideosResult?: ThemeMediaResult;
    /**
     * 
     * @type {ThemeMediaResult}
     * @memberof AllThemeMediaResult
     */
    ThemeSongsResult?: ThemeMediaResult;
    /**
     * 
     * @type {ThemeMediaResult}
     * @memberof AllThemeMediaResult
     */
    SoundtrackSongsResult?: ThemeMediaResult;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Architecture {
    X86 = 'X86',
    X64 = 'X64',
    Arm = 'Arm',
    Arm64 = 'Arm64'
}

/**
 * 
 * @export
 * @interface ArtistInfo
 */
export interface ArtistInfo {
    /**
     * 
     * @type {Array<SongInfo>}
     * @memberof ArtistInfo
     */
    SongInfos?: Array<SongInfo> | null;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ArtistInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof ArtistInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof ArtistInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof ArtistInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof ArtistInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof ArtistInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ArtistInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ArtistInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ArtistInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface ArtistInfoRemoteSearchQuery
 */
export interface ArtistInfoRemoteSearchQuery {
    /**
     * 
     * @type {ArtistInfo}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    SearchInfo?: ArtistInfo;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * The authenticate user by name request body.
 * @export
 * @interface AuthenticateUserByName
 */
export interface AuthenticateUserByName {
    /**
     * Gets or sets the username.
     * @type {string}
     * @memberof AuthenticateUserByName
     */
    Username?: string | null;
    /**
     * Gets or sets the plain text password.
     * @type {string}
     * @memberof AuthenticateUserByName
     */
    Pw?: string | null;
    /**
     * Gets or sets the sha1-hashed password.
     * @type {string}
     * @memberof AuthenticateUserByName
     */
    Password?: string | null;
}
/**
 * 
 * @export
 * @interface AuthenticationInfo
 */
export interface AuthenticationInfo {
    /**
     * Gets or sets the identifier.
     * @type {number}
     * @memberof AuthenticationInfo
     */
    Id?: number;
    /**
     * Gets or sets the access token.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    AccessToken?: string | null;
    /**
     * Gets or sets the device identifier.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DeviceId?: string | null;
    /**
     * Gets or sets the name of the application.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    AppName?: string | null;
    /**
     * Gets or sets the application version.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    AppVersion?: string | null;
    /**
     * Gets or sets the name of the device.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DeviceName?: string | null;
    /**
     * Gets or sets the user identifier.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    UserId?: string;
    /**
     * Gets or sets a value indicating whether this instance is active.
     * @type {boolean}
     * @memberof AuthenticationInfo
     */
    IsActive?: boolean;
    /**
     * Gets or sets the date created.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DateCreated?: string;
    /**
     * Gets or sets the date revoked.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DateRevoked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DateLastActivity?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    UserName?: string | null;
}
/**
 * 
 * @export
 * @interface AuthenticationInfoQueryResult
 */
export interface AuthenticationInfoQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<AuthenticationInfo>}
     * @memberof AuthenticationInfoQueryResult
     */
    Items?: Array<AuthenticationInfo> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof AuthenticationInfoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof AuthenticationInfoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface AuthenticationResult
 */
export interface AuthenticationResult {
    /**
     * 
     * @type {UserDto}
     * @memberof AuthenticationResult
     */
    User?: UserDto;
    /**
     * 
     * @type {SessionInfo}
     * @memberof AuthenticationResult
     */
    SessionInfo?: SessionInfo;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResult
     */
    AccessToken?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResult
     */
    ServerId?: string | null;
}
/**
 * Class BaseItem.
 * @export
 * @interface BaseItem
 */
export interface BaseItem {
    /**
     * 
     * @type {number}
     * @memberof BaseItem
     */
    Size?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItem
     */
    Container?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItem
     */
    DateLastSaved?: string;
    /**
     * Gets or sets the remote trailers.
     * @type {Array<MediaUrl>}
     * @memberof BaseItem
     */
    RemoteTrailers?: Array<MediaUrl> | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItem
     */
    IsHD?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItem
     */
    IsShortcut?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseItem
     */
    ShortcutPath?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItem
     */
    Width?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseItem
     */
    Height?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItem
     */
    ExtraIds?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItem
     */
    SupportsExternalTransfer?: boolean;
}
/**
 * This is strictly used as a data transfer object from the api layer.  This holds information about a BaseItem in a format that is convenient for the client.
 * @export
 * @interface BaseItemDto
 */
export interface BaseItemDto {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof BaseItemDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the server identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    ServerId?: string | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof BaseItemDto
     */
    Id?: string;
    /**
     * Gets or sets the etag.
     * @type {string}
     * @memberof BaseItemDto
     */
    Etag?: string | null;
    /**
     * Gets or sets the type of the source.
     * @type {string}
     * @memberof BaseItemDto
     */
    SourceType?: string | null;
    /**
     * Gets or sets the playlist item identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    PlaylistItemId?: string | null;
    /**
     * Gets or sets the date created.
     * @type {string}
     * @memberof BaseItemDto
     */
    DateCreated?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    DateLastMediaAdded?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ExtraType?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    AirsBeforeSeasonNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    AirsAfterSeasonNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    AirsBeforeEpisodeNumber?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    CanDelete?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    CanDownload?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    HasSubtitles?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    PreferredMetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    PreferredMetadataCountryCode?: string | null;
    /**
     * Gets or sets a value indicating whether [supports synchronize].
     * @type {boolean}
     * @memberof BaseItemDto
     */
    SupportsSync?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Container?: string | null;
    /**
     * Gets or sets the name of the sort.
     * @type {string}
     * @memberof BaseItemDto
     */
    SortName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ForcedSortName?: string | null;
    /**
     * 
     * @type {Video3DFormat}
     * @memberof BaseItemDto
     */
    Video3DFormat?: Video3DFormat;
    /**
     * Gets or sets the premiere date.
     * @type {string}
     * @memberof BaseItemDto
     */
    PremiereDate?: string | null;
    /**
     * Gets or sets the external urls.
     * @type {Array<ExternalUrl>}
     * @memberof BaseItemDto
     */
    ExternalUrls?: Array<ExternalUrl> | null;
    /**
     * Gets or sets the media versions.
     * @type {Array<MediaSourceInfo>}
     * @memberof BaseItemDto
     */
    MediaSources?: Array<MediaSourceInfo> | null;
    /**
     * Gets or sets the critic rating.
     * @type {number}
     * @memberof BaseItemDto
     */
    CriticRating?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    ProductionLocations?: Array<string> | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof BaseItemDto
     */
    Path?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    EnableMediaSourceDisplay?: boolean | null;
    /**
     * Gets or sets the official rating.
     * @type {string}
     * @memberof BaseItemDto
     */
    OfficialRating?: string | null;
    /**
     * Gets or sets the custom rating.
     * @type {string}
     * @memberof BaseItemDto
     */
    CustomRating?: string | null;
    /**
     * Gets or sets the channel identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelId?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelName?: string | null;
    /**
     * Gets or sets the overview.
     * @type {string}
     * @memberof BaseItemDto
     */
    Overview?: string | null;
    /**
     * Gets or sets the taglines.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Taglines?: Array<string> | null;
    /**
     * Gets or sets the genres.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Genres?: Array<string> | null;
    /**
     * Gets or sets the community rating.
     * @type {number}
     * @memberof BaseItemDto
     */
    CommunityRating?: number | null;
    /**
     * Gets or sets the cumulative run time ticks.
     * @type {number}
     * @memberof BaseItemDto
     */
    CumulativeRunTimeTicks?: number | null;
    /**
     * Gets or sets the run time ticks.
     * @type {number}
     * @memberof BaseItemDto
     */
    RunTimeTicks?: number | null;
    /**
     * 
     * @type {PlayAccess}
     * @memberof BaseItemDto
     */
    PlayAccess?: PlayAccess;
    /**
     * Gets or sets the aspect ratio.
     * @type {string}
     * @memberof BaseItemDto
     */
    AspectRatio?: string | null;
    /**
     * Gets or sets the production year.
     * @type {number}
     * @memberof BaseItemDto
     */
    ProductionYear?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is place holder.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsPlaceHolder?: boolean | null;
    /**
     * Gets or sets the number.
     * @type {string}
     * @memberof BaseItemDto
     */
    Number?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelNumber?: string | null;
    /**
     * Gets or sets the index number.
     * @type {number}
     * @memberof BaseItemDto
     */
    IndexNumber?: number | null;
    /**
     * Gets or sets the index number end.
     * @type {number}
     * @memberof BaseItemDto
     */
    IndexNumberEnd?: number | null;
    /**
     * Gets or sets the parent index number.
     * @type {number}
     * @memberof BaseItemDto
     */
    ParentIndexNumber?: number | null;
    /**
     * Gets or sets the trailer urls.
     * @type {Array<MediaUrl>}
     * @memberof BaseItemDto
     */
    RemoteTrailers?: Array<MediaUrl> | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof BaseItemDto
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets a value indicating whether this instance is HD.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsHD?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is folder.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsFolder?: boolean | null;
    /**
     * Gets or sets the parent id.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentId?: string;
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof BaseItemDto
     */
    Type?: string | null;
    /**
     * Gets or sets the people.
     * @type {Array<BaseItemPerson>}
     * @memberof BaseItemDto
     */
    People?: Array<BaseItemPerson> | null;
    /**
     * Gets or sets the studios.
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    Studios?: Array<NameGuidPair> | null;
    /**
     * 
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    GenreItems?: Array<NameGuidPair> | null;
    /**
     * If the item does not have a logo, this will hold the Id of the Parent that has one.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentLogoItemId?: string | null;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentBackdropItemId?: string | null;
    /**
     * Gets or sets the parent backdrop image tags.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets the local trailer count.
     * @type {number}
     * @memberof BaseItemDto
     */
    LocalTrailerCount?: number | null;
    /**
     * 
     * @type {UserItemDataDto}
     * @memberof BaseItemDto
     */
    UserData?: UserItemDataDto;
    /**
     * Gets or sets the recursive item count.
     * @type {number}
     * @memberof BaseItemDto
     */
    RecursiveItemCount?: number | null;
    /**
     * Gets or sets the child count.
     * @type {number}
     * @memberof BaseItemDto
     */
    ChildCount?: number | null;
    /**
     * Gets or sets the name of the series.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesName?: string | null;
    /**
     * Gets or sets the series id.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesId?: string;
    /**
     * Gets or sets the season identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeasonId?: string;
    /**
     * Gets or sets the special feature count.
     * @type {number}
     * @memberof BaseItemDto
     */
    SpecialFeatureCount?: number | null;
    /**
     * Gets or sets the display preferences id.
     * @type {string}
     * @memberof BaseItemDto
     */
    DisplayPreferencesId?: string | null;
    /**
     * Gets or sets the status.
     * @type {string}
     * @memberof BaseItemDto
     */
    Status?: string | null;
    /**
     * Gets or sets the air time.
     * @type {string}
     * @memberof BaseItemDto
     */
    AirTime?: string | null;
    /**
     * Gets or sets the air days.
     * @type {Array<DayOfWeek>}
     * @memberof BaseItemDto
     */
    AirDays?: Array<DayOfWeek> | null;
    /**
     * Gets or sets the tags.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Tags?: Array<string> | null;
    /**
     * Gets or sets the primary image aspect ratio, after image enhancements.
     * @type {number}
     * @memberof BaseItemDto
     */
    PrimaryImageAspectRatio?: number | null;
    /**
     * Gets or sets the artists.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Artists?: Array<string> | null;
    /**
     * Gets or sets the artist items.
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    ArtistItems?: Array<NameGuidPair> | null;
    /**
     * Gets or sets the album.
     * @type {string}
     * @memberof BaseItemDto
     */
    Album?: string | null;
    /**
     * Gets or sets the type of the collection.
     * @type {string}
     * @memberof BaseItemDto
     */
    CollectionType?: string | null;
    /**
     * Gets or sets the display order.
     * @type {string}
     * @memberof BaseItemDto
     */
    DisplayOrder?: string | null;
    /**
     * Gets or sets the album id.
     * @type {string}
     * @memberof BaseItemDto
     */
    AlbumId?: string;
    /**
     * Gets or sets the album image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    AlbumPrimaryImageTag?: string | null;
    /**
     * Gets or sets the series primary image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesPrimaryImageTag?: string | null;
    /**
     * Gets or sets the album artist.
     * @type {string}
     * @memberof BaseItemDto
     */
    AlbumArtist?: string | null;
    /**
     * Gets or sets the album artists.
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    AlbumArtists?: Array<NameGuidPair> | null;
    /**
     * Gets or sets the name of the season.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeasonName?: string | null;
    /**
     * Gets or sets the media streams.
     * @type {Array<MediaStream>}
     * @memberof BaseItemDto
     */
    MediaStreams?: Array<MediaStream> | null;
    /**
     * 
     * @type {VideoType}
     * @memberof BaseItemDto
     */
    VideoType?: VideoType;
    /**
     * Gets or sets the part count.
     * @type {number}
     * @memberof BaseItemDto
     */
    PartCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    MediaSourceCount?: number | null;
    /**
     * 
     * @type {BaseItemDtoImageTags}
     * @memberof BaseItemDto
     */
    ImageTags?: BaseItemDtoImageTags | null;
    /**
     * Gets or sets the backdrop image tags.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    BackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets the screenshot image tags.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    ScreenshotImageTags?: Array<string> | null;
    /**
     * Gets or sets the parent logo image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentLogoImageTag?: string | null;
    /**
     * If the item does not have a art, this will hold the Id of the Parent that has one.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentArtItemId?: string | null;
    /**
     * Gets or sets the parent art image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentArtImageTag?: string | null;
    /**
     * Gets or sets the series thumb image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesThumbImageTag?: string | null;
    /**
     * 
     * @type {BaseItemDtoImageBlurHashes}
     * @memberof BaseItemDto
     */
    ImageBlurHashes?: BaseItemDtoImageBlurHashes | null;
    /**
     * Gets or sets the series studio.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesStudio?: string | null;
    /**
     * Gets or sets the parent thumb item id.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentThumbItemId?: string | null;
    /**
     * Gets or sets the parent thumb image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentThumbImageTag?: string | null;
    /**
     * Gets or sets the parent primary image item identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentPrimaryImageItemId?: string | null;
    /**
     * Gets or sets the parent primary image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentPrimaryImageTag?: string | null;
    /**
     * Gets or sets the chapters.
     * @type {Array<ChapterInfo>}
     * @memberof BaseItemDto
     */
    Chapters?: Array<ChapterInfo> | null;
    /**
     * 
     * @type {LocationType}
     * @memberof BaseItemDto
     */
    LocationType?: LocationType;
    /**
     * 
     * @type {IsoType}
     * @memberof BaseItemDto
     */
    IsoType?: IsoType;
    /**
     * Gets or sets the type of the media.
     * @type {string}
     * @memberof BaseItemDto
     */
    MediaType?: string | null;
    /**
     * Gets or sets the end date.
     * @type {string}
     * @memberof BaseItemDto
     */
    EndDate?: string | null;
    /**
     * Gets or sets the locked fields.
     * @type {Array<MetadataField>}
     * @memberof BaseItemDto
     */
    LockedFields?: Array<MetadataField> | null;
    /**
     * Gets or sets the trailer count.
     * @type {number}
     * @memberof BaseItemDto
     */
    TrailerCount?: number | null;
    /**
     * Gets or sets the movie count.
     * @type {number}
     * @memberof BaseItemDto
     */
    MovieCount?: number | null;
    /**
     * Gets or sets the series count.
     * @type {number}
     * @memberof BaseItemDto
     */
    SeriesCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ProgramCount?: number | null;
    /**
     * Gets or sets the episode count.
     * @type {number}
     * @memberof BaseItemDto
     */
    EpisodeCount?: number | null;
    /**
     * Gets or sets the song count.
     * @type {number}
     * @memberof BaseItemDto
     */
    SongCount?: number | null;
    /**
     * Gets or sets the album count.
     * @type {number}
     * @memberof BaseItemDto
     */
    AlbumCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ArtistCount?: number | null;
    /**
     * Gets or sets the music video count.
     * @type {number}
     * @memberof BaseItemDto
     */
    MusicVideoCount?: number | null;
    /**
     * Gets or sets a value indicating whether [enable internet providers].
     * @type {boolean}
     * @memberof BaseItemDto
     */
    LockData?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Width?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Height?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    CameraMake?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    CameraModel?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Software?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ExposureTime?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    FocalLength?: number | null;
    /**
     * 
     * @type {ImageOrientation}
     * @memberof BaseItemDto
     */
    ImageOrientation?: ImageOrientation;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Aperture?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ShutterSpeed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Latitude?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Longitude?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Altitude?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    IsoSpeedRating?: number | null;
    /**
     * Gets or sets the series timer identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesTimerId?: string | null;
    /**
     * Gets or sets the program identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    ProgramId?: string | null;
    /**
     * Gets or sets the channel primary image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelPrimaryImageTag?: string | null;
    /**
     * The start date of the recording, in UTC.
     * @type {string}
     * @memberof BaseItemDto
     */
    StartDate?: string | null;
    /**
     * Gets or sets the completion percentage.
     * @type {number}
     * @memberof BaseItemDto
     */
    CompletionPercentage?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is repeat.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsRepeat?: boolean | null;
    /**
     * Gets or sets the episode title.
     * @type {string}
     * @memberof BaseItemDto
     */
    EpisodeTitle?: string | null;
    /**
     * 
     * @type {ChannelType}
     * @memberof BaseItemDto
     */
    ChannelType?: ChannelType;
    /**
     * 
     * @type {ProgramAudio}
     * @memberof BaseItemDto
     */
    Audio?: ProgramAudio;
    /**
     * Gets or sets a value indicating whether this instance is movie.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsMovie?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is sports.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsSports?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is series.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsSeries?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is live.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsLive?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is news.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsNews?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is kids.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsKids?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is premiere.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsPremiere?: boolean | null;
    /**
     * Gets or sets the timer identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    TimerId?: string | null;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof BaseItemDto
     */
    CurrentProgram?: BaseItemDto;
}
/**
 * Gets or sets the blurhashes for the image tags.  Maps image type to dictionary mapping image tag to blurhash value.
 * @export
 * @interface BaseItemDtoImageBlurHashes
 */
export interface BaseItemDtoImageBlurHashes {
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Primary?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Art?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Backdrop?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Banner?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Logo?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Thumb?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Disc?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Box?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Screenshot?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Menu?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Chapter?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    BoxRear?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Profile?: BaseItemPersonImageBlurHashesPrimary;
}
/**
 * Gets or sets the image tags.
 * @export
 * @interface BaseItemDtoImageTags
 */
export interface BaseItemDtoImageTags {
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Primary?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Art?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Backdrop?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Banner?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Logo?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Thumb?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Disc?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Box?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Screenshot?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Menu?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Chapter?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    BoxRear?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Profile?: string;
}
/**
 * 
 * @export
 * @interface BaseItemDtoQueryResult
 */
export interface BaseItemDtoQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<BaseItemDto>}
     * @memberof BaseItemDtoQueryResult
     */
    Items?: Array<BaseItemDto> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof BaseItemDtoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof BaseItemDtoQueryResult
     */
    StartIndex?: number;
}
/**
 * This is used by the api to get information about a Person within a BaseItem.
 * @export
 * @interface BaseItemPerson
 */
export interface BaseItemPerson {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof BaseItemPerson
     */
    Name?: string | null;
    /**
     * Gets or sets the identifier.
     * @type {string}
     * @memberof BaseItemPerson
     */
    Id?: string | null;
    /**
     * Gets or sets the role.
     * @type {string}
     * @memberof BaseItemPerson
     */
    Role?: string | null;
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof BaseItemPerson
     */
    Type?: string | null;
    /**
     * Gets or sets the primary image tag.
     * @type {string}
     * @memberof BaseItemPerson
     */
    PrimaryImageTag?: string | null;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashes}
     * @memberof BaseItemPerson
     */
    ImageBlurHashes?: BaseItemPersonImageBlurHashes | null;
}
/**
 * Gets or sets the primary image blurhash.
 * @export
 * @interface BaseItemPersonImageBlurHashes
 */
export interface BaseItemPersonImageBlurHashes {
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Primary?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Art?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Backdrop?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Banner?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Logo?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Thumb?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Disc?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Box?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Screenshot?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Menu?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Chapter?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    BoxRear?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Profile?: BaseItemPersonImageBlurHashesPrimary;
}
/**
 * 
 * @export
 * @interface BaseItemPersonImageBlurHashesPrimary
 */
export interface BaseItemPersonImageBlurHashesPrimary {
    /**
     * 
     * @type {string}
     * @memberof BaseItemPersonImageBlurHashesPrimary
     */
    string?: string;
}
/**
 * 
 * @export
 * @interface BookInfo
 */
export interface BookInfo {
    /**
     * 
     * @type {string}
     * @memberof BookInfo
     */
    SeriesName?: string | null;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof BookInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof BookInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof BookInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof BookInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof BookInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof BookInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BookInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BookInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BookInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface BookInfoRemoteSearchQuery
 */
export interface BookInfoRemoteSearchQuery {
    /**
     * 
     * @type {BookInfo}
     * @memberof BookInfoRemoteSearchQuery
     */
    SearchInfo?: BookInfo;
    /**
     * 
     * @type {string}
     * @memberof BookInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof BookInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof BookInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface BoxSetInfo
 */
export interface BoxSetInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof BoxSetInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof BoxSetInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof BoxSetInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof BoxSetInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof BoxSetInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof BoxSetInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BoxSetInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BoxSetInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BoxSetInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface BoxSetInfoRemoteSearchQuery
 */
export interface BoxSetInfoRemoteSearchQuery {
    /**
     * 
     * @type {BoxSetInfo}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    SearchInfo?: BoxSetInfo;
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface BrandingOptions
 */
export interface BrandingOptions {
    /**
     * Gets or sets the login disclaimer.
     * @type {string}
     * @memberof BrandingOptions
     */
    LoginDisclaimer?: string | null;
    /**
     * Gets or sets the custom CSS.
     * @type {string}
     * @memberof BrandingOptions
     */
    CustomCss?: string | null;
}
/**
 * 
 * @export
 * @interface ChannelFeatures
 */
export interface ChannelFeatures {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ChannelFeatures
     */
    Name?: string | null;
    /**
     * Gets or sets the identifier.
     * @type {string}
     * @memberof ChannelFeatures
     */
    Id?: string | null;
    /**
     * Gets or sets a value indicating whether this instance can search.
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    CanSearch?: boolean;
    /**
     * Gets or sets the media types.
     * @type {Array<ChannelMediaType>}
     * @memberof ChannelFeatures
     */
    MediaTypes?: Array<ChannelMediaType> | null;
    /**
     * Gets or sets the content types.
     * @type {Array<ChannelMediaContentType>}
     * @memberof ChannelFeatures
     */
    ContentTypes?: Array<ChannelMediaContentType> | null;
    /**
     * Represents the maximum number of records the channel allows retrieving at a time.
     * @type {number}
     * @memberof ChannelFeatures
     */
    MaxPageSize?: number | null;
    /**
     * Gets or sets the automatic refresh levels.
     * @type {number}
     * @memberof ChannelFeatures
     */
    AutoRefreshLevels?: number | null;
    /**
     * Gets or sets the default sort orders.
     * @type {Array<ChannelItemSortField>}
     * @memberof ChannelFeatures
     */
    DefaultSortFields?: Array<ChannelItemSortField> | null;
    /**
     * Indicates if a sort ascending/descending toggle is supported or not.
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    SupportsSortOrderToggle?: boolean;
    /**
     * Gets or sets a value indicating whether [supports latest media].
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    SupportsLatestMedia?: boolean;
    /**
     * Gets or sets a value indicating whether this instance can filter.
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    CanFilter?: boolean;
    /**
     * Gets or sets a value indicating whether [supports content downloading].
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    SupportsContentDownloading?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ChannelItemSortField {
    Name = 'Name',
    CommunityRating = 'CommunityRating',
    PremiereDate = 'PremiereDate',
    DateCreated = 'DateCreated',
    Runtime = 'Runtime',
    PlayCount = 'PlayCount',
    CommunityPlayCount = 'CommunityPlayCount'
}

/**
 * Channel mapping options dto.
 * @export
 * @interface ChannelMappingOptionsDto
 */
export interface ChannelMappingOptionsDto {
    /**
     * Gets or sets list of tuner channels.
     * @type {Array<TunerChannelMapping>}
     * @memberof ChannelMappingOptionsDto
     */
    TunerChannels?: Array<TunerChannelMapping> | null;
    /**
     * Gets or sets list of provider channels.
     * @type {Array<NameIdPair>}
     * @memberof ChannelMappingOptionsDto
     */
    ProviderChannels?: Array<NameIdPair> | null;
    /**
     * Gets or sets list of mappings.
     * @type {Array<NameValuePair>}
     * @memberof ChannelMappingOptionsDto
     */
    Mappings?: Array<NameValuePair> | null;
    /**
     * Gets or sets provider name.
     * @type {string}
     * @memberof ChannelMappingOptionsDto
     */
    ProviderName?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ChannelMediaContentType {
    Clip = 'Clip',
    Podcast = 'Podcast',
    Trailer = 'Trailer',
    Movie = 'Movie',
    Episode = 'Episode',
    Song = 'Song',
    MovieExtra = 'MovieExtra',
    TvExtra = 'TvExtra'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ChannelMediaType {
    Audio = 'Audio',
    Video = 'Video',
    Photo = 'Photo'
}

/**
 * Enum ChannelType.
 * @export
 * @enum {string}
 */
export enum ChannelType {
    TV = 'TV',
    Radio = 'Radio'
}

/**
 * Class ChapterInfo.
 * @export
 * @interface ChapterInfo
 */
export interface ChapterInfo {
    /**
     * Gets or sets the start position ticks.
     * @type {number}
     * @memberof ChapterInfo
     */
    StartPositionTicks?: number;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ChapterInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the image path.
     * @type {string}
     * @memberof ChapterInfo
     */
    ImagePath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChapterInfo
     */
    ImageDateModified?: string;
    /**
     * 
     * @type {string}
     * @memberof ChapterInfo
     */
    ImageTag?: string | null;
}
/**
 * 
 * @export
 * @interface ClientCapabilities
 */
export interface ClientCapabilities {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientCapabilities
     */
    PlayableMediaTypes?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientCapabilities
     */
    SupportedCommands?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsMediaControl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsContentUploading?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientCapabilities
     */
    MessageCallbackUrl?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsPersistentIdentifier?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsSync?: boolean;
    /**
     * 
     * @type {DeviceProfile}
     * @memberof ClientCapabilities
     */
    DeviceProfile?: DeviceProfile;
    /**
     * 
     * @type {string}
     * @memberof ClientCapabilities
     */
    AppStoreUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientCapabilities
     */
    IconUrl?: string | null;
}
/**
 * 
 * @export
 * @interface CodecProfile
 */
export interface CodecProfile {
    /**
     * 
     * @type {CodecType}
     * @memberof CodecProfile
     */
    Type?: CodecType;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof CodecProfile
     */
    Conditions?: Array<ProfileCondition> | null;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof CodecProfile
     */
    ApplyConditions?: Array<ProfileCondition> | null;
    /**
     * 
     * @type {string}
     * @memberof CodecProfile
     */
    Codec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CodecProfile
     */
    Container?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CodecType {
    Video = 'Video',
    VideoAudio = 'VideoAudio',
    Audio = 'Audio'
}

/**
 * 
 * @export
 * @interface CollectionCreationResult
 */
export interface CollectionCreationResult {
    /**
     * 
     * @type {string}
     * @memberof CollectionCreationResult
     */
    Id?: string;
}
/**
 * The configuration page info.
 * @export
 * @interface ConfigurationPageInfo
 */
export interface ConfigurationPageInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    Name?: string | null;
    /**
     * Gets or sets a value indicating whether the configurations page is enabled in the main menu.
     * @type {boolean}
     * @memberof ConfigurationPageInfo
     */
    EnableInMainMenu?: boolean;
    /**
     * Gets or sets the menu section.
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    MenuSection?: string | null;
    /**
     * Gets or sets the menu icon.
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    MenuIcon?: string | null;
    /**
     * Gets or sets the display name.
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    DisplayName?: string | null;
    /**
     * 
     * @type {ConfigurationPageType}
     * @memberof ConfigurationPageInfo
     */
    ConfigurationPageType?: ConfigurationPageType;
    /**
     * Gets or sets the plugin id.
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    PluginId?: string | null;
}
/**
 * Enum ConfigurationPageType.
 * @export
 * @enum {string}
 */
export enum ConfigurationPageType {
    PluginConfiguration = 'PluginConfiguration',
    None = 'None'
}

/**
 * 
 * @export
 * @interface ContainerProfile
 */
export interface ContainerProfile {
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof ContainerProfile
     */
    Type?: DlnaProfileType;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof ContainerProfile
     */
    Conditions?: Array<ProfileCondition> | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerProfile
     */
    Container?: string | null;
}
/**
 * 
 * @export
 * @interface ControlResponse
 */
export interface ControlResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ControlResponse
     */
    Headers?: { [key: string]: string; } | null;
    /**
     * 
     * @type {string}
     * @memberof ControlResponse
     */
    Xml?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ControlResponse
     */
    IsSuccessful?: boolean;
}
/**
 * Class CountryInfo.
 * @export
 * @interface CountryInfo
 */
export interface CountryInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof CountryInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the display name.
     * @type {string}
     * @memberof CountryInfo
     */
    DisplayName?: string | null;
    /**
     * Gets or sets the name of the two letter ISO region.
     * @type {string}
     * @memberof CountryInfo
     */
    TwoLetterISORegionName?: string | null;
    /**
     * Gets or sets the name of the three letter ISO region.
     * @type {string}
     * @memberof CountryInfo
     */
    ThreeLetterISORegionName?: string | null;
}
/**
 * Create new playlist dto.
 * @export
 * @interface CreatePlaylistDto
 */
export interface CreatePlaylistDto {
    /**
     * Gets or sets the name of the new playlist.
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    Name?: string | null;
    /**
     * Gets or sets item ids to add to the playlist.
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    Ids?: string | null;
    /**
     * Gets or sets the user id.
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    UserId?: string;
    /**
     * Gets or sets the media type.
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    MediaType?: string | null;
}
/**
 * The create user by name request body.
 * @export
 * @interface CreateUserByName
 */
export interface CreateUserByName {
    /**
     * Gets or sets the username.
     * @type {string}
     * @memberof CreateUserByName
     */
    Name?: string | null;
    /**
     * Gets or sets the password.
     * @type {string}
     * @memberof CreateUserByName
     */
    Password?: string | null;
}
/**
 * Class CultureDto.
 * @export
 * @interface CultureDto
 */
export interface CultureDto {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof CultureDto
     */
    Name?: string | null;
    /**
     * Gets or sets the display name.
     * @type {string}
     * @memberof CultureDto
     */
    DisplayName?: string | null;
    /**
     * Gets or sets the name of the two letter ISO language.
     * @type {string}
     * @memberof CultureDto
     */
    TwoLetterISOLanguageName?: string | null;
    /**
     * Gets or sets the name of the three letter ISO language.
     * @type {string}
     * @memberof CultureDto
     */
    ThreeLetterISOLanguageName?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CultureDto
     */
    ThreeLetterISOLanguageNames?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DayOfWeek {
    Sunday = 'Sunday',
    Monday = 'Monday',
    Tuesday = 'Tuesday',
    Wednesday = 'Wednesday',
    Thursday = 'Thursday',
    Friday = 'Friday',
    Saturday = 'Saturday'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DayPattern {
    Daily = 'Daily',
    Weekdays = 'Weekdays',
    Weekends = 'Weekends'
}

/**
 * Default directory browser info.
 * @export
 * @interface DefaultDirectoryBrowserInfoDto
 */
export interface DefaultDirectoryBrowserInfoDto {
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof DefaultDirectoryBrowserInfoDto
     */
    Path?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceIdentification
 */
export interface DeviceIdentification {
    /**
     * Gets or sets the name of the friendly.
     * @type {string}
     * @memberof DeviceIdentification
     */
    FriendlyName?: string | null;
    /**
     * Gets or sets the model number.
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelNumber?: string | null;
    /**
     * Gets or sets the serial number.
     * @type {string}
     * @memberof DeviceIdentification
     */
    SerialNumber?: string | null;
    /**
     * Gets or sets the name of the model.
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelName?: string | null;
    /**
     * Gets or sets the model description.
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelDescription?: string | null;
    /**
     * Gets or sets the model URL.
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelUrl?: string | null;
    /**
     * Gets or sets the manufacturer.
     * @type {string}
     * @memberof DeviceIdentification
     */
    Manufacturer?: string | null;
    /**
     * Gets or sets the manufacturer URL.
     * @type {string}
     * @memberof DeviceIdentification
     */
    ManufacturerUrl?: string | null;
    /**
     * Gets or sets the headers.
     * @type {Array<HttpHeaderInfo>}
     * @memberof DeviceIdentification
     */
    Headers?: Array<HttpHeaderInfo> | null;
}
/**
 * 
 * @export
 * @interface DeviceInfo
 */
export interface DeviceInfo {
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the identifier.
     * @type {string}
     * @memberof DeviceInfo
     */
    Id?: string | null;
    /**
     * Gets or sets the last name of the user.
     * @type {string}
     * @memberof DeviceInfo
     */
    LastUserName?: string | null;
    /**
     * Gets or sets the name of the application.
     * @type {string}
     * @memberof DeviceInfo
     */
    AppName?: string | null;
    /**
     * Gets or sets the application version.
     * @type {string}
     * @memberof DeviceInfo
     */
    AppVersion?: string | null;
    /**
     * Gets or sets the last user identifier.
     * @type {string}
     * @memberof DeviceInfo
     */
    LastUserId?: string;
    /**
     * Gets or sets the date last modified.
     * @type {string}
     * @memberof DeviceInfo
     */
    DateLastActivity?: string;
    /**
     * 
     * @type {ClientCapabilities}
     * @memberof DeviceInfo
     */
    Capabilities?: ClientCapabilities;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    IconUrl?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceInfoQueryResult
 */
export interface DeviceInfoQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<DeviceInfo>}
     * @memberof DeviceInfoQueryResult
     */
    Items?: Array<DeviceInfo> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof DeviceInfoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof DeviceInfoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface DeviceOptions
 */
export interface DeviceOptions {
    /**
     * 
     * @type {string}
     * @memberof DeviceOptions
     */
    CustomName?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceProfile
 */
export interface DeviceProfile {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof DeviceProfile
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    Id?: string | null;
    /**
     * 
     * @type {DeviceIdentification}
     * @memberof DeviceProfile
     */
    Identification?: DeviceIdentification;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    FriendlyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    Manufacturer?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ManufacturerUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelDescription?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    SerialNumber?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableAlbumArtInDidl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableSingleAlbumArtLimit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableSingleSubtitleLimit?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    SupportedMediaTypes?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    UserId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    AlbumArtPn?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxAlbumArtWidth?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxAlbumArtHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxIconWidth?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxIconHeight?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxStreamingBitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxStaticBitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MusicStreamingTranscodingBitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxStaticMusicBitrate?: number | null;
    /**
     * Controls the content of the aggregationFlags element in the urn:schemas-sonycom:av namespace.
     * @type {string}
     * @memberof DeviceProfile
     */
    SonyAggregationFlags?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ProtocolInfo?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    TimelineOffsetSeconds?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    RequiresPlainVideoItems?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    RequiresPlainFolders?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableMSMediaReceiverRegistrar?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    IgnoreTranscodeByteRangeRequests?: boolean;
    /**
     * 
     * @type {Array<XmlAttribute>}
     * @memberof DeviceProfile
     */
    XmlRootAttributes?: Array<XmlAttribute> | null;
    /**
     * Gets or sets the direct play profiles.
     * @type {Array<DirectPlayProfile>}
     * @memberof DeviceProfile
     */
    DirectPlayProfiles?: Array<DirectPlayProfile> | null;
    /**
     * Gets or sets the transcoding profiles.
     * @type {Array<TranscodingProfile>}
     * @memberof DeviceProfile
     */
    TranscodingProfiles?: Array<TranscodingProfile> | null;
    /**
     * 
     * @type {Array<ContainerProfile>}
     * @memberof DeviceProfile
     */
    ContainerProfiles?: Array<ContainerProfile> | null;
    /**
     * 
     * @type {Array<CodecProfile>}
     * @memberof DeviceProfile
     */
    CodecProfiles?: Array<CodecProfile> | null;
    /**
     * 
     * @type {Array<ResponseProfile>}
     * @memberof DeviceProfile
     */
    ResponseProfiles?: Array<ResponseProfile> | null;
    /**
     * 
     * @type {Array<SubtitleProfile>}
     * @memberof DeviceProfile
     */
    SubtitleProfiles?: Array<SubtitleProfile> | null;
}
/**
 * Device profile dto.
 * @export
 * @interface DeviceProfileDto
 */
export interface DeviceProfileDto {
    /**
     * 
     * @type {DeviceProfile}
     * @memberof DeviceProfileDto
     */
    DeviceProfile?: DeviceProfile;
}
/**
 * 
 * @export
 * @interface DeviceProfileInfo
 */
export interface DeviceProfileInfo {
    /**
     * Gets or sets the identifier.
     * @type {string}
     * @memberof DeviceProfileInfo
     */
    Id?: string | null;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof DeviceProfileInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {DeviceProfileType}
     * @memberof DeviceProfileInfo
     */
    Type?: DeviceProfileType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DeviceProfileType {
    System = 'System',
    User = 'User'
}

/**
 * 
 * @export
 * @interface DirectPlayProfile
 */
export interface DirectPlayProfile {
    /**
     * 
     * @type {string}
     * @memberof DirectPlayProfile
     */
    Container?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DirectPlayProfile
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DirectPlayProfile
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof DirectPlayProfile
     */
    Type?: DlnaProfileType;
}
/**
 * Defines the display preferences for any item that supports them (usually Folders).
 * @export
 * @interface DisplayPreferencesDto
 */
export interface DisplayPreferencesDto {
    /**
     * Gets or sets the user id.
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    Id?: string | null;
    /**
     * Gets or sets the type of the view.
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    ViewType?: string | null;
    /**
     * Gets or sets the sort by.
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    SortBy?: string | null;
    /**
     * Gets or sets the index by.
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    IndexBy?: string | null;
    /**
     * Gets or sets a value indicating whether [remember indexing].
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    RememberIndexing?: boolean;
    /**
     * Gets or sets the height of the primary image.
     * @type {number}
     * @memberof DisplayPreferencesDto
     */
    PrimaryImageHeight?: number;
    /**
     * Gets or sets the width of the primary image.
     * @type {number}
     * @memberof DisplayPreferencesDto
     */
    PrimaryImageWidth?: number;
    /**
     * Gets or sets the custom prefs.
     * @type {{ [key: string]: string; }}
     * @memberof DisplayPreferencesDto
     */
    CustomPrefs?: { [key: string]: string; } | null;
    /**
     * 
     * @type {ScrollDirection}
     * @memberof DisplayPreferencesDto
     */
    ScrollDirection?: ScrollDirection;
    /**
     * Gets or sets a value indicating whether to show backdrops on this item.
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    ShowBackdrop?: boolean;
    /**
     * Gets or sets a value indicating whether [remember sorting].
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    RememberSorting?: boolean;
    /**
     * 
     * @type {SortOrder}
     * @memberof DisplayPreferencesDto
     */
    SortOrder?: SortOrder;
    /**
     * Gets or sets a value indicating whether [show sidebar].
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    ShowSidebar?: boolean;
    /**
     * Gets or sets the client.
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    Client?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DlnaProfileType {
    Audio = 'Audio',
    Video = 'Video',
    Photo = 'Photo'
}

/**
 * An enum that represents a day of the week, weekdays, weekends, or all days.
 * @export
 * @enum {string}
 */
export enum DynamicDayOfWeek {
    Sunday = 'Sunday',
    Monday = 'Monday',
    Tuesday = 'Tuesday',
    Wednesday = 'Wednesday',
    Thursday = 'Thursday',
    Friday = 'Friday',
    Saturday = 'Saturday',
    Everyday = 'Everyday',
    Weekday = 'Weekday',
    Weekend = 'Weekend'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum EncodingContext {
    Streaming = 'Streaming',
    Static = 'Static'
}

/**
 * 
 * @export
 * @interface EndPointInfo
 */
export interface EndPointInfo {
    /**
     * 
     * @type {boolean}
     * @memberof EndPointInfo
     */
    IsLocal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EndPointInfo
     */
    IsInNetwork?: boolean;
}
/**
 * Represents the external id information for serialization to the client.
 * @export
 * @interface ExternalIdInfo
 */
export interface ExternalIdInfo {
    /**
     * Gets or sets the display name of the external id provider (IE: IMDB, MusicBrainz, etc).
     * @type {string}
     * @memberof ExternalIdInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the unique key for this id. This key should be unique across all providers.
     * @type {string}
     * @memberof ExternalIdInfo
     */
    Key?: string | null;
    /**
     * 
     * @type {ExternalIdMediaType}
     * @memberof ExternalIdInfo
     */
    Type?: ExternalIdMediaType;
    /**
     * Gets or sets the URL format string.
     * @type {string}
     * @memberof ExternalIdInfo
     */
    UrlFormatString?: string | null;
}
/**
 * The specific media type of an MediaBrowser.Model.Providers.ExternalIdInfo.
 * @export
 * @enum {string}
 */
export enum ExternalIdMediaType {
    Album = 'Album',
    AlbumArtist = 'AlbumArtist',
    Artist = 'Artist',
    BoxSet = 'BoxSet',
    Episode = 'Episode',
    Movie = 'Movie',
    OtherArtist = 'OtherArtist',
    Person = 'Person',
    ReleaseGroup = 'ReleaseGroup',
    Season = 'Season',
    Series = 'Series',
    Track = 'Track'
}

/**
 * 
 * @export
 * @interface ExternalUrl
 */
export interface ExternalUrl {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ExternalUrl
     */
    Name?: string | null;
    /**
     * Gets or sets the type of the item.
     * @type {string}
     * @memberof ExternalUrl
     */
    Url?: string | null;
}
/**
 * Enum describing the location of the FFmpeg tool.
 * @export
 * @enum {string}
 */
export enum FFmpegLocation {
    NotFound = 'NotFound',
    SetByArgument = 'SetByArgument',
    Custom = 'Custom',
    System = 'System'
}

/**
 * Class FileSystemEntryInfo.
 * @export
 * @interface FileSystemEntryInfo
 */
export interface FileSystemEntryInfo {
    /**
     * Gets the name.
     * @type {string}
     * @memberof FileSystemEntryInfo
     */
    Name?: string | null;
    /**
     * Gets the path.
     * @type {string}
     * @memberof FileSystemEntryInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {FileSystemEntryType}
     * @memberof FileSystemEntryInfo
     */
    Type?: FileSystemEntryType;
}
/**
 * Enum FileSystemEntryType.
 * @export
 * @enum {string}
 */
export enum FileSystemEntryType {
    File = 'File',
    Directory = 'Directory',
    NetworkComputer = 'NetworkComputer',
    NetworkShare = 'NetworkShare'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ForgotPasswordAction {
    ContactAdmin = 'ContactAdmin',
    PinCode = 'PinCode',
    InNetworkRequired = 'InNetworkRequired'
}

/**
 * Forgot Password request body DTO.
 * @export
 * @interface ForgotPasswordDto
 */
export interface ForgotPasswordDto {
    /**
     * Gets or sets the entered username to have its password reset.
     * @type {string}
     * @memberof ForgotPasswordDto
     */
    EnteredUsername: string;
}
/**
 * 
 * @export
 * @interface ForgotPasswordResult
 */
export interface ForgotPasswordResult {
    /**
     * 
     * @type {ForgotPasswordAction}
     * @memberof ForgotPasswordResult
     */
    Action?: ForgotPasswordAction;
    /**
     * Gets or sets the pin file.
     * @type {string}
     * @memberof ForgotPasswordResult
     */
    PinFile?: string | null;
    /**
     * Gets or sets the pin expiration date.
     * @type {string}
     * @memberof ForgotPasswordResult
     */
    PinExpirationDate?: string | null;
}
/**
 * 
 * @export
 * @interface GeneralCommand
 */
export interface GeneralCommand {
    /**
     * 
     * @type {GeneralCommandType}
     * @memberof GeneralCommand
     */
    Name?: GeneralCommandType;
    /**
     * 
     * @type {string}
     * @memberof GeneralCommand
     */
    ControllingUserId?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GeneralCommand
     */
    Arguments?: { [key: string]: string; } | null;
}
/**
 * This exists simply to identify a set of known commands.
 * @export
 * @enum {string}
 */
export enum GeneralCommandType {
    MoveUp = 'MoveUp',
    MoveDown = 'MoveDown',
    MoveLeft = 'MoveLeft',
    MoveRight = 'MoveRight',
    PageUp = 'PageUp',
    PageDown = 'PageDown',
    PreviousLetter = 'PreviousLetter',
    NextLetter = 'NextLetter',
    ToggleOsd = 'ToggleOsd',
    ToggleContextMenu = 'ToggleContextMenu',
    Select = 'Select',
    Back = 'Back',
    TakeScreenshot = 'TakeScreenshot',
    SendKey = 'SendKey',
    SendString = 'SendString',
    GoHome = 'GoHome',
    GoToSettings = 'GoToSettings',
    VolumeUp = 'VolumeUp',
    VolumeDown = 'VolumeDown',
    Mute = 'Mute',
    Unmute = 'Unmute',
    ToggleMute = 'ToggleMute',
    SetVolume = 'SetVolume',
    SetAudioStreamIndex = 'SetAudioStreamIndex',
    SetSubtitleStreamIndex = 'SetSubtitleStreamIndex',
    ToggleFullscreen = 'ToggleFullscreen',
    DisplayContent = 'DisplayContent',
    GoToSearch = 'GoToSearch',
    DisplayMessage = 'DisplayMessage',
    SetRepeatMode = 'SetRepeatMode',
    ChannelUp = 'ChannelUp',
    ChannelDown = 'ChannelDown',
    Guide = 'Guide',
    ToggleStats = 'ToggleStats',
    PlayMediaSource = 'PlayMediaSource',
    PlayTrailers = 'PlayTrailers'
}

/**
 * Get programs dto.
 * @export
 * @interface GetProgramsDto
 */
export interface GetProgramsDto {
    /**
     * Gets or sets the channels to return guide information for.
     * @type {string}
     * @memberof GetProgramsDto
     */
    ChannelIds?: string | null;
    /**
     * Gets or sets optional. Filter by user id.
     * @type {string}
     * @memberof GetProgramsDto
     */
    UserId?: string;
    /**
     * Gets or sets the minimum premiere start date.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    MinStartDate?: string | null;
    /**
     * Gets or sets filter by programs that have completed airing, or not.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    HasAired?: boolean | null;
    /**
     * Gets or sets filter by programs that are currently airing, or not.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsAiring?: boolean | null;
    /**
     * Gets or sets the maximum premiere start date.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    MaxStartDate?: string | null;
    /**
     * Gets or sets the minimum premiere end date.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    MinEndDate?: string | null;
    /**
     * Gets or sets the maximum premiere end date.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    MaxEndDate?: string | null;
    /**
     * Gets or sets filter for movies.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsMovie?: boolean | null;
    /**
     * Gets or sets filter for series.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsSeries?: boolean | null;
    /**
     * Gets or sets filter for news.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsNews?: boolean | null;
    /**
     * Gets or sets filter for kids.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsKids?: boolean | null;
    /**
     * Gets or sets filter for sports.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsSports?: boolean | null;
    /**
     * Gets or sets the record index to start at. All items with a lower index will be dropped from the results.  Optional.
     * @type {number}
     * @memberof GetProgramsDto
     */
    StartIndex?: number | null;
    /**
     * Gets or sets the maximum number of records to return.  Optional.
     * @type {number}
     * @memberof GetProgramsDto
     */
    Limit?: number | null;
    /**
     * Gets or sets specify one or more sort orders, comma delimited. Options: Name, StartDate.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    SortBy?: string | null;
    /**
     * Gets or sets sort Order - Ascending,Descending.
     * @type {string}
     * @memberof GetProgramsDto
     */
    SortOrder?: string | null;
    /**
     * Gets or sets the genres to return guide information for.
     * @type {string}
     * @memberof GetProgramsDto
     */
    Genres?: string | null;
    /**
     * Gets or sets the genre ids to return guide information for.
     * @type {string}
     * @memberof GetProgramsDto
     */
    GenreIds?: string | null;
    /**
     * Gets or sets include image information in output.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    EnableImages?: boolean | null;
    /**
     * Gets or sets a value indicating whether retrieve total record count.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    EnableTotalRecordCount?: boolean;
    /**
     * Gets or sets the max number of images to return, per image type.  Optional.
     * @type {number}
     * @memberof GetProgramsDto
     */
    ImageTypeLimit?: number | null;
    /**
     * Gets or sets the image types to include in the output.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    EnableImageTypes?: string | null;
    /**
     * Gets or sets include user data.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    EnableUserData?: boolean | null;
    /**
     * Gets or sets filter by series timer id.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    SeriesTimerId?: string | null;
    /**
     * Gets or sets filter by library series id.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    LibrarySeriesId?: string;
    /**
     * Gets or sets specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    Fields?: string | null;
}
/**
 * Class GroupInfoView.
 * @export
 * @interface GroupInfoView
 */
export interface GroupInfoView {
    /**
     * Gets or sets the group identifier.
     * @type {string}
     * @memberof GroupInfoView
     */
    GroupId?: string | null;
    /**
     * Gets or sets the playing item id.
     * @type {string}
     * @memberof GroupInfoView
     */
    PlayingItemId?: string | null;
    /**
     * Gets or sets the playing item name.
     * @type {string}
     * @memberof GroupInfoView
     */
    PlayingItemName?: string | null;
    /**
     * Gets or sets the position ticks.
     * @type {number}
     * @memberof GroupInfoView
     */
    PositionTicks?: number;
    /**
     * Gets or sets the participants.
     * @type {Array<string>}
     * @memberof GroupInfoView
     */
    Participants?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface GuideInfo
 */
export interface GuideInfo {
    /**
     * Gets or sets the start date.
     * @type {string}
     * @memberof GuideInfo
     */
    StartDate?: string;
    /**
     * Gets or sets the end date.
     * @type {string}
     * @memberof GuideInfo
     */
    EndDate?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum HeaderMatchType {
    Equals = 'Equals',
    Regex = 'Regex',
    Substring = 'Substring'
}

/**
 * 
 * @export
 * @interface HttpHeaderInfo
 */
export interface HttpHeaderInfo {
    /**
     * 
     * @type {string}
     * @memberof HttpHeaderInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HttpHeaderInfo
     */
    Value?: string | null;
    /**
     * 
     * @type {HeaderMatchType}
     * @memberof HttpHeaderInfo
     */
    Match?: HeaderMatchType;
}
/**
 * Interface IScheduledTaskWorker.
 * @export
 * @interface IScheduledTask
 */
export interface IScheduledTask {
    /**
     * Gets the name of the task.
     * @type {string}
     * @memberof IScheduledTask
     */
    Name?: string | null;
    /**
     * Gets the key of the task.
     * @type {string}
     * @memberof IScheduledTask
     */
    Key?: string | null;
    /**
     * Gets the description.
     * @type {string}
     * @memberof IScheduledTask
     */
    Description?: string | null;
    /**
     * Gets the category.
     * @type {string}
     * @memberof IScheduledTask
     */
    Category?: string | null;
}
/**
 * Interface IScheduledTaskWorker.
 * @export
 * @interface IScheduledTaskWorker
 */
export interface IScheduledTaskWorker {
    /**
     * 
     * @type {IScheduledTask}
     * @memberof IScheduledTaskWorker
     */
    ScheduledTask?: IScheduledTask;
    /**
     * 
     * @type {TaskResult}
     * @memberof IScheduledTaskWorker
     */
    LastExecutionResult?: TaskResult;
    /**
     * Gets the name.
     * @type {string}
     * @memberof IScheduledTaskWorker
     */
    Name?: string | null;
    /**
     * Gets the description.
     * @type {string}
     * @memberof IScheduledTaskWorker
     */
    Description?: string | null;
    /**
     * Gets the category.
     * @type {string}
     * @memberof IScheduledTaskWorker
     */
    Category?: string | null;
    /**
     * 
     * @type {TaskState}
     * @memberof IScheduledTaskWorker
     */
    State?: TaskState;
    /**
     * Gets the current progress.
     * @type {number}
     * @memberof IScheduledTaskWorker
     */
    CurrentProgress?: number | null;
    /**
     * Gets the triggers that define when the task will run.
     * @type {Array<TaskTriggerInfo>}
     * @memberof IScheduledTaskWorker
     */
    Triggers?: Array<TaskTriggerInfo> | null;
    /**
     * Gets the unique id.
     * @type {string}
     * @memberof IScheduledTaskWorker
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @interface ImageByNameInfo
 */
export interface ImageByNameInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the theme.
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Theme?: string | null;
    /**
     * Gets or sets the context.
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Context?: string | null;
    /**
     * Gets or sets the length of the file.
     * @type {number}
     * @memberof ImageByNameInfo
     */
    FileLength?: number;
    /**
     * Gets or sets the format.
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Format?: string | null;
}
/**
 * Class ImageInfo.
 * @export
 * @interface ImageInfo
 */
export interface ImageInfo {
    /**
     * 
     * @type {ImageType}
     * @memberof ImageInfo
     */
    ImageType?: ImageType;
    /**
     * Gets or sets the index of the image.
     * @type {number}
     * @memberof ImageInfo
     */
    ImageIndex?: number | null;
    /**
     * Gets or sets the image tag.
     * @type {string}
     * @memberof ImageInfo
     */
    ImageTag?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof ImageInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the blurhash.
     * @type {string}
     * @memberof ImageInfo
     */
    BlurHash?: string | null;
    /**
     * Gets or sets the height.
     * @type {number}
     * @memberof ImageInfo
     */
    Height?: number | null;
    /**
     * Gets or sets the width.
     * @type {number}
     * @memberof ImageInfo
     */
    Width?: number | null;
    /**
     * Gets or sets the size.
     * @type {number}
     * @memberof ImageInfo
     */
    Size?: number;
}
/**
 * 
 * @export
 * @interface ImageOption
 */
export interface ImageOption {
    /**
     * 
     * @type {ImageType}
     * @memberof ImageOption
     */
    Type?: ImageType;
    /**
     * Gets or sets the limit.
     * @type {number}
     * @memberof ImageOption
     */
    Limit?: number;
    /**
     * Gets or sets the minimum width.
     * @type {number}
     * @memberof ImageOption
     */
    MinWidth?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ImageOrientation {
    TopLeft = 'TopLeft',
    TopRight = 'TopRight',
    BottomRight = 'BottomRight',
    BottomLeft = 'BottomLeft',
    LeftTop = 'LeftTop',
    RightTop = 'RightTop',
    RightBottom = 'RightBottom',
    LeftBottom = 'LeftBottom'
}

/**
 * Class ImageProviderInfo.
 * @export
 * @interface ImageProviderInfo
 */
export interface ImageProviderInfo {
    /**
     * Gets the name.
     * @type {string}
     * @memberof ImageProviderInfo
     */
    Name?: string | null;
    /**
     * Gets the supported image types.
     * @type {Array<ImageType>}
     * @memberof ImageProviderInfo
     */
    SupportedImages?: Array<ImageType> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ImageSavingConvention {
    Legacy = 'Legacy',
    Compatible = 'Compatible'
}

/**
 * Enum ImageType.
 * @export
 * @enum {string}
 */
export enum ImageType {
    Primary = 'Primary',
    Art = 'Art',
    Backdrop = 'Backdrop',
    Banner = 'Banner',
    Logo = 'Logo',
    Thumb = 'Thumb',
    Disc = 'Disc',
    Box = 'Box',
    Screenshot = 'Screenshot',
    Menu = 'Menu',
    Chapter = 'Chapter',
    BoxRear = 'BoxRear',
    Profile = 'Profile'
}

/**
 * Class InstallationInfo.
 * @export
 * @interface InstallationInfo
 */
export interface InstallationInfo {
    /**
     * Gets or sets the guid.
     * @type {string}
     * @memberof InstallationInfo
     */
    Guid?: string;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof InstallationInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {Version}
     * @memberof InstallationInfo
     */
    Version?: Version;
    /**
     * Gets or sets the changelog for this version.
     * @type {string}
     * @memberof InstallationInfo
     */
    Changelog?: string | null;
    /**
     * Gets or sets the source URL.
     * @type {string}
     * @memberof InstallationInfo
     */
    SourceUrl?: string | null;
    /**
     * Gets or sets a checksum for the binary.
     * @type {string}
     * @memberof InstallationInfo
     */
    Checksum?: string | null;
}
/**
 * Enum IsoType.
 * @export
 * @enum {string}
 */
export enum IsoType {
    Dvd = 'Dvd',
    BluRay = 'BluRay'
}

/**
 * Class LibrarySummary.
 * @export
 * @interface ItemCounts
 */
export interface ItemCounts {
    /**
     * Gets or sets the movie count.
     * @type {number}
     * @memberof ItemCounts
     */
    MovieCount?: number;
    /**
     * Gets or sets the series count.
     * @type {number}
     * @memberof ItemCounts
     */
    SeriesCount?: number;
    /**
     * Gets or sets the episode count.
     * @type {number}
     * @memberof ItemCounts
     */
    EpisodeCount?: number;
    /**
     * Gets or sets the artist count.
     * @type {number}
     * @memberof ItemCounts
     */
    ArtistCount?: number;
    /**
     * Gets or sets the program count.
     * @type {number}
     * @memberof ItemCounts
     */
    ProgramCount?: number;
    /**
     * Gets or sets the trailer count.
     * @type {number}
     * @memberof ItemCounts
     */
    TrailerCount?: number;
    /**
     * Gets or sets the song count.
     * @type {number}
     * @memberof ItemCounts
     */
    SongCount?: number;
    /**
     * Gets or sets the album count.
     * @type {number}
     * @memberof ItemCounts
     */
    AlbumCount?: number;
    /**
     * Gets or sets the music video count.
     * @type {number}
     * @memberof ItemCounts
     */
    MusicVideoCount?: number;
    /**
     * Gets or sets the box set count.
     * @type {number}
     * @memberof ItemCounts
     */
    BoxSetCount?: number;
    /**
     * Gets or sets the book count.
     * @type {number}
     * @memberof ItemCounts
     */
    BookCount?: number;
    /**
     * Gets or sets the item count.
     * @type {number}
     * @memberof ItemCounts
     */
    ItemCount?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum KeepUntil {
    UntilDeleted = 'UntilDeleted',
    UntilSpaceNeeded = 'UntilSpaceNeeded',
    UntilWatched = 'UntilWatched',
    UntilDate = 'UntilDate'
}

/**
 * Library option info dto.
 * @export
 * @interface LibraryOptionInfoDto
 */
export interface LibraryOptionInfoDto {
    /**
     * Gets or sets name.
     * @type {string}
     * @memberof LibraryOptionInfoDto
     */
    Name?: string | null;
    /**
     * Gets or sets a value indicating whether default enabled.
     * @type {boolean}
     * @memberof LibraryOptionInfoDto
     */
    DefaultEnabled?: boolean;
}
/**
 * 
 * @export
 * @interface LibraryOptions
 */
export interface LibraryOptions {
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnablePhotos?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableRealtimeMonitor?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableChapterImageExtraction?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    ExtractChapterImagesDuringLibraryScan?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    DownloadImagesInAdvance?: boolean;
    /**
     * 
     * @type {Array<MediaPathInfo>}
     * @memberof LibraryOptions
     */
    PathInfos?: Array<MediaPathInfo> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SaveLocalMetadata?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableInternetProviders?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    ImportMissingEpisodes?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableAutomaticSeriesGrouping?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableEmbeddedTitles?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableEmbeddedEpisodeInfos?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LibraryOptions
     */
    AutomaticRefreshIntervalDays?: number;
    /**
     * Gets or sets the preferred metadata language.
     * @type {string}
     * @memberof LibraryOptions
     */
    PreferredMetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof LibraryOptions
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LibraryOptions
     */
    SeasonZeroDisplayName?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    MetadataSavers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    DisabledLocalMetadataReaders?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    LocalMetadataReaderOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    DisabledSubtitleFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    SubtitleFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SkipSubtitlesIfEmbeddedSubtitlesPresent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SkipSubtitlesIfAudioTrackMatches?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    SubtitleDownloadLanguages?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    RequirePerfectSubtitleMatch?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SaveSubtitlesWithMedia?: boolean;
    /**
     * 
     * @type {Array<TypeOptions>}
     * @memberof LibraryOptions
     */
    TypeOptions?: Array<TypeOptions> | null;
}
/**
 * Library options result dto.
 * @export
 * @interface LibraryOptionsResultDto
 */
export interface LibraryOptionsResultDto {
    /**
     * Gets or sets the metadata savers.
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryOptionsResultDto
     */
    MetadataSavers?: Array<LibraryOptionInfoDto> | null;
    /**
     * Gets or sets the metadata readers.
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryOptionsResultDto
     */
    MetadataReaders?: Array<LibraryOptionInfoDto> | null;
    /**
     * Gets or sets the subtitle fetchers.
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryOptionsResultDto
     */
    SubtitleFetchers?: Array<LibraryOptionInfoDto> | null;
    /**
     * Gets or sets the type options.
     * @type {Array<LibraryTypeOptionsDto>}
     * @memberof LibraryOptionsResultDto
     */
    TypeOptions?: Array<LibraryTypeOptionsDto> | null;
}
/**
 * Library type options dto.
 * @export
 * @interface LibraryTypeOptionsDto
 */
export interface LibraryTypeOptionsDto {
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof LibraryTypeOptionsDto
     */
    Type?: string | null;
    /**
     * Gets or sets the metadata fetchers.
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryTypeOptionsDto
     */
    MetadataFetchers?: Array<LibraryOptionInfoDto> | null;
    /**
     * Gets or sets the image fetchers.
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryTypeOptionsDto
     */
    ImageFetchers?: Array<LibraryOptionInfoDto> | null;
    /**
     * Gets or sets the supported image types.
     * @type {Array<ImageType>}
     * @memberof LibraryTypeOptionsDto
     */
    SupportedImageTypes?: Array<ImageType> | null;
    /**
     * Gets or sets the default image options.
     * @type {Array<ImageOption>}
     * @memberof LibraryTypeOptionsDto
     */
    DefaultImageOptions?: Array<ImageOption> | null;
}
/**
 * 
 * @export
 * @interface ListingsProviderInfo
 */
export interface ListingsProviderInfo {
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    ListingsId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    ZipCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Country?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    EnabledTuners?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListingsProviderInfo
     */
    EnableAllTuners?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    NewsCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    SportsCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    KidsCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    MovieCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof ListingsProviderInfo
     */
    ChannelMappings?: Array<NameValuePair> | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    MoviePrefix?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    PreferredLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    UserAgent?: string | null;
}
/**
 * 
 * @export
 * @interface LiveStreamResponse
 */
export interface LiveStreamResponse {
    /**
     * 
     * @type {MediaSourceInfo}
     * @memberof LiveStreamResponse
     */
    MediaSource?: MediaSourceInfo;
}
/**
 * 
 * @export
 * @interface LiveTvInfo
 */
export interface LiveTvInfo {
    /**
     * Gets or sets the services.
     * @type {Array<LiveTvServiceInfo>}
     * @memberof LiveTvInfo
     */
    Services?: Array<LiveTvServiceInfo> | null;
    /**
     * Gets or sets a value indicating whether this instance is enabled.
     * @type {boolean}
     * @memberof LiveTvInfo
     */
    IsEnabled?: boolean;
    /**
     * Gets or sets the enabled users.
     * @type {Array<string>}
     * @memberof LiveTvInfo
     */
    EnabledUsers?: Array<string> | null;
}
/**
 * Class ServiceInfo.
 * @export
 * @interface LiveTvServiceInfo
 */
export interface LiveTvServiceInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the home page URL.
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    HomePageUrl?: string | null;
    /**
     * 
     * @type {LiveTvServiceStatus}
     * @memberof LiveTvServiceInfo
     */
    Status?: LiveTvServiceStatus;
    /**
     * Gets or sets the status message.
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    StatusMessage?: string | null;
    /**
     * Gets or sets the version.
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    Version?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has update available.
     * @type {boolean}
     * @memberof LiveTvServiceInfo
     */
    HasUpdateAvailable?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is visible.
     * @type {boolean}
     * @memberof LiveTvServiceInfo
     */
    IsVisible?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof LiveTvServiceInfo
     */
    Tuners?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LiveTvServiceStatus {
    Ok = 'Ok',
    Unavailable = 'Unavailable'
}

/**
 * 
 * @export
 * @interface LocalizationOption
 */
export interface LocalizationOption {
    /**
     * 
     * @type {string}
     * @memberof LocalizationOption
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LocalizationOption
     */
    Value?: string | null;
}
/**
 * Enum LocationType.
 * @export
 * @enum {string}
 */
export enum LocationType {
    FileSystem = 'FileSystem',
    Remote = 'Remote',
    Virtual = 'Virtual',
    Offline = 'Offline'
}

/**
 * 
 * @export
 * @interface LogFile
 */
export interface LogFile {
    /**
     * Gets or sets the date created.
     * @type {string}
     * @memberof LogFile
     */
    DateCreated?: string;
    /**
     * Gets or sets the date modified.
     * @type {string}
     * @memberof LogFile
     */
    DateModified?: string;
    /**
     * Gets or sets the size.
     * @type {number}
     * @memberof LogFile
     */
    Size?: number;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof LogFile
     */
    Name?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LogLevel {
    Trace = 'Trace',
    Debug = 'Debug',
    Information = 'Information',
    Warning = 'Warning',
    Error = 'Error',
    Critical = 'Critical',
    None = 'None'
}

/**
 * MB Registration Record.
 * @export
 * @interface MBRegistrationRecord
 */
export interface MBRegistrationRecord {
    /**
     * Gets or sets expiration date.
     * @type {string}
     * @memberof MBRegistrationRecord
     */
    ExpirationDate?: string;
    /**
     * Gets or sets a value indicating whether is registered.
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    IsRegistered?: boolean;
    /**
     * Gets or sets a value indicating whether reg checked.
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    RegChecked?: boolean;
    /**
     * Gets or sets a value indicating whether reg error.
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    RegError?: boolean;
    /**
     * Gets or sets a value indicating whether trial version.
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    TrialVersion?: boolean;
    /**
     * Gets or sets a value indicating whether is valid.
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    IsValid?: boolean;
}
/**
 * Class MediaAttachment.
 * @export
 * @interface MediaAttachment
 */
export interface MediaAttachment {
    /**
     * Gets or sets the codec.
     * @type {string}
     * @memberof MediaAttachment
     */
    Codec?: string | null;
    /**
     * Gets or sets the codec tag.
     * @type {string}
     * @memberof MediaAttachment
     */
    CodecTag?: string | null;
    /**
     * Gets or sets the comment.
     * @type {string}
     * @memberof MediaAttachment
     */
    Comment?: string | null;
    /**
     * Gets or sets the index.
     * @type {number}
     * @memberof MediaAttachment
     */
    Index?: number;
    /**
     * Gets or sets the filename.
     * @type {string}
     * @memberof MediaAttachment
     */
    FileName?: string | null;
    /**
     * Gets or sets the MIME type.
     * @type {string}
     * @memberof MediaAttachment
     */
    MimeType?: string | null;
    /**
     * Gets or sets the delivery URL.
     * @type {string}
     * @memberof MediaAttachment
     */
    DeliveryUrl?: string | null;
}
/**
 * Media Encoder Path Dto.
 * @export
 * @interface MediaEncoderPathDto
 */
export interface MediaEncoderPathDto {
    /**
     * Gets or sets media encoder path.
     * @type {string}
     * @memberof MediaEncoderPathDto
     */
    Path?: string | null;
    /**
     * Gets or sets media encoder path type.
     * @type {string}
     * @memberof MediaEncoderPathDto
     */
    PathType?: string | null;
}
/**
 * Media Path dto.
 * @export
 * @interface MediaPathDto
 */
export interface MediaPathDto {
    /**
     * Gets or sets the name of the library.
     * @type {string}
     * @memberof MediaPathDto
     */
    Name: string;
    /**
     * Gets or sets the path to add.
     * @type {string}
     * @memberof MediaPathDto
     */
    Path?: string | null;
    /**
     * 
     * @type {MediaPathInfo}
     * @memberof MediaPathDto
     */
    PathInfo?: MediaPathInfo;
}
/**
 * 
 * @export
 * @interface MediaPathInfo
 */
export interface MediaPathInfo {
    /**
     * 
     * @type {string}
     * @memberof MediaPathInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaPathInfo
     */
    NetworkPath?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MediaProtocol {
    File = 'File',
    Http = 'Http',
    Rtmp = 'Rtmp',
    Rtsp = 'Rtsp',
    Udp = 'Udp',
    Rtp = 'Rtp',
    Ftp = 'Ftp'
}

/**
 * 
 * @export
 * @interface MediaSourceInfo
 */
export interface MediaSourceInfo {
    /**
     * 
     * @type {MediaProtocol}
     * @memberof MediaSourceInfo
     */
    Protocol?: MediaProtocol;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    EncoderPath?: string | null;
    /**
     * 
     * @type {MediaProtocol}
     * @memberof MediaSourceInfo
     */
    EncoderProtocol?: MediaProtocol;
    /**
     * 
     * @type {MediaSourceType}
     * @memberof MediaSourceInfo
     */
    Type?: MediaSourceType;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Container?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    Size?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Name?: string | null;
    /**
     * Differentiate internet url vs local network.
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IsRemote?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    ETag?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    RunTimeTicks?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    ReadAtNativeFramerate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IgnoreDts?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IgnoreIndex?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    GenPtsInput?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsDirectStream?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsDirectPlay?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IsInfiniteStream?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    RequiresOpening?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    OpenToken?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    RequiresClosing?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    LiveStreamId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    BufferMs?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    RequiresLooping?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsProbing?: boolean;
    /**
     * 
     * @type {VideoType}
     * @memberof MediaSourceInfo
     */
    VideoType?: VideoType;
    /**
     * 
     * @type {IsoType}
     * @memberof MediaSourceInfo
     */
    IsoType?: IsoType;
    /**
     * 
     * @type {Video3DFormat}
     * @memberof MediaSourceInfo
     */
    Video3DFormat?: Video3DFormat;
    /**
     * 
     * @type {Array<MediaStream>}
     * @memberof MediaSourceInfo
     */
    MediaStreams?: Array<MediaStream> | null;
    /**
     * 
     * @type {Array<MediaAttachment>}
     * @memberof MediaSourceInfo
     */
    MediaAttachments?: Array<MediaAttachment> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaSourceInfo
     */
    Formats?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    Bitrate?: number | null;
    /**
     * 
     * @type {TransportStreamTimestamp}
     * @memberof MediaSourceInfo
     */
    Timestamp?: TransportStreamTimestamp;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MediaSourceInfo
     */
    RequiredHttpHeaders?: { [key: string]: string; } | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    TranscodingUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    TranscodingSubProtocol?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    TranscodingContainer?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    AnalyzeDurationMs?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    DefaultAudioStreamIndex?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    DefaultSubtitleStreamIndex?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MediaSourceType {
    Default = 'Default',
    Grouping = 'Grouping',
    Placeholder = 'Placeholder'
}

/**
 * Class MediaStream.
 * @export
 * @interface MediaStream
 */
export interface MediaStream {
    /**
     * Gets or sets the codec.
     * @type {string}
     * @memberof MediaStream
     */
    Codec?: string | null;
    /**
     * Gets or sets the codec tag.
     * @type {string}
     * @memberof MediaStream
     */
    CodecTag?: string | null;
    /**
     * Gets or sets the language.
     * @type {string}
     * @memberof MediaStream
     */
    Language?: string | null;
    /**
     * Gets or sets the color range.
     * @type {string}
     * @memberof MediaStream
     */
    ColorRange?: string | null;
    /**
     * Gets or sets the color space.
     * @type {string}
     * @memberof MediaStream
     */
    ColorSpace?: string | null;
    /**
     * Gets or sets the color transfer.
     * @type {string}
     * @memberof MediaStream
     */
    ColorTransfer?: string | null;
    /**
     * Gets or sets the color primaries.
     * @type {string}
     * @memberof MediaStream
     */
    ColorPrimaries?: string | null;
    /**
     * Gets or sets the comment.
     * @type {string}
     * @memberof MediaStream
     */
    Comment?: string | null;
    /**
     * Gets or sets the time base.
     * @type {string}
     * @memberof MediaStream
     */
    TimeBase?: string | null;
    /**
     * Gets or sets the codec time base.
     * @type {string}
     * @memberof MediaStream
     */
    CodecTimeBase?: string | null;
    /**
     * Gets or sets the title.
     * @type {string}
     * @memberof MediaStream
     */
    Title?: string | null;
    /**
     * Gets or sets the video range.
     * @type {string}
     * @memberof MediaStream
     */
    VideoRange?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    localizedUndefined?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    localizedDefault?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    localizedForced?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    DisplayTitle?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    NalLengthSize?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is interlaced.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsInterlaced?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsAVC?: boolean | null;
    /**
     * Gets or sets the channel layout.
     * @type {string}
     * @memberof MediaStream
     */
    ChannelLayout?: string | null;
    /**
     * Gets or sets the bit rate.
     * @type {number}
     * @memberof MediaStream
     */
    BitRate?: number | null;
    /**
     * Gets or sets the bit depth.
     * @type {number}
     * @memberof MediaStream
     */
    BitDepth?: number | null;
    /**
     * Gets or sets the reference frames.
     * @type {number}
     * @memberof MediaStream
     */
    RefFrames?: number | null;
    /**
     * Gets or sets the length of the packet.
     * @type {number}
     * @memberof MediaStream
     */
    PacketLength?: number | null;
    /**
     * Gets or sets the channels.
     * @type {number}
     * @memberof MediaStream
     */
    Channels?: number | null;
    /**
     * Gets or sets the sample rate.
     * @type {number}
     * @memberof MediaStream
     */
    SampleRate?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is default.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsDefault?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is forced.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsForced?: boolean;
    /**
     * Gets or sets the height.
     * @type {number}
     * @memberof MediaStream
     */
    Height?: number | null;
    /**
     * Gets or sets the width.
     * @type {number}
     * @memberof MediaStream
     */
    Width?: number | null;
    /**
     * Gets or sets the average frame rate.
     * @type {number}
     * @memberof MediaStream
     */
    AverageFrameRate?: number | null;
    /**
     * Gets or sets the real frame rate.
     * @type {number}
     * @memberof MediaStream
     */
    RealFrameRate?: number | null;
    /**
     * Gets or sets the profile.
     * @type {string}
     * @memberof MediaStream
     */
    Profile?: string | null;
    /**
     * 
     * @type {MediaStreamType}
     * @memberof MediaStream
     */
    Type?: MediaStreamType;
    /**
     * Gets or sets the aspect ratio.
     * @type {string}
     * @memberof MediaStream
     */
    AspectRatio?: string | null;
    /**
     * Gets or sets the index.
     * @type {number}
     * @memberof MediaStream
     */
    Index?: number;
    /**
     * Gets or sets the score.
     * @type {number}
     * @memberof MediaStream
     */
    Score?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is external.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsExternal?: boolean;
    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof MediaStream
     */
    DeliveryMethod?: SubtitleDeliveryMethod;
    /**
     * Gets or sets the delivery URL.
     * @type {string}
     * @memberof MediaStream
     */
    DeliveryUrl?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is external URL.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsExternalUrl?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsTextSubtitleStream?: boolean;
    /**
     * Gets or sets a value indicating whether [supports external stream].
     * @type {boolean}
     * @memberof MediaStream
     */
    SupportsExternalStream?: boolean;
    /**
     * Gets or sets the filename.
     * @type {string}
     * @memberof MediaStream
     */
    Path?: string | null;
    /**
     * Gets or sets the pixel format.
     * @type {string}
     * @memberof MediaStream
     */
    PixelFormat?: string | null;
    /**
     * Gets or sets the level.
     * @type {number}
     * @memberof MediaStream
     */
    Level?: number | null;
    /**
     * Gets a value indicating whether this instance is anamorphic.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsAnamorphic?: boolean | null;
}
/**
 * Enum MediaStreamType.
 * @export
 * @enum {string}
 */
export enum MediaStreamType {
    Audio = 'Audio',
    Video = 'Video',
    Subtitle = 'Subtitle',
    EmbeddedImage = 'EmbeddedImage'
}

/**
 * Media Update Info Dto.
 * @export
 * @interface MediaUpdateInfoDto
 */
export interface MediaUpdateInfoDto {
    /**
     * Gets or sets media path.
     * @type {string}
     * @memberof MediaUpdateInfoDto
     */
    Path?: string | null;
    /**
     * Gets or sets media update type.  Created, Modified, Deleted.
     * @type {string}
     * @memberof MediaUpdateInfoDto
     */
    UpdateType?: string | null;
}
/**
 * 
 * @export
 * @interface MediaUrl
 */
export interface MediaUrl {
    /**
     * 
     * @type {string}
     * @memberof MediaUrl
     */
    Url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaUrl
     */
    Name?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataEditorInfo
 */
export interface MetadataEditorInfo {
    /**
     * 
     * @type {Array<ParentalRating>}
     * @memberof MetadataEditorInfo
     */
    ParentalRatingOptions?: Array<ParentalRating> | null;
    /**
     * 
     * @type {Array<CountryInfo>}
     * @memberof MetadataEditorInfo
     */
    Countries?: Array<CountryInfo> | null;
    /**
     * 
     * @type {Array<CultureDto>}
     * @memberof MetadataEditorInfo
     */
    Cultures?: Array<CultureDto> | null;
    /**
     * 
     * @type {Array<ExternalIdInfo>}
     * @memberof MetadataEditorInfo
     */
    ExternalIdInfos?: Array<ExternalIdInfo> | null;
    /**
     * 
     * @type {string}
     * @memberof MetadataEditorInfo
     */
    ContentType?: string | null;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof MetadataEditorInfo
     */
    ContentTypeOptions?: Array<NameValuePair> | null;
}
/**
 * Enum MetadataFields.
 * @export
 * @enum {string}
 */
export enum MetadataField {
    Cast = 'Cast',
    Genres = 'Genres',
    ProductionLocations = 'ProductionLocations',
    Studios = 'Studios',
    Tags = 'Tags',
    Name = 'Name',
    Overview = 'Overview',
    Runtime = 'Runtime',
    OfficialRating = 'OfficialRating'
}

/**
 * Class MetadataOptions.
 * @export
 * @interface MetadataOptions
 */
export interface MetadataOptions {
    /**
     * 
     * @type {string}
     * @memberof MetadataOptions
     */
    ItemType?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    DisabledMetadataSavers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    LocalMetadataReaderOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    DisabledMetadataFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    MetadataFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    DisabledImageFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    ImageFetcherOrder?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MetadataRefreshMode {
    None = 'None',
    ValidationOnly = 'ValidationOnly',
    Default = 'Default',
    FullRefresh = 'FullRefresh'
}

/**
 * 
 * @export
 * @interface MovieInfo
 */
export interface MovieInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof MovieInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof MovieInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof MovieInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof MovieInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof MovieInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof MovieInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MovieInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MovieInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MovieInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MovieInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface MovieInfoRemoteSearchQuery
 */
export interface MovieInfoRemoteSearchQuery {
    /**
     * 
     * @type {MovieInfo}
     * @memberof MovieInfoRemoteSearchQuery
     */
    SearchInfo?: MovieInfo;
    /**
     * 
     * @type {string}
     * @memberof MovieInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof MovieInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof MovieInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface MusicVideoInfo
 */
export interface MusicVideoInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof MusicVideoInfo
     */
    Artists?: Array<string> | null;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof MusicVideoInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof MusicVideoInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof MusicVideoInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof MusicVideoInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof MusicVideoInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof MusicVideoInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MusicVideoInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MusicVideoInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MusicVideoInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface MusicVideoInfoRemoteSearchQuery
 */
export interface MusicVideoInfoRemoteSearchQuery {
    /**
     * 
     * @type {MusicVideoInfo}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    SearchInfo?: MusicVideoInfo;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface NameGuidPair
 */
export interface NameGuidPair {
    /**
     * 
     * @type {string}
     * @memberof NameGuidPair
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NameGuidPair
     */
    Id?: string;
}
/**
 * 
 * @export
 * @interface NameIdPair
 */
export interface NameIdPair {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof NameIdPair
     */
    Name?: string | null;
    /**
     * Gets or sets the identifier.
     * @type {string}
     * @memberof NameIdPair
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @interface NameValuePair
 */
export interface NameValuePair {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof NameValuePair
     */
    Name?: string | null;
    /**
     * Gets or sets the value.
     * @type {string}
     * @memberof NameValuePair
     */
    Value?: string | null;
}
/**
 * The notification DTO.
 * @export
 * @interface NotificationDto
 */
export interface NotificationDto {
    /**
     * Gets or sets the notification ID. Defaults to an empty string.
     * @type {string}
     * @memberof NotificationDto
     */
    Id?: string | null;
    /**
     * Gets or sets the notification\'s user ID. Defaults to an empty string.
     * @type {string}
     * @memberof NotificationDto
     */
    UserId?: string | null;
    /**
     * Gets or sets the notification date.
     * @type {string}
     * @memberof NotificationDto
     */
    Date?: string;
    /**
     * Gets or sets a value indicating whether the notification has been read. Defaults to false.
     * @type {boolean}
     * @memberof NotificationDto
     */
    IsRead?: boolean;
    /**
     * Gets or sets the notification\'s name. Defaults to an empty string.
     * @type {string}
     * @memberof NotificationDto
     */
    Name?: string | null;
    /**
     * Gets or sets the notification\'s description. Defaults to an empty string.
     * @type {string}
     * @memberof NotificationDto
     */
    Description?: string | null;
    /**
     * Gets or sets the notification\'s URL. Defaults to an empty string.
     * @type {string}
     * @memberof NotificationDto
     */
    Url?: string | null;
    /**
     * 
     * @type {NotificationLevel}
     * @memberof NotificationDto
     */
    Level?: NotificationLevel;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum NotificationLevel {
    Normal = 'Normal',
    Warning = 'Warning',
    Error = 'Error'
}

/**
 * A list of notifications with the total record count for pagination.
 * @export
 * @interface NotificationResultDto
 */
export interface NotificationResultDto {
    /**
     * Gets or sets the current page of notifications.
     * @type {Array<NotificationDto>}
     * @memberof NotificationResultDto
     */
    Notifications?: Array<NotificationDto> | null;
    /**
     * Gets or sets the total number of notifications.
     * @type {number}
     * @memberof NotificationResultDto
     */
    TotalRecordCount?: number;
}
/**
 * 
 * @export
 * @interface NotificationTypeInfo
 */
export interface NotificationTypeInfo {
    /**
     * 
     * @type {string}
     * @memberof NotificationTypeInfo
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationTypeInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationTypeInfo
     */
    Enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationTypeInfo
     */
    Category?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationTypeInfo
     */
    IsBasedOnUserEvent?: boolean;
}
/**
 * The notification summary DTO.
 * @export
 * @interface NotificationsSummaryDto
 */
export interface NotificationsSummaryDto {
    /**
     * Gets or sets the number of unread notifications.
     * @type {number}
     * @memberof NotificationsSummaryDto
     */
    UnreadCount?: number;
    /**
     * 
     * @type {NotificationLevel}
     * @memberof NotificationsSummaryDto
     */
    MaxUnreadNotificationLevel?: NotificationLevel;
}
/**
 * Open live stream dto.
 * @export
 * @interface OpenLiveStreamDto
 */
export interface OpenLiveStreamDto {
    /**
     * 
     * @type {DeviceProfile}
     * @memberof OpenLiveStreamDto
     */
    DeviceProfile?: DeviceProfile;
    /**
     * Gets or sets the device play protocols.
     * @type {Array<MediaProtocol>}
     * @memberof OpenLiveStreamDto
     */
    DirectPlayProtocols?: Array<MediaProtocol> | null;
}
/**
 * Class PackageInfo.
 * @export
 * @interface PackageInfo
 */
export interface PackageInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof PackageInfo
     */
    name?: string | null;
    /**
     * Gets or sets a long description of the plugin containing features or helpful explanations.
     * @type {string}
     * @memberof PackageInfo
     */
    description?: string | null;
    /**
     * Gets or sets a short overview of what the plugin does.
     * @type {string}
     * @memberof PackageInfo
     */
    overview?: string | null;
    /**
     * Gets or sets the owner.
     * @type {string}
     * @memberof PackageInfo
     */
    owner?: string | null;
    /**
     * Gets or sets the category.
     * @type {string}
     * @memberof PackageInfo
     */
    category?: string | null;
    /**
     * The guid of the assembly associated with this plugin.  This is used to identify the proper item for automatic updates.
     * @type {string}
     * @memberof PackageInfo
     */
    guid?: string | null;
    /**
     * Gets or sets the versions.
     * @type {Array<VersionInfo>}
     * @memberof PackageInfo
     */
    versions?: Array<VersionInfo> | null;
}
/**
 * Class ParentalRating.
 * @export
 * @interface ParentalRating
 */
export interface ParentalRating {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ParentalRating
     */
    Name?: string | null;
    /**
     * Gets or sets the value.
     * @type {number}
     * @memberof ParentalRating
     */
    Value?: number;
}
/**
 * 
 * @export
 * @interface PathSubstitution
 */
export interface PathSubstitution {
    /**
     * 
     * @type {string}
     * @memberof PathSubstitution
     */
    From?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PathSubstitution
     */
    To?: string | null;
}
/**
 * 
 * @export
 * @interface PersonLookupInfo
 */
export interface PersonLookupInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof PersonLookupInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof PersonLookupInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof PersonLookupInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof PersonLookupInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof PersonLookupInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof PersonLookupInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PersonLookupInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PersonLookupInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PersonLookupInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface PersonLookupInfoRemoteSearchQuery
 */
export interface PersonLookupInfoRemoteSearchQuery {
    /**
     * 
     * @type {PersonLookupInfo}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    SearchInfo?: PersonLookupInfo;
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface PinRedeemResult
 */
export interface PinRedeemResult {
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Users.PinRedeemResult is success.
     * @type {boolean}
     * @memberof PinRedeemResult
     */
    Success?: boolean;
    /**
     * Gets or sets the users reset.
     * @type {Array<string>}
     * @memberof PinRedeemResult
     */
    UsersReset?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PlayAccess {
    Full = 'Full',
    None = 'None'
}

/**
 * Enum PlayCommand.
 * @export
 * @enum {string}
 */
export enum PlayCommand {
    PlayNow = 'PlayNow',
    PlayNext = 'PlayNext',
    PlayLast = 'PlayLast',
    PlayInstantMix = 'PlayInstantMix',
    PlayShuffle = 'PlayShuffle'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PlayMethod {
    Transcode = 'Transcode',
    DirectStream = 'DirectStream',
    DirectPlay = 'DirectPlay'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PlaybackErrorCode {
    NotAllowed = 'NotAllowed',
    NoCompatibleStream = 'NoCompatibleStream',
    RateLimitExceeded = 'RateLimitExceeded'
}

/**
 * Class PlaybackInfoResponse.
 * @export
 * @interface PlaybackInfoResponse
 */
export interface PlaybackInfoResponse {
    /**
     * Gets or sets the media sources.
     * @type {Array<MediaSourceInfo>}
     * @memberof PlaybackInfoResponse
     */
    MediaSources?: Array<MediaSourceInfo> | null;
    /**
     * Gets or sets the play session identifier.
     * @type {string}
     * @memberof PlaybackInfoResponse
     */
    PlaySessionId?: string | null;
    /**
     * 
     * @type {PlaybackErrorCode}
     * @memberof PlaybackInfoResponse
     */
    ErrorCode?: PlaybackErrorCode;
}
/**
 * Class PlaybackProgressInfo.
 * @export
 * @interface PlaybackProgressInfo
 */
export interface PlaybackProgressInfo {
    /**
     * Gets or sets a value indicating whether this instance can seek.
     * @type {boolean}
     * @memberof PlaybackProgressInfo
     */
    CanSeek?: boolean;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof PlaybackProgressInfo
     */
    Item?: BaseItemDto;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    ItemId?: string;
    /**
     * Gets or sets the session id.
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    SessionId?: string | null;
    /**
     * Gets or sets the media version identifier.
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the index of the audio stream.
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the index of the subtitle stream.
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is paused.
     * @type {boolean}
     * @memberof PlaybackProgressInfo
     */
    IsPaused?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is muted.
     * @type {boolean}
     * @memberof PlaybackProgressInfo
     */
    IsMuted?: boolean;
    /**
     * Gets or sets the position ticks.
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    PositionTicks?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    PlaybackStartTimeTicks?: number | null;
    /**
     * Gets or sets the volume level.
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    VolumeLevel?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    Brightness?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    AspectRatio?: string | null;
    /**
     * 
     * @type {PlayMethod}
     * @memberof PlaybackProgressInfo
     */
    PlayMethod?: PlayMethod;
    /**
     * Gets or sets the live stream identifier.
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    LiveStreamId?: string | null;
    /**
     * Gets or sets the play session identifier.
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    PlaySessionId?: string | null;
    /**
     * 
     * @type {RepeatMode}
     * @memberof PlaybackProgressInfo
     */
    RepeatMode?: RepeatMode;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof PlaybackProgressInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    PlaylistItemId?: string | null;
}
/**
 * Class PlaybackStartInfo.
 * @export
 * @interface PlaybackStartInfo
 */
export interface PlaybackStartInfo {
    /**
     * Gets or sets a value indicating whether this instance can seek.
     * @type {boolean}
     * @memberof PlaybackStartInfo
     */
    CanSeek?: boolean;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof PlaybackStartInfo
     */
    Item?: BaseItemDto;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    ItemId?: string;
    /**
     * Gets or sets the session id.
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    SessionId?: string | null;
    /**
     * Gets or sets the media version identifier.
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the index of the audio stream.
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the index of the subtitle stream.
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is paused.
     * @type {boolean}
     * @memberof PlaybackStartInfo
     */
    IsPaused?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is muted.
     * @type {boolean}
     * @memberof PlaybackStartInfo
     */
    IsMuted?: boolean;
    /**
     * Gets or sets the position ticks.
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    PositionTicks?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    PlaybackStartTimeTicks?: number | null;
    /**
     * Gets or sets the volume level.
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    VolumeLevel?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    Brightness?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    AspectRatio?: string | null;
    /**
     * 
     * @type {PlayMethod}
     * @memberof PlaybackStartInfo
     */
    PlayMethod?: PlayMethod;
    /**
     * Gets or sets the live stream identifier.
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    LiveStreamId?: string | null;
    /**
     * Gets or sets the play session identifier.
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    PlaySessionId?: string | null;
    /**
     * 
     * @type {RepeatMode}
     * @memberof PlaybackStartInfo
     */
    RepeatMode?: RepeatMode;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof PlaybackStartInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    PlaylistItemId?: string | null;
}
/**
 * Class PlaybackStopInfo.
 * @export
 * @interface PlaybackStopInfo
 */
export interface PlaybackStopInfo {
    /**
     * 
     * @type {BaseItemDto}
     * @memberof PlaybackStopInfo
     */
    Item?: BaseItemDto;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    ItemId?: string;
    /**
     * Gets or sets the session id.
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    SessionId?: string | null;
    /**
     * Gets or sets the media version identifier.
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the position ticks.
     * @type {number}
     * @memberof PlaybackStopInfo
     */
    PositionTicks?: number | null;
    /**
     * Gets or sets the live stream identifier.
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    LiveStreamId?: string | null;
    /**
     * Gets or sets the play session identifier.
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    PlaySessionId?: string | null;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Session.PlaybackStopInfo is failed.
     * @type {boolean}
     * @memberof PlaybackStopInfo
     */
    Failed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    NextMediaType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    PlaylistItemId?: string | null;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof PlaybackStopInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
}
/**
 * 
 * @export
 * @interface PlayerStateInfo
 */
export interface PlayerStateInfo {
    /**
     * Gets or sets the now playing position ticks.
     * @type {number}
     * @memberof PlayerStateInfo
     */
    PositionTicks?: number | null;
    /**
     * Gets or sets a value indicating whether this instance can seek.
     * @type {boolean}
     * @memberof PlayerStateInfo
     */
    CanSeek?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is paused.
     * @type {boolean}
     * @memberof PlayerStateInfo
     */
    IsPaused?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is muted.
     * @type {boolean}
     * @memberof PlayerStateInfo
     */
    IsMuted?: boolean;
    /**
     * Gets or sets the volume level.
     * @type {number}
     * @memberof PlayerStateInfo
     */
    VolumeLevel?: number | null;
    /**
     * Gets or sets the index of the now playing audio stream.
     * @type {number}
     * @memberof PlayerStateInfo
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the index of the now playing subtitle stream.
     * @type {number}
     * @memberof PlayerStateInfo
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets the now playing media version identifier.
     * @type {string}
     * @memberof PlayerStateInfo
     */
    MediaSourceId?: string | null;
    /**
     * 
     * @type {PlayMethod}
     * @memberof PlayerStateInfo
     */
    PlayMethod?: PlayMethod;
    /**
     * 
     * @type {RepeatMode}
     * @memberof PlayerStateInfo
     */
    RepeatMode?: RepeatMode;
}
/**
 * 
 * @export
 * @interface PlaylistCreationResult
 */
export interface PlaylistCreationResult {
    /**
     * 
     * @type {string}
     * @memberof PlaylistCreationResult
     */
    Id?: string | null;
}
/**
 * Enum PlaystateCommand.
 * @export
 * @enum {string}
 */
export enum PlaystateCommand {
    Stop = 'Stop',
    Pause = 'Pause',
    Unpause = 'Unpause',
    NextTrack = 'NextTrack',
    PreviousTrack = 'PreviousTrack',
    Seek = 'Seek',
    Rewind = 'Rewind',
    FastForward = 'FastForward',
    PlayPause = 'PlayPause'
}

/**
 * This is a serializable stub class that is used by the api to provide information about installed plugins.
 * @export
 * @interface PluginInfo
 */
export interface PluginInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof PluginInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the version.
     * @type {string}
     * @memberof PluginInfo
     */
    Version?: string | null;
    /**
     * Gets or sets the name of the configuration file.
     * @type {string}
     * @memberof PluginInfo
     */
    ConfigurationFileName?: string | null;
    /**
     * Gets or sets the description.
     * @type {string}
     * @memberof PluginInfo
     */
    Description?: string | null;
    /**
     * Gets or sets the unique id.
     * @type {string}
     * @memberof PluginInfo
     */
    Id?: string | null;
    /**
     * Gets or sets a value indicating whether the plugin can be uninstalled.
     * @type {boolean}
     * @memberof PluginInfo
     */
    CanUninstall?: boolean;
    /**
     * Gets or sets the image URL.
     * @type {string}
     * @memberof PluginInfo
     */
    ImageUrl?: string | null;
}
/**
 * Plugin security info.
 * @export
 * @interface PluginSecurityInfo
 */
export interface PluginSecurityInfo {
    /**
     * Gets or sets the supporter key.
     * @type {string}
     * @memberof PluginSecurityInfo
     */
    SupporterKey?: string | null;
    /**
     * Gets or sets a value indicating whether is mb supporter.
     * @type {boolean}
     * @memberof PluginSecurityInfo
     */
    IsMbSupporter?: boolean;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    title?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    status?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    detail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    instance?: string | null;
}
/**
 * 
 * @export
 * @interface ProfileCondition
 */
export interface ProfileCondition {
    /**
     * 
     * @type {ProfileConditionType}
     * @memberof ProfileCondition
     */
    Condition?: ProfileConditionType;
    /**
     * 
     * @type {ProfileConditionValue}
     * @memberof ProfileCondition
     */
    Property?: ProfileConditionValue;
    /**
     * 
     * @type {string}
     * @memberof ProfileCondition
     */
    Value?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCondition
     */
    IsRequired?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ProfileConditionType {
    Equals = 'Equals',
    NotEquals = 'NotEquals',
    LessThanEqual = 'LessThanEqual',
    GreaterThanEqual = 'GreaterThanEqual',
    EqualsAny = 'EqualsAny'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ProfileConditionValue {
    AudioChannels = 'AudioChannels',
    AudioBitrate = 'AudioBitrate',
    AudioProfile = 'AudioProfile',
    Width = 'Width',
    Height = 'Height',
    Has64BitOffsets = 'Has64BitOffsets',
    PacketLength = 'PacketLength',
    VideoBitDepth = 'VideoBitDepth',
    VideoBitrate = 'VideoBitrate',
    VideoFramerate = 'VideoFramerate',
    VideoLevel = 'VideoLevel',
    VideoProfile = 'VideoProfile',
    VideoTimestamp = 'VideoTimestamp',
    IsAnamorphic = 'IsAnamorphic',
    RefFrames = 'RefFrames',
    NumAudioStreams = 'NumAudioStreams',
    NumVideoStreams = 'NumVideoStreams',
    IsSecondaryAudio = 'IsSecondaryAudio',
    VideoCodecTag = 'VideoCodecTag',
    IsAvc = 'IsAvc',
    IsInterlaced = 'IsInterlaced',
    AudioSampleRate = 'AudioSampleRate',
    AudioBitDepth = 'AudioBitDepth'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ProgramAudio {
    Mono = 'Mono',
    Stereo = 'Stereo',
    Dolby = 'Dolby',
    DolbyDigital = 'DolbyDigital',
    Thx = 'Thx',
    Atmos = 'Atmos'
}

/**
 * 
 * @export
 * @interface PublicSystemInfo
 */
export interface PublicSystemInfo {
    /**
     * Gets or sets the local address.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    LocalAddress?: string | null;
    /**
     * Gets or sets the name of the server.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    ServerName?: string | null;
    /**
     * Gets or sets the server version.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    Version?: string | null;
    /**
     * Gets or sets the product name. This is the AssemblyProduct name.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    ProductName?: string | null;
    /**
     * Gets or sets the operating system.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    OperatingSystem?: string | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    Id?: string | null;
    /**
     * Gets or sets a value indicating whether the startup wizard is completed.
     * @type {boolean}
     * @memberof PublicSystemInfo
     */
    StartupWizardCompleted?: boolean;
}
/**
 * 
 * @export
 * @interface QueryFilters
 */
export interface QueryFilters {
    /**
     * 
     * @type {Array<NameGuidPair>}
     * @memberof QueryFilters
     */
    Genres?: Array<NameGuidPair> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFilters
     */
    Tags?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface QueryFiltersLegacy
 */
export interface QueryFiltersLegacy {
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFiltersLegacy
     */
    Genres?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFiltersLegacy
     */
    Tags?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFiltersLegacy
     */
    OfficialRatings?: Array<string> | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof QueryFiltersLegacy
     */
    Years?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface QueueItem
 */
export interface QueueItem {
    /**
     * 
     * @type {string}
     * @memberof QueueItem
     */
    Id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueItem
     */
    PlaylistItemId?: string | null;
}
/**
 * The quick connect request body.
 * @export
 * @interface QuickConnectDto
 */
export interface QuickConnectDto {
    /**
     * Gets or sets the quick connect token.
     * @type {string}
     * @memberof QuickConnectDto
     */
    Token: string;
}
/**
 * Stores the result of an incoming quick connect request.
 * @export
 * @interface QuickConnectResult
 */
export interface QuickConnectResult {
    /**
     * Gets a value indicating whether this request is authorized.
     * @type {boolean}
     * @memberof QuickConnectResult
     */
    Authenticated?: boolean;
    /**
     * Gets or sets the secret value used to uniquely identify this request. Can be used to retrieve authentication information.
     * @type {string}
     * @memberof QuickConnectResult
     */
    Secret?: string | null;
    /**
     * Gets or sets the user facing code used so the user can quickly differentiate this request from others.
     * @type {string}
     * @memberof QuickConnectResult
     */
    Code?: string | null;
    /**
     * Gets or sets the private access token.
     * @type {string}
     * @memberof QuickConnectResult
     */
    Authentication?: string | null;
    /**
     * Gets or sets an error message.
     * @type {string}
     * @memberof QuickConnectResult
     */
    Error?: string | null;
    /**
     * Gets or sets the DateTime that this request was created.
     * @type {string}
     * @memberof QuickConnectResult
     */
    DateAdded?: string | null;
}
/**
 * Quick connect state.
 * @export
 * @enum {string}
 */
export enum QuickConnectState {
    Unavailable = 'Unavailable',
    Available = 'Available',
    Active = 'Active'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RatingType {
    Score = 'Score',
    Likes = 'Likes'
}

/**
 * 
 * @export
 * @interface RecommendationDto
 */
export interface RecommendationDto {
    /**
     * 
     * @type {Array<BaseItemDto>}
     * @memberof RecommendationDto
     */
    Items?: Array<BaseItemDto> | null;
    /**
     * 
     * @type {RecommendationType}
     * @memberof RecommendationDto
     */
    RecommendationType?: RecommendationType;
    /**
     * 
     * @type {string}
     * @memberof RecommendationDto
     */
    BaselineItemName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecommendationDto
     */
    CategoryId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RecommendationType {
    SimilarToRecentlyPlayed = 'SimilarToRecentlyPlayed',
    SimilarToLikedItem = 'SimilarToLikedItem',
    HasDirectorFromRecentlyPlayed = 'HasDirectorFromRecentlyPlayed',
    HasActorFromRecentlyPlayed = 'HasActorFromRecentlyPlayed',
    HasLikedDirector = 'HasLikedDirector',
    HasLikedActor = 'HasLikedActor'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RecordingStatus {
    New = 'New',
    InProgress = 'InProgress',
    Completed = 'Completed',
    Cancelled = 'Cancelled',
    ConflictedOk = 'ConflictedOk',
    ConflictedNotOk = 'ConflictedNotOk',
    Error = 'Error'
}

/**
 * Class RemoteImageInfo.
 * @export
 * @interface RemoteImageInfo
 */
export interface RemoteImageInfo {
    /**
     * Gets or sets the name of the provider.
     * @type {string}
     * @memberof RemoteImageInfo
     */
    ProviderName?: string | null;
    /**
     * Gets or sets the URL.
     * @type {string}
     * @memberof RemoteImageInfo
     */
    Url?: string | null;
    /**
     * Gets a url used for previewing a smaller version.
     * @type {string}
     * @memberof RemoteImageInfo
     */
    ThumbnailUrl?: string | null;
    /**
     * Gets or sets the height.
     * @type {number}
     * @memberof RemoteImageInfo
     */
    Height?: number | null;
    /**
     * Gets or sets the width.
     * @type {number}
     * @memberof RemoteImageInfo
     */
    Width?: number | null;
    /**
     * Gets or sets the community rating.
     * @type {number}
     * @memberof RemoteImageInfo
     */
    CommunityRating?: number | null;
    /**
     * Gets or sets the vote count.
     * @type {number}
     * @memberof RemoteImageInfo
     */
    VoteCount?: number | null;
    /**
     * Gets or sets the language.
     * @type {string}
     * @memberof RemoteImageInfo
     */
    Language?: string | null;
    /**
     * 
     * @type {ImageType}
     * @memberof RemoteImageInfo
     */
    Type?: ImageType;
    /**
     * 
     * @type {RatingType}
     * @memberof RemoteImageInfo
     */
    RatingType?: RatingType;
}
/**
 * Class RemoteImageResult.
 * @export
 * @interface RemoteImageResult
 */
export interface RemoteImageResult {
    /**
     * Gets or sets the images.
     * @type {Array<RemoteImageInfo>}
     * @memberof RemoteImageResult
     */
    Images?: Array<RemoteImageInfo> | null;
    /**
     * Gets or sets the total record count.
     * @type {number}
     * @memberof RemoteImageResult
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the providers.
     * @type {Array<string>}
     * @memberof RemoteImageResult
     */
    Providers?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface RemoteSearchResult
 */
export interface RemoteSearchResult {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof RemoteSearchResult
     */
    Name?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof RemoteSearchResult
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof RemoteSearchResult
     */
    ProductionYear?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSearchResult
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSearchResult
     */
    IndexNumberEnd?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSearchResult
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    ImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    Overview?: string | null;
    /**
     * 
     * @type {RemoteSearchResult}
     * @memberof RemoteSearchResult
     */
    AlbumArtist?: RemoteSearchResult;
    /**
     * 
     * @type {Array<RemoteSearchResult>}
     * @memberof RemoteSearchResult
     */
    Artists?: Array<RemoteSearchResult> | null;
}
/**
 * 
 * @export
 * @interface RemoteSubtitleInfo
 */
export interface RemoteSubtitleInfo {
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    ThreeLetterISOLanguageName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    ProviderName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Format?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Author?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Comment?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    DateCreated?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSubtitleInfo
     */
    CommunityRating?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSubtitleInfo
     */
    DownloadCount?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteSubtitleInfo
     */
    IsHashMatch?: boolean | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RepeatMode {
    RepeatNone = 'RepeatNone',
    RepeatAll = 'RepeatAll',
    RepeatOne = 'RepeatOne'
}

/**
 * Class RepositoryInfo.
 * @export
 * @interface RepositoryInfo
 */
export interface RepositoryInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof RepositoryInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the URL.
     * @type {string}
     * @memberof RepositoryInfo
     */
    Url?: string | null;
}
/**
 * 
 * @export
 * @interface ResponseProfile
 */
export interface ResponseProfile {
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    Container?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof ResponseProfile
     */
    Type?: DlnaProfileType;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    OrgPn?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    MimeType?: string | null;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof ResponseProfile
     */
    Conditions?: Array<ProfileCondition> | null;
}
/**
 * An enum representing the axis that should be scrolled.
 * @export
 * @enum {string}
 */
export enum ScrollDirection {
    Horizontal = 'Horizontal',
    Vertical = 'Vertical'
}

/**
 * Class SearchHintResult.
 * @export
 * @interface SearchHint
 */
export interface SearchHint {
    /**
     * Gets or sets the item id.
     * @type {string}
     * @memberof SearchHint
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    Id?: string;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof SearchHint
     */
    Name?: string | null;
    /**
     * Gets or sets the matched term.
     * @type {string}
     * @memberof SearchHint
     */
    MatchedTerm?: string | null;
    /**
     * Gets or sets the index number.
     * @type {number}
     * @memberof SearchHint
     */
    IndexNumber?: number | null;
    /**
     * Gets or sets the production year.
     * @type {number}
     * @memberof SearchHint
     */
    ProductionYear?: number | null;
    /**
     * Gets or sets the parent index number.
     * @type {number}
     * @memberof SearchHint
     */
    ParentIndexNumber?: number | null;
    /**
     * Gets or sets the image tag.
     * @type {string}
     * @memberof SearchHint
     */
    PrimaryImageTag?: string | null;
    /**
     * Gets or sets the thumb image tag.
     * @type {string}
     * @memberof SearchHint
     */
    ThumbImageTag?: string | null;
    /**
     * Gets or sets the thumb image item identifier.
     * @type {string}
     * @memberof SearchHint
     */
    ThumbImageItemId?: string | null;
    /**
     * Gets or sets the backdrop image tag.
     * @type {string}
     * @memberof SearchHint
     */
    BackdropImageTag?: string | null;
    /**
     * Gets or sets the backdrop image item identifier.
     * @type {string}
     * @memberof SearchHint
     */
    BackdropImageItemId?: string | null;
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof SearchHint
     */
    Type?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SearchHint
     */
    IsFolder?: boolean | null;
    /**
     * Gets or sets the run time ticks.
     * @type {number}
     * @memberof SearchHint
     */
    RunTimeTicks?: number | null;
    /**
     * Gets or sets the type of the media.
     * @type {string}
     * @memberof SearchHint
     */
    MediaType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    StartDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    EndDate?: string | null;
    /**
     * Gets or sets the series.
     * @type {string}
     * @memberof SearchHint
     */
    Series?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    Status?: string | null;
    /**
     * Gets or sets the album.
     * @type {string}
     * @memberof SearchHint
     */
    Album?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    AlbumId?: string;
    /**
     * Gets or sets the album artist.
     * @type {string}
     * @memberof SearchHint
     */
    AlbumArtist?: string | null;
    /**
     * Gets or sets the artists.
     * @type {Array<string>}
     * @memberof SearchHint
     */
    Artists?: Array<string> | null;
    /**
     * Gets or sets the song count.
     * @type {number}
     * @memberof SearchHint
     */
    SongCount?: number | null;
    /**
     * Gets or sets the episode count.
     * @type {number}
     * @memberof SearchHint
     */
    EpisodeCount?: number | null;
    /**
     * Gets or sets the channel identifier.
     * @type {string}
     * @memberof SearchHint
     */
    ChannelId?: string;
    /**
     * Gets or sets the name of the channel.
     * @type {string}
     * @memberof SearchHint
     */
    ChannelName?: string | null;
    /**
     * Gets or sets the primary image aspect ratio.
     * @type {number}
     * @memberof SearchHint
     */
    PrimaryImageAspectRatio?: number | null;
}
/**
 * Class SearchHintResult.
 * @export
 * @interface SearchHintResult
 */
export interface SearchHintResult {
    /**
     * Gets or sets the search hints.
     * @type {Array<SearchHint>}
     * @memberof SearchHintResult
     */
    SearchHints?: Array<SearchHint> | null;
    /**
     * Gets or sets the total record count.
     * @type {number}
     * @memberof SearchHintResult
     */
    TotalRecordCount?: number;
}
/**
 * 
 * @export
 * @interface SeriesInfo
 */
export interface SeriesInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof SeriesInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof SeriesInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof SeriesInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof SeriesInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof SeriesInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof SeriesInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SeriesInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SeriesInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface SeriesInfoRemoteSearchQuery
 */
export interface SeriesInfoRemoteSearchQuery {
    /**
     * 
     * @type {SeriesInfo}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    SearchInfo?: SeriesInfo;
    /**
     * 
     * @type {string}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * Class SeriesTimerInfoDto.
 * @export
 * @interface SeriesTimerInfoDto
 */
export interface SeriesTimerInfoDto {
    /**
     * Gets or sets a value indicating whether [record any time].
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    RecordAnyTime?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    SkipEpisodesInLibrary?: boolean;
    /**
     * Gets or sets a value indicating whether [record any channel].
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    RecordAnyChannel?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    KeepUpTo?: number;
    /**
     * Gets or sets a value indicating whether [record new only].
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    RecordNewOnly?: boolean;
    /**
     * Gets or sets the days.
     * @type {Array<DayOfWeek>}
     * @memberof SeriesTimerInfoDto
     */
    Days?: Array<DayOfWeek> | null;
    /**
     * 
     * @type {DayPattern}
     * @memberof SeriesTimerInfoDto
     */
    DayPattern?: DayPattern;
    /**
     * 
     * @type {BaseItemDtoImageTags}
     * @memberof SeriesTimerInfoDto
     */
    ImageTags?: BaseItemDtoImageTags | null;
    /**
     * Gets or sets the parent thumb item id.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentThumbItemId?: string | null;
    /**
     * Gets or sets the parent thumb image tag.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentThumbImageTag?: string | null;
    /**
     * Gets or sets the parent primary image item identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentPrimaryImageItemId?: string | null;
    /**
     * Gets or sets the parent primary image tag.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentPrimaryImageTag?: string | null;
    /**
     * Id of the recording.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Type?: string | null;
    /**
     * Gets or sets the server identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ServerId?: string | null;
    /**
     * Gets or sets the external identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ExternalId?: string | null;
    /**
     * ChannelId of the recording.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ChannelId?: string;
    /**
     * Gets or sets the external channel identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ExternalChannelId?: string | null;
    /**
     * ChannelName of the recording.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ChannelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ChannelPrimaryImageTag?: string | null;
    /**
     * Gets or sets the program identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ProgramId?: string | null;
    /**
     * Gets or sets the external program identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ExternalProgramId?: string | null;
    /**
     * Name of the recording.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Name?: string | null;
    /**
     * Description of the recording.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Overview?: string | null;
    /**
     * The start date of the recording, in UTC.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    StartDate?: string;
    /**
     * The end date of the recording, in UTC.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    EndDate?: string;
    /**
     * Gets or sets the name of the service.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ServiceName?: string | null;
    /**
     * Gets or sets the priority.
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    Priority?: number;
    /**
     * Gets or sets the pre padding seconds.
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    PrePaddingSeconds?: number;
    /**
     * Gets or sets the post padding seconds.
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    PostPaddingSeconds?: number;
    /**
     * Gets or sets a value indicating whether this instance is pre padding required.
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    IsPrePaddingRequired?: boolean;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentBackdropItemId?: string | null;
    /**
     * Gets or sets the parent backdrop image tags.
     * @type {Array<string>}
     * @memberof SeriesTimerInfoDto
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets a value indicating whether this instance is post padding required.
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    IsPostPaddingRequired?: boolean;
    /**
     * 
     * @type {KeepUntil}
     * @memberof SeriesTimerInfoDto
     */
    KeepUntil?: KeepUntil;
}
/**
 * 
 * @export
 * @interface SeriesTimerInfoDtoQueryResult
 */
export interface SeriesTimerInfoDtoQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<SeriesTimerInfoDto>}
     * @memberof SeriesTimerInfoDtoQueryResult
     */
    Items?: Array<SeriesTimerInfoDto> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof SeriesTimerInfoDtoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof SeriesTimerInfoDtoQueryResult
     */
    StartIndex?: number;
}
/**
 * Represents the server configuration.
 * @export
 * @interface ServerConfiguration
 */
export interface ServerConfiguration {
    /**
     * Gets or sets a value indicating whether to enable automatic port forwarding.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableUPnP?: boolean;
    /**
     * Gets or sets a value indicating whether to enable prometheus metrics exporting.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableMetrics?: boolean;
    /**
     * Gets or sets the public mapped port.
     * @type {number}
     * @memberof ServerConfiguration
     */
    PublicPort?: number;
    /**
     * Gets or sets the public HTTPS port.
     * @type {number}
     * @memberof ServerConfiguration
     */
    PublicHttpsPort?: number;
    /**
     * Gets or sets the HTTP server port number.
     * @type {number}
     * @memberof ServerConfiguration
     */
    HttpServerPortNumber?: number;
    /**
     * Gets or sets the HTTPS server port number.
     * @type {number}
     * @memberof ServerConfiguration
     */
    HttpsPortNumber?: number;
    /**
     * Gets or sets a value indicating whether to use HTTPS.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableHttps?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableNormalizedItemByNameIds?: boolean;
    /**
     * Gets or sets the filesystem path of an X.509 certificate to use for SSL.
     * @type {string}
     * @memberof ServerConfiguration
     */
    CertificatePath?: string | null;
    /**
     * Gets or sets the password required to access the X.509 certificate data in the file specified by MediaBrowser.Model.Configuration.ServerConfiguration.CertificatePath.
     * @type {string}
     * @memberof ServerConfiguration
     */
    CertificatePassword?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is port authorized.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IsPortAuthorized?: boolean;
    /**
     * Gets or sets if quick connect is available for use on this server.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    QuickConnectAvailable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    AutoRunWebApp?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableRemoteAccess?: boolean;
    /**
     * Gets or sets a value indicating whether [enable case sensitive item ids].
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableCaseSensitiveItemIds?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    DisableLiveTvChannelUserDataName?: boolean;
    /**
     * Gets or sets the metadata path.
     * @type {string}
     * @memberof ServerConfiguration
     */
    MetadataPath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    MetadataNetworkPath?: string | null;
    /**
     * Gets or sets the preferred metadata language.
     * @type {string}
     * @memberof ServerConfiguration
     */
    PreferredMetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof ServerConfiguration
     */
    MetadataCountryCode?: string | null;
    /**
     * Characters to be replaced with a \' \' in strings to create a sort name.
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    SortReplaceCharacters?: Array<string> | null;
    /**
     * Characters to be removed from strings to create a sort name.
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    SortRemoveCharacters?: Array<string> | null;
    /**
     * Words to be removed from strings to create a sort name.
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    SortRemoveWords?: Array<string> | null;
    /**
     * Gets or sets the minimum percentage of an item that must be played in order for playstate to be updated.
     * @type {number}
     * @memberof ServerConfiguration
     */
    MinResumePct?: number;
    /**
     * Gets or sets the maximum percentage of an item that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
     * @type {number}
     * @memberof ServerConfiguration
     */
    MaxResumePct?: number;
    /**
     * Gets or sets the minimum duration that an item must have in order to be eligible for playstate updates..
     * @type {number}
     * @memberof ServerConfiguration
     */
    MinResumeDurationSeconds?: number;
    /**
     * The delay in seconds that we will wait after a file system change to try and discover what has been added/removed  Some delay is necessary with some items because their creation is not atomic.  It involves the creation of several  different directories and files.
     * @type {number}
     * @memberof ServerConfiguration
     */
    LibraryMonitorDelay?: number;
    /**
     * Gets or sets a value indicating whether [enable dashboard response caching].  Allows potential contributors without visual studio to modify production dashboard code and test changes.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableDashboardResponseCaching?: boolean;
    /**
     * 
     * @type {ImageSavingConvention}
     * @memberof ServerConfiguration
     */
    ImageSavingConvention?: ImageSavingConvention;
    /**
     * 
     * @type {Array<MetadataOptions>}
     * @memberof ServerConfiguration
     */
    MetadataOptions?: Array<MetadataOptions> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    SkipDeserializationForBasicTypes?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    ServerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    BaseUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    UICulture?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    SaveMetadataHidden?: boolean;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof ServerConfiguration
     */
    ContentTypes?: Array<NameValuePair> | null;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    RemoteClientBitrateLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableFolderView?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableGroupingIntoCollections?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    DisplaySpecialsWithinSeasons?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    LocalNetworkSubnets?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    LocalNetworkAddresses?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    CodecsUsed?: Array<string> | null;
    /**
     * 
     * @type {Array<RepositoryInfo>}
     * @memberof ServerConfiguration
     */
    PluginRepositories?: Array<RepositoryInfo> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IgnoreVirtualInterfaces?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableExternalContentInSuggestions?: boolean;
    /**
     * Gets or sets a value indicating whether the server should force connections over HTTPS.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    RequireHttps?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableNewOmdbSupport?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    RemoteIPFilter?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IsRemoteIPFilterBlacklist?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    ImageExtractionTimeoutMs?: number;
    /**
     * 
     * @type {Array<PathSubstitution>}
     * @memberof ServerConfiguration
     */
    PathSubstitutions?: Array<PathSubstitution> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableSimpleArtistDetection?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    UninstalledPlugins?: Array<string> | null;
    /**
     * Gets or sets a value indicating whether slow server responses should be logged as a warning.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableSlowResponseWarning?: boolean;
    /**
     * Gets or sets the threshold for the slow response time warning in ms.
     * @type {number}
     * @memberof ServerConfiguration
     */
    SlowResponseThresholdMs?: number;
    /**
     * Gets or sets the cors hosts.
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    CorsHosts?: Array<string> | null;
    /**
     * Gets or sets the known proxies.
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    KnownProxies?: Array<string> | null;
    /**
     * Gets or sets the number of days we should retain log files.
     * @type {number}
     * @memberof ServerConfiguration
     */
    LogFileRetentionDays?: number;
    /**
     * Gets or sets a value indicating whether this instance is first run.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IsStartupWizardCompleted?: boolean;
    /**
     * Gets or sets the cache path.
     * @type {string}
     * @memberof ServerConfiguration
     */
    CachePath?: string | null;
    /**
     * 
     * @type {Version}
     * @memberof ServerConfiguration
     */
    PreviousVersion?: Version;
    /**
     * Gets or sets the stringified PreviousVersion to be stored/loaded,  because System.Version itself isn\'t xml-serializable.
     * @type {string}
     * @memberof ServerConfiguration
     */
    PreviousVersionStr?: string | null;
}
/**
 * Class SessionInfo.
 * @export
 * @interface SessionInfo
 */
export interface SessionInfo {
    /**
     * 
     * @type {PlayerStateInfo}
     * @memberof SessionInfo
     */
    PlayState?: PlayerStateInfo;
    /**
     * 
     * @type {Array<SessionUserInfo>}
     * @memberof SessionInfo
     */
    AdditionalUsers?: Array<SessionUserInfo> | null;
    /**
     * 
     * @type {ClientCapabilities}
     * @memberof SessionInfo
     */
    Capabilities?: ClientCapabilities;
    /**
     * Gets or sets the remote end point.
     * @type {string}
     * @memberof SessionInfo
     */
    RemoteEndPoint?: string | null;
    /**
     * Gets or sets the playable media types.
     * @type {Array<string>}
     * @memberof SessionInfo
     */
    PlayableMediaTypes?: Array<string> | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof SessionInfo
     */
    Id?: string | null;
    /**
     * Gets or sets the user id.
     * @type {string}
     * @memberof SessionInfo
     */
    UserId?: string;
    /**
     * Gets or sets the username.
     * @type {string}
     * @memberof SessionInfo
     */
    UserName?: string | null;
    /**
     * Gets or sets the type of the client.
     * @type {string}
     * @memberof SessionInfo
     */
    Client?: string | null;
    /**
     * Gets or sets the last activity date.
     * @type {string}
     * @memberof SessionInfo
     */
    LastActivityDate?: string;
    /**
     * Gets or sets the last playback check in.
     * @type {string}
     * @memberof SessionInfo
     */
    LastPlaybackCheckIn?: string;
    /**
     * Gets or sets the name of the device.
     * @type {string}
     * @memberof SessionInfo
     */
    DeviceName?: string | null;
    /**
     * Gets or sets the type of the device.
     * @type {string}
     * @memberof SessionInfo
     */
    DeviceType?: string | null;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof SessionInfo
     */
    NowPlayingItem?: BaseItemDto;
    /**
     * 
     * @type {BaseItem}
     * @memberof SessionInfo
     */
    FullNowPlayingItem?: BaseItem;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof SessionInfo
     */
    NowViewingItem?: BaseItemDto;
    /**
     * Gets or sets the device id.
     * @type {string}
     * @memberof SessionInfo
     */
    DeviceId?: string | null;
    /**
     * Gets or sets the application version.
     * @type {string}
     * @memberof SessionInfo
     */
    ApplicationVersion?: string | null;
    /**
     * 
     * @type {TranscodingInfo}
     * @memberof SessionInfo
     */
    TranscodingInfo?: TranscodingInfo;
    /**
     * Gets a value indicating whether this instance is active.
     * @type {boolean}
     * @memberof SessionInfo
     */
    IsActive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionInfo
     */
    SupportsMediaControl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionInfo
     */
    SupportsRemoteControl?: boolean;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof SessionInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
    /**
     * 
     * @type {boolean}
     * @memberof SessionInfo
     */
    HasCustomDeviceName?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    PlaylistItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    ServerId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    UserPrimaryImageTag?: string | null;
    /**
     * Gets or sets the supported commands.
     * @type {Array<string>}
     * @memberof SessionInfo
     */
    SupportedCommands?: Array<string> | null;
}
/**
 * Class SessionUserInfo.
 * @export
 * @interface SessionUserInfo
 */
export interface SessionUserInfo {
    /**
     * Gets or sets the user identifier.
     * @type {string}
     * @memberof SessionUserInfo
     */
    UserId?: string;
    /**
     * Gets or sets the name of the user.
     * @type {string}
     * @memberof SessionUserInfo
     */
    UserName?: string | null;
}
/**
 * 
 * @export
 * @interface SongInfo
 */
export interface SongInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof SongInfo
     */
    AlbumArtists?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof SongInfo
     */
    Album?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongInfo
     */
    Artists?: Array<string> | null;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof SongInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof SongInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof SongInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof SongInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof SongInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof SongInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SongInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SongInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SongInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SongInfo
     */
    IsAutomated?: boolean;
}
/**
 * An enum representing the sorting order.
 * @export
 * @enum {string}
 */
export enum SortOrder {
    Ascending = 'Ascending',
    Descending = 'Descending'
}

/**
 * Special view option dto.
 * @export
 * @interface SpecialViewOptionDto
 */
export interface SpecialViewOptionDto {
    /**
     * Gets or sets view option name.
     * @type {string}
     * @memberof SpecialViewOptionDto
     */
    Name?: string | null;
    /**
     * Gets or sets view option id.
     * @type {string}
     * @memberof SpecialViewOptionDto
     */
    Id?: string | null;
}
/**
 * The startup configuration DTO.
 * @export
 * @interface StartupConfigurationDto
 */
export interface StartupConfigurationDto {
    /**
     * Gets or sets UI language culture.
     * @type {string}
     * @memberof StartupConfigurationDto
     */
    UICulture?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof StartupConfigurationDto
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the preferred language for the metadata.
     * @type {string}
     * @memberof StartupConfigurationDto
     */
    PreferredMetadataLanguage?: string | null;
}
/**
 * Startup remote access dto.
 * @export
 * @interface StartupRemoteAccessDto
 */
export interface StartupRemoteAccessDto {
    /**
     * Gets or sets a value indicating whether enable remote access.
     * @type {boolean}
     * @memberof StartupRemoteAccessDto
     */
    EnableRemoteAccess: boolean;
    /**
     * Gets or sets a value indicating whether enable automatic port mapping.
     * @type {boolean}
     * @memberof StartupRemoteAccessDto
     */
    EnableAutomaticPortMapping: boolean;
}
/**
 * The startup user DTO.
 * @export
 * @interface StartupUserDto
 */
export interface StartupUserDto {
    /**
     * Gets or sets the username.
     * @type {string}
     * @memberof StartupUserDto
     */
    Name?: string | null;
    /**
     * Gets or sets the user\'s password.
     * @type {string}
     * @memberof StartupUserDto
     */
    Password?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SubtitleDeliveryMethod {
    Encode = 'Encode',
    Embed = 'Embed',
    External = 'External',
    Hls = 'Hls'
}

/**
 * An enum representing a subtitle playback mode.
 * @export
 * @enum {string}
 */
export enum SubtitlePlaybackMode {
    Default = 'Default',
    Always = 'Always',
    OnlyForced = 'OnlyForced',
    None = 'None',
    Smart = 'Smart'
}

/**
 * 
 * @export
 * @interface SubtitleProfile
 */
export interface SubtitleProfile {
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    Format?: string | null;
    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof SubtitleProfile
     */
    Method?: SubtitleDeliveryMethod;
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    DidlMode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    Language?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    Container?: string | null;
}
/**
 * Enum SyncPlayAccess.
 * @export
 * @enum {string}
 */
export enum SyncPlayAccess {
    CreateAndJoinGroups = 'CreateAndJoinGroups',
    JoinGroups = 'JoinGroups',
    None = 'None'
}

/**
 * Class SystemInfo.
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * Gets or sets the display name of the operating system.
     * @type {string}
     * @memberof SystemInfo
     */
    OperatingSystemDisplayName?: string | null;
    /**
     * Get or sets the package name.
     * @type {string}
     * @memberof SystemInfo
     */
    PackageName?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has pending restart.
     * @type {boolean}
     * @memberof SystemInfo
     */
    HasPendingRestart?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemInfo
     */
    IsShuttingDown?: boolean;
    /**
     * Gets or sets a value indicating whether [supports library monitor].
     * @type {boolean}
     * @memberof SystemInfo
     */
    SupportsLibraryMonitor?: boolean;
    /**
     * Gets or sets the web socket port number.
     * @type {number}
     * @memberof SystemInfo
     */
    WebSocketPortNumber?: number;
    /**
     * Gets or sets the completed installations.
     * @type {Array<InstallationInfo>}
     * @memberof SystemInfo
     */
    CompletedInstallations?: Array<InstallationInfo> | null;
    /**
     * Gets or sets a value indicating whether this instance can self restart.
     * @type {boolean}
     * @memberof SystemInfo
     */
    CanSelfRestart?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemInfo
     */
    CanLaunchWebBrowser?: boolean;
    /**
     * Gets or sets the program data path.
     * @type {string}
     * @memberof SystemInfo
     */
    ProgramDataPath?: string | null;
    /**
     * Gets or sets the web UI resources path.
     * @type {string}
     * @memberof SystemInfo
     */
    WebPath?: string | null;
    /**
     * Gets or sets the items by name path.
     * @type {string}
     * @memberof SystemInfo
     */
    ItemsByNamePath?: string | null;
    /**
     * Gets or sets the cache path.
     * @type {string}
     * @memberof SystemInfo
     */
    CachePath?: string | null;
    /**
     * Gets or sets the log path.
     * @type {string}
     * @memberof SystemInfo
     */
    LogPath?: string | null;
    /**
     * Gets or sets the internal metadata path.
     * @type {string}
     * @memberof SystemInfo
     */
    InternalMetadataPath?: string | null;
    /**
     * Gets or sets the transcode path.
     * @type {string}
     * @memberof SystemInfo
     */
    TranscodingTempPath?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has update available.
     * @type {boolean}
     * @memberof SystemInfo
     */
    HasUpdateAvailable?: boolean;
    /**
     * 
     * @type {FFmpegLocation}
     * @memberof SystemInfo
     */
    EncoderLocation?: FFmpegLocation;
    /**
     * 
     * @type {Architecture}
     * @memberof SystemInfo
     */
    SystemArchitecture?: Architecture;
    /**
     * Gets or sets the local address.
     * @type {string}
     * @memberof SystemInfo
     */
    LocalAddress?: string | null;
    /**
     * Gets or sets the name of the server.
     * @type {string}
     * @memberof SystemInfo
     */
    ServerName?: string | null;
    /**
     * Gets or sets the server version.
     * @type {string}
     * @memberof SystemInfo
     */
    Version?: string | null;
    /**
     * Gets or sets the product name. This is the AssemblyProduct name.
     * @type {string}
     * @memberof SystemInfo
     */
    ProductName?: string | null;
    /**
     * Gets or sets the operating system.
     * @type {string}
     * @memberof SystemInfo
     */
    OperatingSystem?: string | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof SystemInfo
     */
    Id?: string | null;
    /**
     * Gets or sets a value indicating whether the startup wizard is completed.
     * @type {boolean}
     * @memberof SystemInfo
     */
    StartupWizardCompleted?: boolean;
}
/**
 * Enum TaskCompletionStatus.
 * @export
 * @enum {string}
 */
export enum TaskCompletionStatus {
    Completed = 'Completed',
    Failed = 'Failed',
    Cancelled = 'Cancelled',
    Aborted = 'Aborted'
}

/**
 * Class TaskInfo.
 * @export
 * @interface TaskInfo
 */
export interface TaskInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof TaskInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {TaskState}
     * @memberof TaskInfo
     */
    State?: TaskState;
    /**
     * Gets or sets the progress.
     * @type {number}
     * @memberof TaskInfo
     */
    CurrentProgressPercentage?: number | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof TaskInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {TaskResult}
     * @memberof TaskInfo
     */
    LastExecutionResult?: TaskResult;
    /**
     * Gets or sets the triggers.
     * @type {Array<TaskTriggerInfo>}
     * @memberof TaskInfo
     */
    Triggers?: Array<TaskTriggerInfo> | null;
    /**
     * Gets or sets the description.
     * @type {string}
     * @memberof TaskInfo
     */
    Description?: string | null;
    /**
     * Gets or sets the category.
     * @type {string}
     * @memberof TaskInfo
     */
    Category?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is hidden.
     * @type {boolean}
     * @memberof TaskInfo
     */
    IsHidden?: boolean;
    /**
     * Gets or sets the key.
     * @type {string}
     * @memberof TaskInfo
     */
    Key?: string | null;
}
/**
 * Class TaskExecutionInfo.
 * @export
 * @interface TaskResult
 */
export interface TaskResult {
    /**
     * Gets or sets the start time UTC.
     * @type {string}
     * @memberof TaskResult
     */
    StartTimeUtc?: string;
    /**
     * Gets or sets the end time UTC.
     * @type {string}
     * @memberof TaskResult
     */
    EndTimeUtc?: string;
    /**
     * 
     * @type {TaskCompletionStatus}
     * @memberof TaskResult
     */
    Status?: TaskCompletionStatus;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof TaskResult
     */
    Name?: string | null;
    /**
     * Gets or sets the key.
     * @type {string}
     * @memberof TaskResult
     */
    Key?: string | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof TaskResult
     */
    Id?: string | null;
    /**
     * Gets or sets the error message.
     * @type {string}
     * @memberof TaskResult
     */
    ErrorMessage?: string | null;
    /**
     * Gets or sets the long error message.
     * @type {string}
     * @memberof TaskResult
     */
    LongErrorMessage?: string | null;
}
/**
 * Enum TaskState.
 * @export
 * @enum {string}
 */
export enum TaskState {
    Idle = 'Idle',
    Cancelling = 'Cancelling',
    Running = 'Running'
}

/**
 * Class TaskTriggerInfo.
 * @export
 * @interface TaskTriggerInfo
 */
export interface TaskTriggerInfo {
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof TaskTriggerInfo
     */
    Type?: string | null;
    /**
     * Gets or sets the time of day.
     * @type {number}
     * @memberof TaskTriggerInfo
     */
    TimeOfDayTicks?: number | null;
    /**
     * Gets or sets the interval.
     * @type {number}
     * @memberof TaskTriggerInfo
     */
    IntervalTicks?: number | null;
    /**
     * 
     * @type {DayOfWeek}
     * @memberof TaskTriggerInfo
     */
    DayOfWeek?: DayOfWeek;
    /**
     * Gets or sets the maximum runtime ticks.
     * @type {number}
     * @memberof TaskTriggerInfo
     */
    MaxRuntimeTicks?: number | null;
}
/**
 * Class ThemeMediaResult.
 * @export
 * @interface ThemeMediaResult
 */
export interface ThemeMediaResult {
    /**
     * Gets or sets the owner id.
     * @type {string}
     * @memberof ThemeMediaResult
     */
    OwnerId?: string;
    /**
     * Gets or sets the items.
     * @type {Array<BaseItemDto>}
     * @memberof ThemeMediaResult
     */
    Items?: Array<BaseItemDto> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof ThemeMediaResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof ThemeMediaResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface TimerInfoDto
 */
export interface TimerInfoDto {
    /**
     * 
     * @type {RecordingStatus}
     * @memberof TimerInfoDto
     */
    Status?: RecordingStatus;
    /**
     * Gets or sets the series timer identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    SeriesTimerId?: string | null;
    /**
     * Gets or sets the external series timer identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalSeriesTimerId?: string | null;
    /**
     * Gets or sets the run time ticks.
     * @type {number}
     * @memberof TimerInfoDto
     */
    RunTimeTicks?: number | null;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof TimerInfoDto
     */
    ProgramInfo?: BaseItemDto;
    /**
     * Id of the recording.
     * @type {string}
     * @memberof TimerInfoDto
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    Type?: string | null;
    /**
     * Gets or sets the server identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ServerId?: string | null;
    /**
     * Gets or sets the external identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalId?: string | null;
    /**
     * ChannelId of the recording.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ChannelId?: string;
    /**
     * Gets or sets the external channel identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalChannelId?: string | null;
    /**
     * ChannelName of the recording.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ChannelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ChannelPrimaryImageTag?: string | null;
    /**
     * Gets or sets the program identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ProgramId?: string | null;
    /**
     * Gets or sets the external program identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalProgramId?: string | null;
    /**
     * Name of the recording.
     * @type {string}
     * @memberof TimerInfoDto
     */
    Name?: string | null;
    /**
     * Description of the recording.
     * @type {string}
     * @memberof TimerInfoDto
     */
    Overview?: string | null;
    /**
     * The start date of the recording, in UTC.
     * @type {string}
     * @memberof TimerInfoDto
     */
    StartDate?: string;
    /**
     * The end date of the recording, in UTC.
     * @type {string}
     * @memberof TimerInfoDto
     */
    EndDate?: string;
    /**
     * Gets or sets the name of the service.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ServiceName?: string | null;
    /**
     * Gets or sets the priority.
     * @type {number}
     * @memberof TimerInfoDto
     */
    Priority?: number;
    /**
     * Gets or sets the pre padding seconds.
     * @type {number}
     * @memberof TimerInfoDto
     */
    PrePaddingSeconds?: number;
    /**
     * Gets or sets the post padding seconds.
     * @type {number}
     * @memberof TimerInfoDto
     */
    PostPaddingSeconds?: number;
    /**
     * Gets or sets a value indicating whether this instance is pre padding required.
     * @type {boolean}
     * @memberof TimerInfoDto
     */
    IsPrePaddingRequired?: boolean;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ParentBackdropItemId?: string | null;
    /**
     * Gets or sets the parent backdrop image tags.
     * @type {Array<string>}
     * @memberof TimerInfoDto
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets a value indicating whether this instance is post padding required.
     * @type {boolean}
     * @memberof TimerInfoDto
     */
    IsPostPaddingRequired?: boolean;
    /**
     * 
     * @type {KeepUntil}
     * @memberof TimerInfoDto
     */
    KeepUntil?: KeepUntil;
}
/**
 * 
 * @export
 * @interface TimerInfoDtoQueryResult
 */
export interface TimerInfoDtoQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<TimerInfoDto>}
     * @memberof TimerInfoDtoQueryResult
     */
    Items?: Array<TimerInfoDto> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof TimerInfoDtoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof TimerInfoDtoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface TrailerInfo
 */
export interface TrailerInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof TrailerInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof TrailerInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof TrailerInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof TrailerInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof TrailerInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof TrailerInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrailerInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrailerInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TrailerInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrailerInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface TrailerInfoRemoteSearchQuery
 */
export interface TrailerInfoRemoteSearchQuery {
    /**
     * 
     * @type {TrailerInfo}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    SearchInfo?: TrailerInfo;
    /**
     * 
     * @type {string}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TranscodeReason {
    ContainerNotSupported = 'ContainerNotSupported',
    VideoCodecNotSupported = 'VideoCodecNotSupported',
    AudioCodecNotSupported = 'AudioCodecNotSupported',
    ContainerBitrateExceedsLimit = 'ContainerBitrateExceedsLimit',
    AudioBitrateNotSupported = 'AudioBitrateNotSupported',
    AudioChannelsNotSupported = 'AudioChannelsNotSupported',
    VideoResolutionNotSupported = 'VideoResolutionNotSupported',
    UnknownVideoStreamInfo = 'UnknownVideoStreamInfo',
    UnknownAudioStreamInfo = 'UnknownAudioStreamInfo',
    AudioProfileNotSupported = 'AudioProfileNotSupported',
    AudioSampleRateNotSupported = 'AudioSampleRateNotSupported',
    AnamorphicVideoNotSupported = 'AnamorphicVideoNotSupported',
    InterlacedVideoNotSupported = 'InterlacedVideoNotSupported',
    SecondaryAudioNotSupported = 'SecondaryAudioNotSupported',
    RefFramesNotSupported = 'RefFramesNotSupported',
    VideoBitDepthNotSupported = 'VideoBitDepthNotSupported',
    VideoBitrateNotSupported = 'VideoBitrateNotSupported',
    VideoFramerateNotSupported = 'VideoFramerateNotSupported',
    VideoLevelNotSupported = 'VideoLevelNotSupported',
    VideoProfileNotSupported = 'VideoProfileNotSupported',
    AudioBitDepthNotSupported = 'AudioBitDepthNotSupported',
    SubtitleCodecNotSupported = 'SubtitleCodecNotSupported',
    DirectPlayError = 'DirectPlayError'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TranscodeSeekInfo {
    Auto = 'Auto',
    Bytes = 'Bytes'
}

/**
 * 
 * @export
 * @interface TranscodingInfo
 */
export interface TranscodingInfo {
    /**
     * 
     * @type {string}
     * @memberof TranscodingInfo
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingInfo
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingInfo
     */
    Container?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingInfo
     */
    IsVideoDirect?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingInfo
     */
    IsAudioDirect?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Bitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Framerate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    CompletionPercentage?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Width?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Height?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    AudioChannels?: number | null;
    /**
     * 
     * @type {Array<TranscodeReason>}
     * @memberof TranscodingInfo
     */
    TranscodeReasons?: Array<TranscodeReason> | null;
}
/**
 * 
 * @export
 * @interface TranscodingProfile
 */
export interface TranscodingProfile {
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    Container?: string | null;
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof TranscodingProfile
     */
    Type?: DlnaProfileType;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    Protocol?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    EstimateContentLength?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    EnableMpegtsM2TsMode?: boolean;
    /**
     * 
     * @type {TranscodeSeekInfo}
     * @memberof TranscodingProfile
     */
    TranscodeSeekInfo?: TranscodeSeekInfo;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    CopyTimestamps?: boolean;
    /**
     * 
     * @type {EncodingContext}
     * @memberof TranscodingProfile
     */
    Context?: EncodingContext;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    EnableSubtitlesInManifest?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    MaxAudioChannels?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingProfile
     */
    MinSegments?: number;
    /**
     * 
     * @type {number}
     * @memberof TranscodingProfile
     */
    SegmentLength?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    BreakOnNonKeyFrames?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransportStreamTimestamp {
    None = 'None',
    Zero = 'Zero',
    Valid = 'Valid'
}

/**
 * 
 * @export
 * @interface TunerChannelMapping
 */
export interface TunerChannelMapping {
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    ProviderChannelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    ProviderChannelId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @interface TunerHostInfo
 */
export interface TunerHostInfo {
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    DeviceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    FriendlyName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TunerHostInfo
     */
    ImportFavoritesOnly?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TunerHostInfo
     */
    AllowHWTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TunerHostInfo
     */
    EnableStreamLooping?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Source?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TunerHostInfo
     */
    TunerCount?: number;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    UserAgent?: string | null;
}
/**
 * 
 * @export
 * @interface TypeOptions
 */
export interface TypeOptions {
    /**
     * 
     * @type {string}
     * @memberof TypeOptions
     */
    Type?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    MetadataFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    MetadataFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    ImageFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    ImageFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<ImageOption>}
     * @memberof TypeOptions
     */
    ImageOptions?: Array<ImageOption> | null;
}
/**
 * An enum representing an unrated item.
 * @export
 * @enum {string}
 */
export enum UnratedItem {
    Movie = 'Movie',
    Trailer = 'Trailer',
    Series = 'Series',
    Music = 'Music',
    Book = 'Book',
    LiveTvChannel = 'LiveTvChannel',
    LiveTvProgram = 'LiveTvProgram',
    ChannelContent = 'ChannelContent',
    Other = 'Other'
}

/**
 * Update library options dto.
 * @export
 * @interface UpdateLibraryOptionsDto
 */
export interface UpdateLibraryOptionsDto {
    /**
     * Gets or sets the library item id.
     * @type {string}
     * @memberof UpdateLibraryOptionsDto
     */
    Id?: string;
    /**
     * 
     * @type {LibraryOptions}
     * @memberof UpdateLibraryOptionsDto
     */
    LibraryOptions?: LibraryOptions;
}
/**
 * The update user easy password request body.
 * @export
 * @interface UpdateUserEasyPassword
 */
export interface UpdateUserEasyPassword {
    /**
     * Gets or sets the new sha1-hashed password.
     * @type {string}
     * @memberof UpdateUserEasyPassword
     */
    NewPassword?: string | null;
    /**
     * Gets or sets the new password.
     * @type {string}
     * @memberof UpdateUserEasyPassword
     */
    NewPw?: string | null;
    /**
     * Gets or sets a value indicating whether to reset the password.
     * @type {boolean}
     * @memberof UpdateUserEasyPassword
     */
    ResetPassword?: boolean;
}
/**
 * The update user password request body.
 * @export
 * @interface UpdateUserPassword
 */
export interface UpdateUserPassword {
    /**
     * Gets or sets the current sha1-hashed password.
     * @type {string}
     * @memberof UpdateUserPassword
     */
    CurrentPassword?: string | null;
    /**
     * Gets or sets the current plain text password.
     * @type {string}
     * @memberof UpdateUserPassword
     */
    CurrentPw?: string | null;
    /**
     * Gets or sets the new plain text password.
     * @type {string}
     * @memberof UpdateUserPassword
     */
    NewPw?: string | null;
    /**
     * Gets or sets a value indicating whether to reset the password.
     * @type {boolean}
     * @memberof UpdateUserPassword
     */
    ResetPassword?: boolean;
}
/**
 * Class UserConfiguration.
 * @export
 * @interface UserConfiguration
 */
export interface UserConfiguration {
    /**
     * Gets or sets the audio language preference.
     * @type {string}
     * @memberof UserConfiguration
     */
    AudioLanguagePreference?: string | null;
    /**
     * Gets or sets a value indicating whether [play default audio track].
     * @type {boolean}
     * @memberof UserConfiguration
     */
    PlayDefaultAudioTrack?: boolean;
    /**
     * Gets or sets the subtitle language preference.
     * @type {string}
     * @memberof UserConfiguration
     */
    SubtitleLanguagePreference?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    DisplayMissingEpisodes?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    GroupedFolders?: Array<string> | null;
    /**
     * 
     * @type {SubtitlePlaybackMode}
     * @memberof UserConfiguration
     */
    SubtitleMode?: SubtitlePlaybackMode;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    DisplayCollectionsView?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    EnableLocalPassword?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    OrderedViews?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    LatestItemsExcludes?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    MyMediaExcludes?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    HidePlayedInLatest?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    RememberAudioSelections?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    RememberSubtitleSelections?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    EnableNextEpisodeAutoPlay?: boolean;
}
/**
 * Class UserDto.
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof UserDto
     */
    Name?: string | null;
    /**
     * Gets or sets the server identifier.
     * @type {string}
     * @memberof UserDto
     */
    ServerId?: string | null;
    /**
     * Gets or sets the name of the server.  This is not used by the server and is for client-side usage only.
     * @type {string}
     * @memberof UserDto
     */
    ServerName?: string | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof UserDto
     */
    Id?: string;
    /**
     * Gets or sets the primary image tag.
     * @type {string}
     * @memberof UserDto
     */
    PrimaryImageTag?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has password.
     * @type {boolean}
     * @memberof UserDto
     */
    HasPassword?: boolean;
    /**
     * Gets or sets a value indicating whether this instance has configured password.
     * @type {boolean}
     * @memberof UserDto
     */
    HasConfiguredPassword?: boolean;
    /**
     * Gets or sets a value indicating whether this instance has configured easy password.
     * @type {boolean}
     * @memberof UserDto
     */
    HasConfiguredEasyPassword?: boolean;
    /**
     * Gets or sets whether async login is enabled or not.
     * @type {boolean}
     * @memberof UserDto
     */
    EnableAutoLogin?: boolean | null;
    /**
     * Gets or sets the last login date.
     * @type {string}
     * @memberof UserDto
     */
    LastLoginDate?: string | null;
    /**
     * Gets or sets the last activity date.
     * @type {string}
     * @memberof UserDto
     */
    LastActivityDate?: string | null;
    /**
     * 
     * @type {UserConfiguration}
     * @memberof UserDto
     */
    Configuration?: UserConfiguration;
    /**
     * 
     * @type {UserPolicy}
     * @memberof UserDto
     */
    Policy?: UserPolicy;
    /**
     * Gets or sets the primary image aspect ratio.
     * @type {number}
     * @memberof UserDto
     */
    PrimaryImageAspectRatio?: number | null;
}
/**
 * Class UserItemDataDto.
 * @export
 * @interface UserItemDataDto
 */
export interface UserItemDataDto {
    /**
     * Gets or sets the rating.
     * @type {number}
     * @memberof UserItemDataDto
     */
    Rating?: number | null;
    /**
     * Gets or sets the played percentage.
     * @type {number}
     * @memberof UserItemDataDto
     */
    PlayedPercentage?: number | null;
    /**
     * Gets or sets the unplayed item count.
     * @type {number}
     * @memberof UserItemDataDto
     */
    UnplayedItemCount?: number | null;
    /**
     * Gets or sets the playback position ticks.
     * @type {number}
     * @memberof UserItemDataDto
     */
    PlaybackPositionTicks?: number;
    /**
     * Gets or sets the play count.
     * @type {number}
     * @memberof UserItemDataDto
     */
    PlayCount?: number;
    /**
     * Gets or sets a value indicating whether this instance is favorite.
     * @type {boolean}
     * @memberof UserItemDataDto
     */
    IsFavorite?: boolean;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is likes.
     * @type {boolean}
     * @memberof UserItemDataDto
     */
    Likes?: boolean | null;
    /**
     * Gets or sets the last played date.
     * @type {string}
     * @memberof UserItemDataDto
     */
    LastPlayedDate?: string | null;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played.
     * @type {boolean}
     * @memberof UserItemDataDto
     */
    Played?: boolean;
    /**
     * Gets or sets the key.
     * @type {string}
     * @memberof UserItemDataDto
     */
    Key?: string | null;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof UserItemDataDto
     */
    ItemId?: string | null;
}
/**
 * 
 * @export
 * @interface UserPolicy
 */
export interface UserPolicy {
    /**
     * Gets or sets a value indicating whether this instance is administrator.
     * @type {boolean}
     * @memberof UserPolicy
     */
    IsAdministrator?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is hidden.
     * @type {boolean}
     * @memberof UserPolicy
     */
    IsHidden?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is disabled.
     * @type {boolean}
     * @memberof UserPolicy
     */
    IsDisabled?: boolean;
    /**
     * Gets or sets the max parental rating.
     * @type {number}
     * @memberof UserPolicy
     */
    MaxParentalRating?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    BlockedTags?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableUserPreferenceAccess?: boolean;
    /**
     * 
     * @type {Array<AccessSchedule>}
     * @memberof UserPolicy
     */
    AccessSchedules?: Array<AccessSchedule> | null;
    /**
     * 
     * @type {Array<UnratedItem>}
     * @memberof UserPolicy
     */
    BlockUnratedItems?: Array<UnratedItem> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableRemoteControlOfOtherUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableSharedDeviceControl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableRemoteAccess?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableLiveTvManagement?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableLiveTvAccess?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableMediaPlayback?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAudioPlaybackTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableVideoPlaybackTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnablePlaybackRemuxing?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    ForceRemoteSourceTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableContentDeletion?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnableContentDeletionFromFolders?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableContentDownloading?: boolean;
    /**
     * Gets or sets a value indicating whether [enable synchronize].
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableSyncTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableMediaConversion?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnabledDevices?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAllDevices?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnabledChannels?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAllChannels?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnabledFolders?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAllFolders?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    InvalidLoginAttemptCount?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    LoginAttemptsBeforeLockout?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnablePublicSharing?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    BlockedMediaFolders?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    BlockedChannels?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    RemoteClientBitrateLimit?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPolicy
     */
    AuthenticationProviderId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPolicy
     */
    PasswordResetProviderId?: string | null;
    /**
     * 
     * @type {SyncPlayAccess}
     * @memberof UserPolicy
     */
    SyncPlayAccess?: SyncPlayAccess;
}
/**
 * Class UtcTimeResponse.
 * @export
 * @interface UtcTimeResponse
 */
export interface UtcTimeResponse {
    /**
     * Gets or sets the UTC time when request has been received.
     * @type {string}
     * @memberof UtcTimeResponse
     */
    RequestReceptionTime?: string | null;
    /**
     * Gets or sets the UTC time when response has been sent.
     * @type {string}
     * @memberof UtcTimeResponse
     */
    ResponseTransmissionTime?: string | null;
}
/**
 * Validate path object.
 * @export
 * @interface ValidatePathDto
 */
export interface ValidatePathDto {
    /**
     * Gets or sets a value indicating whether validate if path is writable.
     * @type {boolean}
     * @memberof ValidatePathDto
     */
    ValidateWritable?: boolean;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof ValidatePathDto
     */
    Path?: string | null;
    /**
     * Gets or sets is path file.
     * @type {boolean}
     * @memberof ValidatePathDto
     */
    IsFile?: boolean | null;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Major?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Minor?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Build?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Revision?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    MajorRevision?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    MinorRevision?: number;
}
/**
 * Class PackageVersionInfo.
 * @export
 * @interface VersionInfo
 */
export interface VersionInfo {
    /**
     * Gets or sets the version.
     * @type {string}
     * @memberof VersionInfo
     */
    version?: string | null;
    /**
     * Gets or sets the changelog for this version.
     * @type {string}
     * @memberof VersionInfo
     */
    changelog?: string | null;
    /**
     * Gets or sets the ABI that this version was built against.
     * @type {string}
     * @memberof VersionInfo
     */
    targetAbi?: string | null;
    /**
     * Gets or sets the source URL.
     * @type {string}
     * @memberof VersionInfo
     */
    sourceUrl?: string | null;
    /**
     * Gets or sets a checksum for the binary.
     * @type {string}
     * @memberof VersionInfo
     */
    checksum?: string | null;
    /**
     * Gets or sets a timestamp of when the binary was built.
     * @type {string}
     * @memberof VersionInfo
     */
    timestamp?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Video3DFormat {
    HalfSideBySide = 'HalfSideBySide',
    FullSideBySide = 'FullSideBySide',
    FullTopAndBottom = 'FullTopAndBottom',
    HalfTopAndBottom = 'HalfTopAndBottom',
    MVC = 'MVC'
}

/**
 * Enum VideoType.
 * @export
 * @enum {string}
 */
export enum VideoType {
    VideoFile = 'VideoFile',
    Iso = 'Iso',
    Dvd = 'Dvd',
    BluRay = 'BluRay'
}

/**
 * Used to hold information about a user\'s list of configured virtual folders.
 * @export
 * @interface VirtualFolderInfo
 */
export interface VirtualFolderInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the locations.
     * @type {Array<string>}
     * @memberof VirtualFolderInfo
     */
    Locations?: Array<string> | null;
    /**
     * Gets or sets the type of the collection.
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    CollectionType?: string | null;
    /**
     * 
     * @type {LibraryOptions}
     * @memberof VirtualFolderInfo
     */
    LibraryOptions?: LibraryOptions;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    ItemId?: string | null;
    /**
     * Gets or sets the primary image item identifier.
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    PrimaryImageItemId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof VirtualFolderInfo
     */
    RefreshProgress?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    RefreshStatus?: string | null;
}
/**
 * Provides the MAC address and port for wake-on-LAN functionality.
 * @export
 * @interface WakeOnLanInfo
 */
export interface WakeOnLanInfo {
    /**
     * Gets the MAC address of the device.
     * @type {string}
     * @memberof WakeOnLanInfo
     */
    MacAddress?: string | null;
    /**
     * Gets or sets the wake-on-LAN port.
     * @type {number}
     * @memberof WakeOnLanInfo
     */
    Port?: number;
}
/**
 * 
 * @export
 * @interface XmlAttribute
 */
export interface XmlAttribute {
    /**
     * 
     * @type {string}
     * @memberof XmlAttribute
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof XmlAttribute
     */
    Value?: string | null;
}

/**
 * ActivityLogApi - axios parameter creator
 * @export
 */
export const ActivityLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets activity log entries.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [minDate] Optional. The minimum date. Format &#x3D; ISO.
         * @param {boolean} [hasUserId] Optional. Filter log entries if it has user id, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogEntries: async (startIndex?: number, limit?: number, minDate?: string, hasUserId?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/ActivityLog/Entries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minDate !== undefined) {
                localVarQueryParameter['minDate'] = (minDate as any instanceof Date) ?
                    (minDate as any).toISOString() :
                    minDate;
            }

            if (hasUserId !== undefined) {
                localVarQueryParameter['hasUserId'] = hasUserId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityLogApi - functional programming interface
 * @export
 */
export const ActivityLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets activity log entries.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [minDate] Optional. The minimum date. Format &#x3D; ISO.
         * @param {boolean} [hasUserId] Optional. Filter log entries if it has user id, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogEntries(startIndex?: number, limit?: number, minDate?: string, hasUserId?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityLogEntryQueryResult>> {
            const localVarAxiosArgs = await ActivityLogApiAxiosParamCreator(configuration).getLogEntries(startIndex, limit, minDate, hasUserId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActivityLogApi - factory interface
 * @export
 */
export const ActivityLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets activity log entries.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [minDate] Optional. The minimum date. Format &#x3D; ISO.
         * @param {boolean} [hasUserId] Optional. Filter log entries if it has user id, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogEntries(startIndex?: number, limit?: number, minDate?: string, hasUserId?: boolean, options?: any): AxiosPromise<ActivityLogEntryQueryResult> {
            return ActivityLogApiFp(configuration).getLogEntries(startIndex, limit, minDate, hasUserId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityLogApi - object-oriented interface
 * @export
 * @class ActivityLogApi
 * @extends {BaseAPI}
 */
export class ActivityLogApi extends BaseAPI {
    /**
     * 
     * @summary Gets activity log entries.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [minDate] Optional. The minimum date. Format &#x3D; ISO.
     * @param {boolean} [hasUserId] Optional. Filter log entries if it has user id, or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogApi
     */
    public getLogEntries(startIndex?: number, limit?: number, minDate?: string, hasUserId?: boolean, options?: any) {
        return ActivityLogApiFp(this.configuration).getLogEntries(startIndex, limit, minDate, hasUserId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlbumsApi - axios parameter creator
 * @export
 */
export const AlbumsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Finds albums similar to a given album.
         * @param {string} albumId The album id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [excludeArtistIds] Optional. Ids of artists to exclude.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarAlbums: async (albumId: string, userId?: string, excludeArtistIds?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            if (albumId === null || albumId === undefined) {
                throw new RequiredError('albumId','Required parameter albumId was null or undefined when calling getSimilarAlbums.');
            }
            const localVarPath = `/Albums/{albumId}/Similar`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds artists similar to a given artist.
         * @param {string} artistId The artist id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [excludeArtistIds] Optional. Ids of artists to exclude.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarArtists: async (artistId: string, userId?: string, excludeArtistIds?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artistId' is not null or undefined
            if (artistId === null || artistId === undefined) {
                throw new RequiredError('artistId','Required parameter artistId was null or undefined when calling getSimilarArtists.');
            }
            const localVarPath = `/Artists/{artistId}/Similar`
                .replace(`{${"artistId"}}`, encodeURIComponent(String(artistId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlbumsApi - functional programming interface
 * @export
 */
export const AlbumsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Finds albums similar to a given album.
         * @param {string} albumId The album id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [excludeArtistIds] Optional. Ids of artists to exclude.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarAlbums(albumId: string, userId?: string, excludeArtistIds?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).getSimilarAlbums(albumId, userId, excludeArtistIds, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Finds artists similar to a given artist.
         * @param {string} artistId The artist id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [excludeArtistIds] Optional. Ids of artists to exclude.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarArtists(artistId: string, userId?: string, excludeArtistIds?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).getSimilarArtists(artistId, userId, excludeArtistIds, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AlbumsApi - factory interface
 * @export
 */
export const AlbumsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Finds albums similar to a given album.
         * @param {string} albumId The album id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [excludeArtistIds] Optional. Ids of artists to exclude.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarAlbums(albumId: string, userId?: string, excludeArtistIds?: string, limit?: number, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return AlbumsApiFp(configuration).getSimilarAlbums(albumId, userId, excludeArtistIds, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finds artists similar to a given artist.
         * @param {string} artistId The artist id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [excludeArtistIds] Optional. Ids of artists to exclude.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarArtists(artistId: string, userId?: string, excludeArtistIds?: string, limit?: number, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return AlbumsApiFp(configuration).getSimilarArtists(artistId, userId, excludeArtistIds, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlbumsApi - object-oriented interface
 * @export
 * @class AlbumsApi
 * @extends {BaseAPI}
 */
export class AlbumsApi extends BaseAPI {
    /**
     * 
     * @summary Finds albums similar to a given album.
     * @param {string} albumId The album id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {string} [excludeArtistIds] Optional. Ids of artists to exclude.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public getSimilarAlbums(albumId: string, userId?: string, excludeArtistIds?: string, limit?: number, options?: any) {
        return AlbumsApiFp(this.configuration).getSimilarAlbums(albumId, userId, excludeArtistIds, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finds artists similar to a given artist.
     * @param {string} artistId The artist id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {string} [excludeArtistIds] Optional. Ids of artists to exclude.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public getSimilarArtists(artistId: string, userId?: string, excludeArtistIds?: string, limit?: number, options?: any) {
        return AlbumsApiFp(this.configuration).getSimilarArtists(artistId, userId, excludeArtistIds, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new api key.
         * @param {string} app Name of the app using the authentication key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (app: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            if (app === null || app === undefined) {
                throw new RequiredError('app','Required parameter app was null or undefined when calling createKey.');
            }
            const localVarPath = `/Auth/Keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/Keys`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an api key.
         * @param {string} key The access token to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeKey: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling revokeKey.');
            }
            const localVarPath = `/Auth/Keys/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new api key.
         * @param {string} app Name of the app using the authentication key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(app: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).createKey(app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationInfoQueryResult>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).getKeys(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove an api key.
         * @param {string} key The access token to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeKey(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).revokeKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a new api key.
         * @param {string} app Name of the app using the authentication key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(app: string, options?: any): AxiosPromise<void> {
            return ApiKeyApiFp(configuration).createKey(app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys(options?: any): AxiosPromise<AuthenticationInfoQueryResult> {
            return ApiKeyApiFp(configuration).getKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an api key.
         * @param {string} key The access token to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeKey(key: string, options?: any): AxiosPromise<void> {
            return ApiKeyApiFp(configuration).revokeKey(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * 
     * @summary Create a new api key.
     * @param {string} app Name of the app using the authentication key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public createKey(app: string, options?: any) {
        return ApiKeyApiFp(this.configuration).createKey(app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public getKeys(options?: any) {
        return ApiKeyApiFp(this.configuration).getKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an api key.
     * @param {string} key The access token to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public revokeKey(key: string, options?: any) {
        return ApiKeyApiFp(this.configuration).revokeKey(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtistsApi - axios parameter creator
 * @export
 */
export const ArtistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets all album artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumArtists: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Artists/AlbumArtists`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an artist by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistByName: async (name: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getArtistByName.');
            }
            const localVarPath = `/Artists/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtists: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Artists`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtistsApi - functional programming interface
 * @export
 */
export const ArtistsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets all album artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ArtistsApiAxiosParamCreator(configuration).getAlbumArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an artist by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistByName(name: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await ArtistsApiAxiosParamCreator(configuration).getArtistByName(name, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ArtistsApiAxiosParamCreator(configuration).getArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ArtistsApi - factory interface
 * @export
 */
export const ArtistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets all album artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ArtistsApiFp(configuration).getAlbumArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an artist by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistByName(name: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return ArtistsApiFp(configuration).getArtistByName(name, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ArtistsApiFp(configuration).getArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtistsApi - object-oriented interface
 * @export
 * @class ArtistsApi
 * @extends {BaseAPI}
 */
export class ArtistsApi extends BaseAPI {
    /**
     * 
     * @summary Gets all album artists from a given item, folder, or the entire library.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [searchTerm] Optional. Search term.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
     * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
     * @param {boolean} [enableUserData] Optional, include user data.
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
     * @param {string} [userId] User id.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {boolean} [enableImages] Optional, include image information in output.
     * @param {boolean} [enableTotalRecordCount] Total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtistsApi
     */
    public getAlbumArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return ArtistsApiFp(this.configuration).getAlbumArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an artist by name.
     * @param {string} name Studio name.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtistsApi
     */
    public getArtistByName(name: string, userId?: string, options?: any) {
        return ArtistsApiFp(this.configuration).getArtistByName(name, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all artists from a given item, folder, or the entire library.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [searchTerm] Optional. Search term.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
     * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
     * @param {boolean} [enableUserData] Optional, include user data.
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
     * @param {string} [userId] User id.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {boolean} [enableImages] Optional, include image information in output.
     * @param {boolean} [enableTotalRecordCount] Total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtistsApi
     */
    public getArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return ArtistsApiFp(this.configuration).getArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AudioApi - axios parameter creator
 * @export
 */
export const AudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAudioStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStreamByContainer: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAudioStreamByContainer.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getAudioStreamByContainer.');
            }
            const localVarPath = `/Audio/{itemId}/stream.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headAudioStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStreamByContainer: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headAudioStreamByContainer.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headAudioStreamByContainer.');
            }
            const localVarPath = `/Audio/{itemId}/stream.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioApi - functional programming interface
 * @export
 */
export const AudioApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).getAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).getAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).headAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).headAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AudioApi - factory interface
 * @export
 */
export const AudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return AudioApiFp(configuration).getAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return AudioApiFp(configuration).getAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return AudioApiFp(configuration).headAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return AudioApiFp(configuration).headAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AudioApi - object-oriented interface
 * @export
 * @class AudioApi
 * @extends {BaseAPI}
 */
export class AudioApi extends BaseAPI {
    /**
     * 
     * @summary Gets an audio stream.
     * @param {string} itemId The item id.
     * @param {string} container The audio container.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public getAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return AudioApiFp(this.configuration).getAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream.
     * @param {string} itemId The item id.
     * @param {string} container The audio container.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public getAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return AudioApiFp(this.configuration).getAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream.
     * @param {string} itemId The item id.
     * @param {string} container The audio container.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public headAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return AudioApiFp(this.configuration).headAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream.
     * @param {string} itemId The item id.
     * @param {string} container The audio container.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public headAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return AudioApiFp(this.configuration).headAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BrandingApi - axios parameter creator
 * @export
 */
export const BrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Branding/Css`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Branding/Css.css`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets branding configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingOptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Branding/Configuration`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandingApi - functional programming interface
 * @export
 */
export const BrandingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingCss(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BrandingApiAxiosParamCreator(configuration).getBrandingCss(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingCss2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BrandingApiAxiosParamCreator(configuration).getBrandingCss2(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets branding configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingOptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandingOptions>> {
            const localVarAxiosArgs = await BrandingApiAxiosParamCreator(configuration).getBrandingOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BrandingApi - factory interface
 * @export
 */
export const BrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss(options?: any): AxiosPromise<string> {
            return BrandingApiFp(configuration).getBrandingCss(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss2(options?: any): AxiosPromise<string> {
            return BrandingApiFp(configuration).getBrandingCss2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets branding configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingOptions(options?: any): AxiosPromise<BrandingOptions> {
            return BrandingApiFp(configuration).getBrandingOptions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
export class BrandingApi extends BaseAPI {
    /**
     * 
     * @summary Gets branding css.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingCss(options?: any) {
        return BrandingApiFp(this.configuration).getBrandingCss(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets branding css.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingCss2(options?: any) {
        return BrandingApiFp(this.configuration).getBrandingCss2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets branding configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingOptions(options?: any) {
        return BrandingApiFp(this.configuration).getBrandingOptions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChannelsApi - axios parameter creator
 * @export
 */
export const ChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all channel features.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllChannelFeatures: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Channels/Features`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel features.
         * @param {string} channelId Channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelFeatures: async (channelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getChannelFeatures.');
            }
            const localVarPath = `/Channels/{channelId}/Features`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel items.
         * @param {string} channelId Channel Id.
         * @param {string} [folderId] Optional. Folder Id.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Optional. Sort Order - Ascending,Descending.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelItems: async (channelId: string, folderId?: string, userId?: string, startIndex?: number, limit?: number, sortOrder?: string, filters?: string, sortBy?: string, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getChannelItems.');
            }
            const localVarPath = `/Channels/{channelId}/Items`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available channels.
         * @param {string} [userId] User Id to filter by. Use System.Guid.Empty to not filter by user.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [supportsLatestItems] Optional. Filter by channels that support getting latest items.
         * @param {boolean} [supportsMediaDeletion] Optional. Filter by channels that support media deletion.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels: async (userId?: string, startIndex?: number, limit?: number, supportsLatestItems?: boolean, supportsMediaDeletion?: boolean, isFavorite?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (supportsLatestItems !== undefined) {
                localVarQueryParameter['supportsLatestItems'] = supportsLatestItems;
            }

            if (supportsMediaDeletion !== undefined) {
                localVarQueryParameter['supportsMediaDeletion'] = supportsMediaDeletion;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets latest channel items.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [channelIds] Optional. Specify one or more channel id\&#39;s, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestChannelItems: async (userId?: string, startIndex?: number, limit?: number, filters?: string, fields?: string, channelIds?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Channels/Items/Latest`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (channelIds !== undefined) {
                localVarQueryParameter['channelIds'] = channelIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all channel features.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllChannelFeatures(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChannelFeatures>>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getAllChannelFeatures(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get channel features.
         * @param {string} channelId Channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelFeatures(channelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelFeatures>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannelFeatures(channelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get channel items.
         * @param {string} channelId Channel Id.
         * @param {string} [folderId] Optional. Folder Id.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Optional. Sort Order - Ascending,Descending.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelItems(channelId: string, folderId?: string, userId?: string, startIndex?: number, limit?: number, sortOrder?: string, filters?: string, sortBy?: string, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannelItems(channelId, folderId, userId, startIndex, limit, sortOrder, filters, sortBy, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available channels.
         * @param {string} [userId] User Id to filter by. Use System.Guid.Empty to not filter by user.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [supportsLatestItems] Optional. Filter by channels that support getting latest items.
         * @param {boolean} [supportsMediaDeletion] Optional. Filter by channels that support media deletion.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannels(userId?: string, startIndex?: number, limit?: number, supportsLatestItems?: boolean, supportsMediaDeletion?: boolean, isFavorite?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannels(userId, startIndex, limit, supportsLatestItems, supportsMediaDeletion, isFavorite, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets latest channel items.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [channelIds] Optional. Specify one or more channel id\&#39;s, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestChannelItems(userId?: string, startIndex?: number, limit?: number, filters?: string, fields?: string, channelIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getLatestChannelItems(userId, startIndex, limit, filters, fields, channelIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all channel features.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllChannelFeatures(options?: any): AxiosPromise<Array<ChannelFeatures>> {
            return ChannelsApiFp(configuration).getAllChannelFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel features.
         * @param {string} channelId Channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelFeatures(channelId: string, options?: any): AxiosPromise<ChannelFeatures> {
            return ChannelsApiFp(configuration).getChannelFeatures(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel items.
         * @param {string} channelId Channel Id.
         * @param {string} [folderId] Optional. Folder Id.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Optional. Sort Order - Ascending,Descending.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelItems(channelId: string, folderId?: string, userId?: string, startIndex?: number, limit?: number, sortOrder?: string, filters?: string, sortBy?: string, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ChannelsApiFp(configuration).getChannelItems(channelId, folderId, userId, startIndex, limit, sortOrder, filters, sortBy, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available channels.
         * @param {string} [userId] User Id to filter by. Use System.Guid.Empty to not filter by user.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [supportsLatestItems] Optional. Filter by channels that support getting latest items.
         * @param {boolean} [supportsMediaDeletion] Optional. Filter by channels that support media deletion.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(userId?: string, startIndex?: number, limit?: number, supportsLatestItems?: boolean, supportsMediaDeletion?: boolean, isFavorite?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ChannelsApiFp(configuration).getChannels(userId, startIndex, limit, supportsLatestItems, supportsMediaDeletion, isFavorite, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets latest channel items.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [channelIds] Optional. Specify one or more channel id\&#39;s, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestChannelItems(userId?: string, startIndex?: number, limit?: number, filters?: string, fields?: string, channelIds?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ChannelsApiFp(configuration).getLatestChannelItems(userId, startIndex, limit, filters, fields, channelIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI {
    /**
     * 
     * @summary Get all channel features.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getAllChannelFeatures(options?: any) {
        return ChannelsApiFp(this.configuration).getAllChannelFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel features.
     * @param {string} channelId Channel id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannelFeatures(channelId: string, options?: any) {
        return ChannelsApiFp(this.configuration).getChannelFeatures(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel items.
     * @param {string} channelId Channel Id.
     * @param {string} [folderId] Optional. Folder Id.
     * @param {string} [userId] Optional. User Id.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [sortOrder] Optional. Sort Order - Ascending,Descending.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannelItems(channelId: string, folderId?: string, userId?: string, startIndex?: number, limit?: number, sortOrder?: string, filters?: string, sortBy?: string, fields?: string, options?: any) {
        return ChannelsApiFp(this.configuration).getChannelItems(channelId, folderId, userId, startIndex, limit, sortOrder, filters, sortBy, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available channels.
     * @param {string} [userId] User Id to filter by. Use System.Guid.Empty to not filter by user.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [supportsLatestItems] Optional. Filter by channels that support getting latest items.
     * @param {boolean} [supportsMediaDeletion] Optional. Filter by channels that support media deletion.
     * @param {boolean} [isFavorite] Optional. Filter by channels that are favorite.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannels(userId?: string, startIndex?: number, limit?: number, supportsLatestItems?: boolean, supportsMediaDeletion?: boolean, isFavorite?: boolean, options?: any) {
        return ChannelsApiFp(this.configuration).getChannels(userId, startIndex, limit, supportsLatestItems, supportsMediaDeletion, isFavorite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets latest channel items.
     * @param {string} [userId] Optional. User Id.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [channelIds] Optional. Specify one or more channel id\&#39;s, comma delimited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getLatestChannelItems(userId?: string, startIndex?: number, limit?: number, filters?: string, fields?: string, channelIds?: string, options?: any) {
        return ChannelsApiFp(this.configuration).getLatestChannelItems(userId, startIndex, limit, filters, fields, channelIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds items to a collection.
         * @param {string} collectionId The collection id.
         * @param {string} itemIds Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToCollection: async (collectionId: string, itemIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling addToCollection.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling addToCollection.');
            }
            const localVarPath = `/Collections/{collectionId}/Items`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemIds !== undefined) {
                localVarQueryParameter['itemIds'] = itemIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new collection.
         * @param {string} [name] The name of the collection.
         * @param {string} [ids] Item Ids to add to the collection.
         * @param {string} [parentId] Optional. Create the collection within a specific folder.
         * @param {boolean} [isLocked] Whether or not to lock the new collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (name?: string, ids?: string, parentId?: string, isLocked?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Collections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes items from a collection.
         * @param {string} collectionId The collection id.
         * @param {string} itemIds Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromCollection: async (collectionId: string, itemIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling removeFromCollection.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling removeFromCollection.');
            }
            const localVarPath = `/Collections/{collectionId}/Items`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemIds !== undefined) {
                localVarQueryParameter['itemIds'] = itemIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds items to a collection.
         * @param {string} collectionId The collection id.
         * @param {string} itemIds Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToCollection(collectionId: string, itemIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CollectionApiAxiosParamCreator(configuration).addToCollection(collectionId, itemIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new collection.
         * @param {string} [name] The name of the collection.
         * @param {string} [ids] Item Ids to add to the collection.
         * @param {string} [parentId] Optional. Create the collection within a specific folder.
         * @param {boolean} [isLocked] Whether or not to lock the new collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(name?: string, ids?: string, parentId?: string, isLocked?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionCreationResult>> {
            const localVarAxiosArgs = await CollectionApiAxiosParamCreator(configuration).createCollection(name, ids, parentId, isLocked, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes items from a collection.
         * @param {string} collectionId The collection id.
         * @param {string} itemIds Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromCollection(collectionId: string, itemIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CollectionApiAxiosParamCreator(configuration).removeFromCollection(collectionId, itemIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds items to a collection.
         * @param {string} collectionId The collection id.
         * @param {string} itemIds Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToCollection(collectionId: string, itemIds: string, options?: any): AxiosPromise<void> {
            return CollectionApiFp(configuration).addToCollection(collectionId, itemIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new collection.
         * @param {string} [name] The name of the collection.
         * @param {string} [ids] Item Ids to add to the collection.
         * @param {string} [parentId] Optional. Create the collection within a specific folder.
         * @param {boolean} [isLocked] Whether or not to lock the new collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(name?: string, ids?: string, parentId?: string, isLocked?: boolean, options?: any): AxiosPromise<CollectionCreationResult> {
            return CollectionApiFp(configuration).createCollection(name, ids, parentId, isLocked, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes items from a collection.
         * @param {string} collectionId The collection id.
         * @param {string} itemIds Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromCollection(collectionId: string, itemIds: string, options?: any): AxiosPromise<void> {
            return CollectionApiFp(configuration).removeFromCollection(collectionId, itemIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * 
     * @summary Adds items to a collection.
     * @param {string} collectionId The collection id.
     * @param {string} itemIds Item ids, comma delimited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public addToCollection(collectionId: string, itemIds: string, options?: any) {
        return CollectionApiFp(this.configuration).addToCollection(collectionId, itemIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new collection.
     * @param {string} [name] The name of the collection.
     * @param {string} [ids] Item Ids to add to the collection.
     * @param {string} [parentId] Optional. Create the collection within a specific folder.
     * @param {boolean} [isLocked] Whether or not to lock the new collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public createCollection(name?: string, ids?: string, parentId?: string, isLocked?: boolean, options?: any) {
        return CollectionApiFp(this.configuration).createCollection(name, ids, parentId, isLocked, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes items from a collection.
     * @param {string} collectionId The collection id.
     * @param {string} itemIds Item ids, comma delimited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeFromCollection(collectionId: string, itemIds: string, options?: any) {
        return CollectionApiFp(this.configuration).removeFromCollection(collectionId, itemIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets application configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Configuration`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a default MetadataOptions object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultMetadataOptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Configuration/MetadataOptions/Default`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamedConfiguration: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getNamedConfiguration.');
            }
            const localVarPath = `/System/Configuration/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates application configuration.
         * @param {ServerConfiguration} serverConfiguration Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguration: async (serverConfiguration: ServerConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverConfiguration' is not null or undefined
            if (serverConfiguration === null || serverConfiguration === undefined) {
                throw new RequiredError('serverConfiguration','Required parameter serverConfiguration was null or undefined when calling updateConfiguration.');
            }
            const localVarPath = `/System/Configuration`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof serverConfiguration !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(serverConfiguration !== undefined ? serverConfiguration : {}) : (serverConfiguration || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the path to the media encoder.
         * @param {MediaEncoderPathDto} mediaEncoderPathDto Media encoder path form body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaEncoderPath: async (mediaEncoderPathDto: MediaEncoderPathDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaEncoderPathDto' is not null or undefined
            if (mediaEncoderPathDto === null || mediaEncoderPathDto === undefined) {
                throw new RequiredError('mediaEncoderPathDto','Required parameter mediaEncoderPathDto was null or undefined when calling updateMediaEncoderPath.');
            }
            const localVarPath = `/System/MediaEncoder/Path`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaEncoderPathDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaEncoderPathDto !== undefined ? mediaEncoderPathDto : {}) : (mediaEncoderPathDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamedConfiguration: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateNamedConfiguration.');
            }
            const localVarPath = `/System/Configuration/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets application configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfiguration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerConfiguration>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).getConfiguration(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a default MetadataOptions object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultMetadataOptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataOptions>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).getDefaultMetadataOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamedConfiguration(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).getNamedConfiguration(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates application configuration.
         * @param {ServerConfiguration} serverConfiguration Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfiguration(serverConfiguration: ServerConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).updateConfiguration(serverConfiguration, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the path to the media encoder.
         * @param {MediaEncoderPathDto} mediaEncoderPathDto Media encoder path form body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMediaEncoderPath(mediaEncoderPathDto: MediaEncoderPathDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).updateMediaEncoderPath(mediaEncoderPathDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamedConfiguration(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).updateNamedConfiguration(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets application configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration(options?: any): AxiosPromise<ServerConfiguration> {
            return ConfigurationApiFp(configuration).getConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a default MetadataOptions object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultMetadataOptions(options?: any): AxiosPromise<MetadataOptions> {
            return ConfigurationApiFp(configuration).getDefaultMetadataOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamedConfiguration(key: string, options?: any): AxiosPromise<any> {
            return ConfigurationApiFp(configuration).getNamedConfiguration(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates application configuration.
         * @param {ServerConfiguration} serverConfiguration Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguration(serverConfiguration: ServerConfiguration, options?: any): AxiosPromise<void> {
            return ConfigurationApiFp(configuration).updateConfiguration(serverConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the path to the media encoder.
         * @param {MediaEncoderPathDto} mediaEncoderPathDto Media encoder path form body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaEncoderPath(mediaEncoderPathDto: MediaEncoderPathDto, options?: any): AxiosPromise<void> {
            return ConfigurationApiFp(configuration).updateMediaEncoderPath(mediaEncoderPathDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamedConfiguration(key: string, options?: any): AxiosPromise<void> {
            return ConfigurationApiFp(configuration).updateNamedConfiguration(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary Gets application configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getConfiguration(options?: any) {
        return ConfigurationApiFp(this.configuration).getConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a default MetadataOptions object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getDefaultMetadataOptions(options?: any) {
        return ConfigurationApiFp(this.configuration).getDefaultMetadataOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a named configuration.
     * @param {string} key Configuration key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getNamedConfiguration(key: string, options?: any) {
        return ConfigurationApiFp(this.configuration).getNamedConfiguration(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates application configuration.
     * @param {ServerConfiguration} serverConfiguration Configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateConfiguration(serverConfiguration: ServerConfiguration, options?: any) {
        return ConfigurationApiFp(this.configuration).updateConfiguration(serverConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the path to the media encoder.
     * @param {MediaEncoderPathDto} mediaEncoderPathDto Media encoder path form body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateMediaEncoderPath(mediaEncoderPathDto: MediaEncoderPathDto, options?: any) {
        return ConfigurationApiFp(this.configuration).updateMediaEncoderPath(mediaEncoderPathDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates named configuration.
     * @param {string} key Configuration key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateNamedConfiguration(key: string, options?: any) {
        return ConfigurationApiFp(this.configuration).updateNamedConfiguration(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the configuration pages.
         * @param {boolean} [enableInMainMenu] Whether to enable in the main menu.
         * @param {ConfigurationPageType} [pageType] The Jellyfin.Api.Models.ConfigurationPageInfo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationPages: async (enableInMainMenu?: boolean, pageType?: ConfigurationPageType, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/web/ConfigurationPages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (enableInMainMenu !== undefined) {
                localVarQueryParameter['enableInMainMenu'] = enableInMainMenu;
            }

            if (pageType !== undefined) {
                localVarQueryParameter['pageType'] = pageType;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a dashboard configuration page.
         * @param {string} [name] The name of the page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardConfigurationPage: async (name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/web/ConfigurationPage`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the configuration pages.
         * @param {boolean} [enableInMainMenu] Whether to enable in the main menu.
         * @param {ConfigurationPageType} [pageType] The Jellyfin.Api.Models.ConfigurationPageInfo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigurationPages(enableInMainMenu?: boolean, pageType?: ConfigurationPageType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigurationPageInfo>>> {
            const localVarAxiosArgs = await DashboardApiAxiosParamCreator(configuration).getConfigurationPages(enableInMainMenu, pageType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a dashboard configuration page.
         * @param {string} [name] The name of the page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardConfigurationPage(name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DashboardApiAxiosParamCreator(configuration).getDashboardConfigurationPage(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets the configuration pages.
         * @param {boolean} [enableInMainMenu] Whether to enable in the main menu.
         * @param {ConfigurationPageType} [pageType] The Jellyfin.Api.Models.ConfigurationPageInfo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationPages(enableInMainMenu?: boolean, pageType?: ConfigurationPageType, options?: any): AxiosPromise<Array<ConfigurationPageInfo>> {
            return DashboardApiFp(configuration).getConfigurationPages(enableInMainMenu, pageType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a dashboard configuration page.
         * @param {string} [name] The name of the page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardConfigurationPage(name?: string, options?: any): AxiosPromise<any> {
            return DashboardApiFp(configuration).getDashboardConfigurationPage(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * 
     * @summary Gets the configuration pages.
     * @param {boolean} [enableInMainMenu] Whether to enable in the main menu.
     * @param {ConfigurationPageType} [pageType] The Jellyfin.Api.Models.ConfigurationPageInfo.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getConfigurationPages(enableInMainMenu?: boolean, pageType?: ConfigurationPageType, options?: any) {
        return DashboardApiFp(this.configuration).getConfigurationPages(enableInMainMenu, pageType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a dashboard configuration page.
     * @param {string} [name] The name of the page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardConfigurationPage(name?: string, options?: any) {
        return DashboardApiFp(this.configuration).getDashboardConfigurationPage(name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDevice.');
            }
            const localVarPath = `/Devices`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get info for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInfo: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeviceInfo.');
            }
            const localVarPath = `/Devices/Info`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get options for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceOptions: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeviceOptions.');
            }
            const localVarPath = `/Devices/Options`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Devices.
         * @param {boolean} [supportsSync] Gets or sets a value indicating whether [supports synchronize].
         * @param {string} [userId] Gets or sets the user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (supportsSync?: boolean, userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Devices`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (supportsSync !== undefined) {
                localVarQueryParameter['supportsSync'] = supportsSync;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update device options.
         * @param {string} id Device Id.
         * @param {DeviceOptions} deviceOptions Device Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceOptions: async (id: string, deviceOptions: DeviceOptions, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDeviceOptions.');
            }
            // verify required parameter 'deviceOptions' is not null or undefined
            if (deviceOptions === null || deviceOptions === undefined) {
                throw new RequiredError('deviceOptions','Required parameter deviceOptions was null or undefined when calling updateDeviceOptions.');
            }
            const localVarPath = `/Devices/Options`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceOptions !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceOptions !== undefined ? deviceOptions : {}) : (deviceOptions || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).deleteDevice(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get info for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceInfo(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceInfo>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).getDeviceInfo(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get options for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceOptions(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceOptions>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).getDeviceOptions(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Devices.
         * @param {boolean} [supportsSync] Gets or sets a value indicating whether [supports synchronize].
         * @param {string} [userId] Gets or sets the user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(supportsSync?: boolean, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceInfoQueryResult>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).getDevices(supportsSync, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update device options.
         * @param {string} id Device Id.
         * @param {DeviceOptions} deviceOptions Device Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceOptions(id: string, deviceOptions: DeviceOptions, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).updateDeviceOptions(id, deviceOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(id: string, options?: any): AxiosPromise<void> {
            return DevicesApiFp(configuration).deleteDevice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get info for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInfo(id: string, options?: any): AxiosPromise<DeviceInfo> {
            return DevicesApiFp(configuration).getDeviceInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get options for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceOptions(id: string, options?: any): AxiosPromise<DeviceOptions> {
            return DevicesApiFp(configuration).getDeviceOptions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Devices.
         * @param {boolean} [supportsSync] Gets or sets a value indicating whether [supports synchronize].
         * @param {string} [userId] Gets or sets the user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(supportsSync?: boolean, userId?: string, options?: any): AxiosPromise<DeviceInfoQueryResult> {
            return DevicesApiFp(configuration).getDevices(supportsSync, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update device options.
         * @param {string} id Device Id.
         * @param {DeviceOptions} deviceOptions Device Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceOptions(id: string, deviceOptions: DeviceOptions, options?: any): AxiosPromise<void> {
            return DevicesApiFp(configuration).updateDeviceOptions(id, deviceOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a device.
     * @param {string} id Device Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDevice(id: string, options?: any) {
        return DevicesApiFp(this.configuration).deleteDevice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get info for a device.
     * @param {string} id Device Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceInfo(id: string, options?: any) {
        return DevicesApiFp(this.configuration).getDeviceInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get options for a device.
     * @param {string} id Device Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceOptions(id: string, options?: any) {
        return DevicesApiFp(this.configuration).getDeviceOptions(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Devices.
     * @param {boolean} [supportsSync] Gets or sets a value indicating whether [supports synchronize].
     * @param {string} [userId] Gets or sets the user identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(supportsSync?: boolean, userId?: string, options?: any) {
        return DevicesApiFp(this.configuration).getDevices(supportsSync, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update device options.
     * @param {string} id Device Id.
     * @param {DeviceOptions} deviceOptions Device Options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceOptions(id: string, deviceOptions: DeviceOptions, options?: any) {
        return DevicesApiFp(this.configuration).updateDeviceOptions(id, deviceOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisplayPreferencesApi - axios parameter creator
 * @export
 */
export const DisplayPreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User id.
         * @param {string} client Client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayPreferences: async (displayPreferencesId: string, userId: string, client: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'displayPreferencesId' is not null or undefined
            if (displayPreferencesId === null || displayPreferencesId === undefined) {
                throw new RequiredError('displayPreferencesId','Required parameter displayPreferencesId was null or undefined when calling getDisplayPreferences.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getDisplayPreferences.');
            }
            // verify required parameter 'client' is not null or undefined
            if (client === null || client === undefined) {
                throw new RequiredError('client','Required parameter client was null or undefined when calling getDisplayPreferences.');
            }
            const localVarPath = `/DisplayPreferences/{displayPreferencesId}`
                .replace(`{${"displayPreferencesId"}}`, encodeURIComponent(String(displayPreferencesId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User Id.
         * @param {string} client Client.
         * @param {DisplayPreferencesDto} displayPreferencesDto New Display Preferences object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDisplayPreferences: async (displayPreferencesId: string, userId: string, client: string, displayPreferencesDto: DisplayPreferencesDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'displayPreferencesId' is not null or undefined
            if (displayPreferencesId === null || displayPreferencesId === undefined) {
                throw new RequiredError('displayPreferencesId','Required parameter displayPreferencesId was null or undefined when calling updateDisplayPreferences.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateDisplayPreferences.');
            }
            // verify required parameter 'client' is not null or undefined
            if (client === null || client === undefined) {
                throw new RequiredError('client','Required parameter client was null or undefined when calling updateDisplayPreferences.');
            }
            // verify required parameter 'displayPreferencesDto' is not null or undefined
            if (displayPreferencesDto === null || displayPreferencesDto === undefined) {
                throw new RequiredError('displayPreferencesDto','Required parameter displayPreferencesDto was null or undefined when calling updateDisplayPreferences.');
            }
            const localVarPath = `/DisplayPreferences/{displayPreferencesId}`
                .replace(`{${"displayPreferencesId"}}`, encodeURIComponent(String(displayPreferencesId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof displayPreferencesDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(displayPreferencesDto !== undefined ? displayPreferencesDto : {}) : (displayPreferencesDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisplayPreferencesApi - functional programming interface
 * @export
 */
export const DisplayPreferencesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User id.
         * @param {string} client Client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisplayPreferences(displayPreferencesId: string, userId: string, client: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisplayPreferencesDto>> {
            const localVarAxiosArgs = await DisplayPreferencesApiAxiosParamCreator(configuration).getDisplayPreferences(displayPreferencesId, userId, client, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User Id.
         * @param {string} client Client.
         * @param {DisplayPreferencesDto} displayPreferencesDto New Display Preferences object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDisplayPreferences(displayPreferencesId: string, userId: string, client: string, displayPreferencesDto: DisplayPreferencesDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DisplayPreferencesApiAxiosParamCreator(configuration).updateDisplayPreferences(displayPreferencesId, userId, client, displayPreferencesDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DisplayPreferencesApi - factory interface
 * @export
 */
export const DisplayPreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User id.
         * @param {string} client Client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayPreferences(displayPreferencesId: string, userId: string, client: string, options?: any): AxiosPromise<DisplayPreferencesDto> {
            return DisplayPreferencesApiFp(configuration).getDisplayPreferences(displayPreferencesId, userId, client, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User Id.
         * @param {string} client Client.
         * @param {DisplayPreferencesDto} displayPreferencesDto New Display Preferences object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDisplayPreferences(displayPreferencesId: string, userId: string, client: string, displayPreferencesDto: DisplayPreferencesDto, options?: any): AxiosPromise<void> {
            return DisplayPreferencesApiFp(configuration).updateDisplayPreferences(displayPreferencesId, userId, client, displayPreferencesDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisplayPreferencesApi - object-oriented interface
 * @export
 * @class DisplayPreferencesApi
 * @extends {BaseAPI}
 */
export class DisplayPreferencesApi extends BaseAPI {
    /**
     * 
     * @summary Get Display Preferences.
     * @param {string} displayPreferencesId Display preferences id.
     * @param {string} userId User id.
     * @param {string} client Client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayPreferencesApi
     */
    public getDisplayPreferences(displayPreferencesId: string, userId: string, client: string, options?: any) {
        return DisplayPreferencesApiFp(this.configuration).getDisplayPreferences(displayPreferencesId, userId, client, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Display Preferences.
     * @param {string} displayPreferencesId Display preferences id.
     * @param {string} userId User Id.
     * @param {string} client Client.
     * @param {DisplayPreferencesDto} displayPreferencesDto New Display Preferences object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayPreferencesApi
     */
    public updateDisplayPreferences(displayPreferencesId: string, userId: string, client: string, displayPreferencesDto: DisplayPreferencesDto, options?: any) {
        return DisplayPreferencesApiFp(this.configuration).updateDisplayPreferences(displayPreferencesId, userId, client, displayPreferencesDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DlnaApi - axios parameter creator
 * @export
 */
export const DlnaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a profile.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (deviceProfile?: DeviceProfile, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Dlna/Profiles`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceProfile !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceProfile !== undefined ? deviceProfile : {}) : (deviceProfile || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a profile.
         * @param {string} profileId Profile id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: async (profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            if (profileId === null || profileId === undefined) {
                throw new RequiredError('profileId','Required parameter profileId was null or undefined when calling deleteProfile.');
            }
            const localVarPath = `/Dlna/Profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the default profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultProfile: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Dlna/Profiles/Default`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a single profile.
         * @param {string} profileId Profile Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            if (profileId === null || profileId === undefined) {
                throw new RequiredError('profileId','Required parameter profileId was null or undefined when calling getProfile.');
            }
            const localVarPath = `/Dlna/Profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get profile infos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInfos: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Dlna/ProfileInfos`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a profile.
         * @param {string} profileId Profile id.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (profileId: string, deviceProfile?: DeviceProfile, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            if (profileId === null || profileId === undefined) {
                throw new RequiredError('profileId','Required parameter profileId was null or undefined when calling updateProfile.');
            }
            const localVarPath = `/Dlna/Profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceProfile !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceProfile !== undefined ? deviceProfile : {}) : (deviceProfile || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DlnaApi - functional programming interface
 * @export
 */
export const DlnaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a profile.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(deviceProfile?: DeviceProfile, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).createProfile(deviceProfile, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a profile.
         * @param {string} profileId Profile id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfile(profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).deleteProfile(profileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the default profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultProfile(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceProfile>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).getDefaultProfile(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a single profile.
         * @param {string} profileId Profile Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceProfile>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).getProfile(profileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get profile infos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileInfos(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceProfileInfo>>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).getProfileInfos(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a profile.
         * @param {string} profileId Profile id.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(profileId: string, deviceProfile?: DeviceProfile, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).updateProfile(profileId, deviceProfile, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DlnaApi - factory interface
 * @export
 */
export const DlnaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates a profile.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(deviceProfile?: DeviceProfile, options?: any): AxiosPromise<void> {
            return DlnaApiFp(configuration).createProfile(deviceProfile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a profile.
         * @param {string} profileId Profile id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(profileId: string, options?: any): AxiosPromise<void> {
            return DlnaApiFp(configuration).deleteProfile(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the default profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultProfile(options?: any): AxiosPromise<DeviceProfile> {
            return DlnaApiFp(configuration).getDefaultProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a single profile.
         * @param {string} profileId Profile Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(profileId: string, options?: any): AxiosPromise<DeviceProfile> {
            return DlnaApiFp(configuration).getProfile(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get profile infos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInfos(options?: any): AxiosPromise<Array<DeviceProfileInfo>> {
            return DlnaApiFp(configuration).getProfileInfos(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a profile.
         * @param {string} profileId Profile id.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(profileId: string, deviceProfile?: DeviceProfile, options?: any): AxiosPromise<void> {
            return DlnaApiFp(configuration).updateProfile(profileId, deviceProfile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DlnaApi - object-oriented interface
 * @export
 * @class DlnaApi
 * @extends {BaseAPI}
 */
export class DlnaApi extends BaseAPI {
    /**
     * 
     * @summary Creates a profile.
     * @param {DeviceProfile} [deviceProfile] Device profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public createProfile(deviceProfile?: DeviceProfile, options?: any) {
        return DlnaApiFp(this.configuration).createProfile(deviceProfile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a profile.
     * @param {string} profileId Profile id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public deleteProfile(profileId: string, options?: any) {
        return DlnaApiFp(this.configuration).deleteProfile(profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the default profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public getDefaultProfile(options?: any) {
        return DlnaApiFp(this.configuration).getDefaultProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a single profile.
     * @param {string} profileId Profile Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public getProfile(profileId: string, options?: any) {
        return DlnaApiFp(this.configuration).getProfile(profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get profile infos.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public getProfileInfos(options?: any) {
        return DlnaApiFp(this.configuration).getProfileInfos(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a profile.
     * @param {string} profileId Profile id.
     * @param {DeviceProfile} [deviceProfile] Device profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public updateProfile(profileId: string, deviceProfile?: DeviceProfile, options?: any) {
        return DlnaApiFp(this.configuration).updateProfile(profileId, deviceProfile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DlnaServerApi - axios parameter creator
 * @export
 */
export const DlnaServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getConnectionManager.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getConnectionManager2.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager/ConnectionManager`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager3: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getConnectionManager3.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager/ConnectionManager.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getContentDirectory.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getContentDirectory2.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory/ContentDirectory`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory3: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getContentDirectory3.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory/ContentDirectory.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getDescriptionXml.');
            }
            const localVarPath = `/Dlna/{serverId}/description`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getDescriptionXml2.');
            }
            const localVarPath = `/Dlna/{serverId}/description.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcon: async (fileName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling getIcon.');
            }
            const localVarPath = `/Dlna/icons/{fileName}`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} serverId Server UUID.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIconId: async (serverId: string, fileName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getIconId.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling getIconId.');
            }
            const localVarPath = `/Dlna/{serverId}/icons/{fileName}`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getMediaReceiverRegistrar.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getMediaReceiverRegistrar2.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar3: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getMediaReceiverRegistrar3.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process a connection manager control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processConnectionManagerControlRequest: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling processConnectionManagerControlRequest.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager/Control`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process a content directory control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processContentDirectoryControlRequest: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling processContentDirectoryControlRequest.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory/Control`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process a media receiver registrar control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMediaReceiverRegistrarControlRequest: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling processMediaReceiverRegistrarControlRequest.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar/Control`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DlnaServerApi - functional programming interface
 * @export
 */
export const DlnaServerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionManager(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getConnectionManager(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionManager2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getConnectionManager2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionManager3(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getConnectionManager3(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentDirectory(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getContentDirectory(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentDirectory2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getContentDirectory2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentDirectory3(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getContentDirectory3(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDescriptionXml(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getDescriptionXml(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDescriptionXml2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getDescriptionXml2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIcon(fileName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getIcon(fileName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} serverId Server UUID.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIconId(serverId: string, fileName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getIconId(serverId, fileName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaReceiverRegistrar(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getMediaReceiverRegistrar(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaReceiverRegistrar2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getMediaReceiverRegistrar2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaReceiverRegistrar3(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getMediaReceiverRegistrar3(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Process a connection manager control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processConnectionManagerControlRequest(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlResponse>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).processConnectionManagerControlRequest(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Process a content directory control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processContentDirectoryControlRequest(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlResponse>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).processContentDirectoryControlRequest(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Process a media receiver registrar control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processMediaReceiverRegistrarControlRequest(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlResponse>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).processMediaReceiverRegistrarControlRequest(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DlnaServerApi - factory interface
 * @export
 */
export const DlnaServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getConnectionManager(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager2(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getConnectionManager2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager3(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getConnectionManager3(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getContentDirectory(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory2(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getContentDirectory2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory3(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getContentDirectory3(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getDescriptionXml(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml2(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getDescriptionXml2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcon(fileName: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getIcon(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} serverId Server UUID.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIconId(serverId: string, fileName: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getIconId(serverId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getMediaReceiverRegistrar(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar2(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getMediaReceiverRegistrar2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar3(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getMediaReceiverRegistrar3(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process a connection manager control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processConnectionManagerControlRequest(serverId: string, options?: any): AxiosPromise<ControlResponse> {
            return DlnaServerApiFp(configuration).processConnectionManagerControlRequest(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process a content directory control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processContentDirectoryControlRequest(serverId: string, options?: any): AxiosPromise<ControlResponse> {
            return DlnaServerApiFp(configuration).processContentDirectoryControlRequest(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process a media receiver registrar control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMediaReceiverRegistrarControlRequest(serverId: string, options?: any): AxiosPromise<ControlResponse> {
            return DlnaServerApiFp(configuration).processMediaReceiverRegistrarControlRequest(serverId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DlnaServerApi - object-oriented interface
 * @export
 * @class DlnaServerApi
 * @extends {BaseAPI}
 */
export class DlnaServerApi extends BaseAPI {
    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getConnectionManager(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getConnectionManager(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getConnectionManager2(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getConnectionManager2(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getConnectionManager3(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getConnectionManager3(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna content directory xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getContentDirectory(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getContentDirectory(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna content directory xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getContentDirectory2(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getContentDirectory2(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna content directory xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getContentDirectory3(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getContentDirectory3(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Description Xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getDescriptionXml(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getDescriptionXml(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Description Xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getDescriptionXml2(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getDescriptionXml2(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a server icon.
     * @param {string} fileName The icon filename.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getIcon(fileName: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getIcon(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a server icon.
     * @param {string} serverId Server UUID.
     * @param {string} fileName The icon filename.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getIconId(serverId: string, fileName: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getIconId(serverId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getMediaReceiverRegistrar(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getMediaReceiverRegistrar(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getMediaReceiverRegistrar2(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getMediaReceiverRegistrar2(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getMediaReceiverRegistrar3(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).getMediaReceiverRegistrar3(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process a connection manager control request.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public processConnectionManagerControlRequest(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).processConnectionManagerControlRequest(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process a content directory control request.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public processContentDirectoryControlRequest(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).processContentDirectoryControlRequest(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process a media receiver registrar control request.
     * @param {string} serverId Server UUID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public processMediaReceiverRegistrarControlRequest(serverId: string, options?: any) {
        return DlnaServerApiFp(this.configuration).processMediaReceiverRegistrarControlRequest(serverId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DynamicHlsApi - axios parameter creator
 * @export
 */
export const DynamicHlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegment: async (itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsAudioSegment.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsAudioSegment.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsAudioSegment.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getHlsAudioSegment.');
            }
            const localVarPath = `/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegment: async (itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsVideoSegment.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsVideoSegment.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsVideoSegment.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getHlsVideoSegment.');
            }
            const localVarPath = `/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsAudioPlaylist: async (itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getMasterHlsAudioPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getMasterHlsAudioPlaylist.');
            }
            const localVarPath = `/Audio/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsVideoPlaylist: async (itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getMasterHlsVideoPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getMasterHlsVideoPlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsAudioPlaylist: async (itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVariantHlsAudioPlaylist.');
            }
            const localVarPath = `/Audio/{itemId}/main.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsVideoPlaylist: async (itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVariantHlsVideoPlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/main.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsAudioPlaylist: async (itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headMasterHlsAudioPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling headMasterHlsAudioPlaylist.');
            }
            const localVarPath = `/Audio/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsVideoPlaylist: async (itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headMasterHlsVideoPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling headMasterHlsVideoPlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DynamicHlsApi - functional programming interface
 * @export
 */
export const DynamicHlsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsAudioSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getHlsAudioSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsVideoSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getHlsVideoSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterHlsAudioPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getMasterHlsAudioPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterHlsVideoPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getMasterHlsVideoPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariantHlsAudioPlaylist(itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getVariantHlsAudioPlaylist(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariantHlsVideoPlaylist(itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getVariantHlsVideoPlaylist(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMasterHlsAudioPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).headMasterHlsAudioPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMasterHlsVideoPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).headMasterHlsVideoPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DynamicHlsApi - factory interface
 * @export
 */
export const DynamicHlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getHlsAudioSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getHlsVideoSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsAudioPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getMasterHlsAudioPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsVideoPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getMasterHlsVideoPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsAudioPlaylist(itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getVariantHlsAudioPlaylist(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsVideoPlaylist(itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getVariantHlsVideoPlaylist(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsAudioPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).headMasterHlsAudioPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsVideoPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).headMasterHlsVideoPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DynamicHlsApi - object-oriented interface
 * @export
 * @class DynamicHlsApi
 * @extends {BaseAPI}
 */
export class DynamicHlsApi extends BaseAPI {
    /**
     * 
     * @summary Gets a video stream using HTTP live streaming.
     * @param {string} itemId The item id.
     * @param {string} playlistId The playlist id.
     * @param {number} segmentId The segment id.
     * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getHlsAudioSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return DynamicHlsApiFp(this.configuration).getHlsAudioSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream using HTTP live streaming.
     * @param {string} itemId The item id.
     * @param {string} playlistId The playlist id.
     * @param {number} segmentId The segment id.
     * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getHlsVideoSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return DynamicHlsApiFp(this.configuration).getHlsVideoSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio hls playlist stream.
     * @param {string} itemId The item id.
     * @param {string} mediaSourceId The media version id, if playing an alternate version.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getMasterHlsAudioPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any) {
        return DynamicHlsApiFp(this.configuration).getMasterHlsAudioPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video hls playlist stream.
     * @param {string} itemId The item id.
     * @param {string} mediaSourceId The media version id, if playing an alternate version.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getMasterHlsVideoPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any) {
        return DynamicHlsApiFp(this.configuration).getMasterHlsVideoPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream using HTTP live streaming.
     * @param {string} itemId The item id.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getVariantHlsAudioPlaylist(itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return DynamicHlsApiFp(this.configuration).getVariantHlsAudioPlaylist(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream using HTTP live streaming.
     * @param {string} itemId The item id.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getVariantHlsVideoPlaylist(itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return DynamicHlsApiFp(this.configuration).getVariantHlsVideoPlaylist(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio hls playlist stream.
     * @param {string} itemId The item id.
     * @param {string} mediaSourceId The media version id, if playing an alternate version.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public headMasterHlsAudioPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any) {
        return DynamicHlsApiFp(this.configuration).headMasterHlsAudioPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video hls playlist stream.
     * @param {string} itemId The item id.
     * @param {string} mediaSourceId The media version id, if playing an alternate version.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public headMasterHlsVideoPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any) {
        return DynamicHlsApiFp(this.configuration).headMasterHlsVideoPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Default directory browser.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDirectoryBrowser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Environment/DefaultDirectoryBrowser`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the contents of a given directory in the file system.
         * @param {string} path The path.
         * @param {boolean} [includeFiles] An optional filter to include or exclude files from the results. true/false.
         * @param {boolean} [includeDirectories] An optional filter to include or exclude folders from the results. true/false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectoryContents: async (path: string, includeFiles?: boolean, includeDirectories?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getDirectoryContents.');
            }
            const localVarPath = `/Environment/DirectoryContents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (includeFiles !== undefined) {
                localVarQueryParameter['includeFiles'] = includeFiles;
            }

            if (includeDirectories !== undefined) {
                localVarQueryParameter['includeDirectories'] = includeDirectories;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available drives from the server\'s file system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrives: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Environment/Drives`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets network paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkShares: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Environment/NetworkShares`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the parent path of a given path.
         * @param {string} path The path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentPath: async (path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getParentPath.');
            }
            const localVarPath = `/Environment/ParentPath`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validates path.
         * @param {ValidatePathDto} validatePathDto Validate request object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePath: async (validatePathDto: ValidatePathDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatePathDto' is not null or undefined
            if (validatePathDto === null || validatePathDto === undefined) {
                throw new RequiredError('validatePathDto','Required parameter validatePathDto was null or undefined when calling validatePath.');
            }
            const localVarPath = `/Environment/ValidatePath`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof validatePathDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(validatePathDto !== undefined ? validatePathDto : {}) : (validatePathDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Default directory browser.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultDirectoryBrowser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultDirectoryBrowserInfoDto>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getDefaultDirectoryBrowser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the contents of a given directory in the file system.
         * @param {string} path The path.
         * @param {boolean} [includeFiles] An optional filter to include or exclude files from the results. true/false.
         * @param {boolean} [includeDirectories] An optional filter to include or exclude folders from the results. true/false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectoryContents(path: string, includeFiles?: boolean, includeDirectories?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileSystemEntryInfo>>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getDirectoryContents(path, includeFiles, includeDirectories, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available drives from the server\'s file system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDrives(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileSystemEntryInfo>>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getDrives(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets network paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkShares(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileSystemEntryInfo>>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getNetworkShares(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the parent path of a given path.
         * @param {string} path The path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentPath(path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getParentPath(path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Validates path.
         * @param {ValidatePathDto} validatePathDto Validate request object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePath(validatePathDto: ValidatePathDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).validatePath(validatePathDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get Default directory browser.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDirectoryBrowser(options?: any): AxiosPromise<DefaultDirectoryBrowserInfoDto> {
            return EnvironmentApiFp(configuration).getDefaultDirectoryBrowser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the contents of a given directory in the file system.
         * @param {string} path The path.
         * @param {boolean} [includeFiles] An optional filter to include or exclude files from the results. true/false.
         * @param {boolean} [includeDirectories] An optional filter to include or exclude folders from the results. true/false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectoryContents(path: string, includeFiles?: boolean, includeDirectories?: boolean, options?: any): AxiosPromise<Array<FileSystemEntryInfo>> {
            return EnvironmentApiFp(configuration).getDirectoryContents(path, includeFiles, includeDirectories, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available drives from the server\'s file system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrives(options?: any): AxiosPromise<Array<FileSystemEntryInfo>> {
            return EnvironmentApiFp(configuration).getDrives(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets network paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkShares(options?: any): AxiosPromise<Array<FileSystemEntryInfo>> {
            return EnvironmentApiFp(configuration).getNetworkShares(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the parent path of a given path.
         * @param {string} path The path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentPath(path: string, options?: any): AxiosPromise<string> {
            return EnvironmentApiFp(configuration).getParentPath(path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validates path.
         * @param {ValidatePathDto} validatePathDto Validate request object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePath(validatePathDto: ValidatePathDto, options?: any): AxiosPromise<void> {
            return EnvironmentApiFp(configuration).validatePath(validatePathDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * 
     * @summary Get Default directory browser.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getDefaultDirectoryBrowser(options?: any) {
        return EnvironmentApiFp(this.configuration).getDefaultDirectoryBrowser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the contents of a given directory in the file system.
     * @param {string} path The path.
     * @param {boolean} [includeFiles] An optional filter to include or exclude files from the results. true/false.
     * @param {boolean} [includeDirectories] An optional filter to include or exclude folders from the results. true/false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getDirectoryContents(path: string, includeFiles?: boolean, includeDirectories?: boolean, options?: any) {
        return EnvironmentApiFp(this.configuration).getDirectoryContents(path, includeFiles, includeDirectories, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available drives from the server\'s file system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getDrives(options?: any) {
        return EnvironmentApiFp(this.configuration).getDrives(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets network paths.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getNetworkShares(options?: any) {
        return EnvironmentApiFp(this.configuration).getNetworkShares(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the parent path of a given path.
     * @param {string} path The path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getParentPath(path: string, options?: any) {
        return EnvironmentApiFp(this.configuration).getParentPath(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validates path.
     * @param {ValidatePathDto} validatePathDto Validate request object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public validatePath(validatePathDto: ValidatePathDto, options?: any) {
        return EnvironmentApiFp(this.configuration).validatePath(validatePathDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilterApi - axios parameter creator
 * @export
 */
export const FilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isAiring] Optional. Is item airing.
         * @param {boolean} [isMovie] Optional. Is item movie.
         * @param {boolean} [isSports] Optional. Is item sports.
         * @param {boolean} [isKids] Optional. Is item kids.
         * @param {boolean} [isNews] Optional. Is item news.
         * @param {boolean} [isSeries] Optional. Is item series.
         * @param {boolean} [recursive] Optional. Search recursive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFilters: async (userId?: string, parentId?: string, includeItemTypes?: string, isAiring?: boolean, isMovie?: boolean, isSports?: boolean, isKids?: boolean, isNews?: boolean, isSeries?: boolean, recursive?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items/Filters2`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets legacy query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Parent id.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFiltersLegacy: async (userId?: string, parentId?: string, includeItemTypes?: string, mediaTypes?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items/Filters`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterApi - functional programming interface
 * @export
 */
export const FilterApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isAiring] Optional. Is item airing.
         * @param {boolean} [isMovie] Optional. Is item movie.
         * @param {boolean} [isSports] Optional. Is item sports.
         * @param {boolean} [isKids] Optional. Is item kids.
         * @param {boolean} [isNews] Optional. Is item news.
         * @param {boolean} [isSeries] Optional. Is item series.
         * @param {boolean} [recursive] Optional. Search recursive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueryFilters(userId?: string, parentId?: string, includeItemTypes?: string, isAiring?: boolean, isMovie?: boolean, isSports?: boolean, isKids?: boolean, isNews?: boolean, isSeries?: boolean, recursive?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryFilters>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).getQueryFilters(userId, parentId, includeItemTypes, isAiring, isMovie, isSports, isKids, isNews, isSeries, recursive, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets legacy query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Parent id.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueryFiltersLegacy(userId?: string, parentId?: string, includeItemTypes?: string, mediaTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryFiltersLegacy>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).getQueryFiltersLegacy(userId, parentId, includeItemTypes, mediaTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FilterApi - factory interface
 * @export
 */
export const FilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isAiring] Optional. Is item airing.
         * @param {boolean} [isMovie] Optional. Is item movie.
         * @param {boolean} [isSports] Optional. Is item sports.
         * @param {boolean} [isKids] Optional. Is item kids.
         * @param {boolean} [isNews] Optional. Is item news.
         * @param {boolean} [isSeries] Optional. Is item series.
         * @param {boolean} [recursive] Optional. Search recursive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFilters(userId?: string, parentId?: string, includeItemTypes?: string, isAiring?: boolean, isMovie?: boolean, isSports?: boolean, isKids?: boolean, isNews?: boolean, isSeries?: boolean, recursive?: boolean, options?: any): AxiosPromise<QueryFilters> {
            return FilterApiFp(configuration).getQueryFilters(userId, parentId, includeItemTypes, isAiring, isMovie, isSports, isKids, isNews, isSeries, recursive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets legacy query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Parent id.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFiltersLegacy(userId?: string, parentId?: string, includeItemTypes?: string, mediaTypes?: string, options?: any): AxiosPromise<QueryFiltersLegacy> {
            return FilterApiFp(configuration).getQueryFiltersLegacy(userId, parentId, includeItemTypes, mediaTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilterApi - object-oriented interface
 * @export
 * @class FilterApi
 * @extends {BaseAPI}
 */
export class FilterApi extends BaseAPI {
    /**
     * 
     * @summary Gets query filters.
     * @param {string} [userId] Optional. User id.
     * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
     * @param {boolean} [isAiring] Optional. Is item airing.
     * @param {boolean} [isMovie] Optional. Is item movie.
     * @param {boolean} [isSports] Optional. Is item sports.
     * @param {boolean} [isKids] Optional. Is item kids.
     * @param {boolean} [isNews] Optional. Is item news.
     * @param {boolean} [isSeries] Optional. Is item series.
     * @param {boolean} [recursive] Optional. Search recursive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public getQueryFilters(userId?: string, parentId?: string, includeItemTypes?: string, isAiring?: boolean, isMovie?: boolean, isSports?: boolean, isKids?: boolean, isNews?: boolean, isSeries?: boolean, recursive?: boolean, options?: any) {
        return FilterApiFp(this.configuration).getQueryFilters(userId, parentId, includeItemTypes, isAiring, isMovie, isSports, isKids, isNews, isSeries, recursive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets legacy query filters.
     * @param {string} [userId] Optional. User id.
     * @param {string} [parentId] Optional. Parent id.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
     * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public getQueryFiltersLegacy(userId?: string, parentId?: string, includeItemTypes?: string, mediaTypes?: string, options?: any) {
        return FilterApiFp(this.configuration).getQueryFiltersLegacy(userId, parentId, includeItemTypes, mediaTypes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GenresApi - axios parameter creator
 * @export
 */
export const GenresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenre: async (genreName: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'genreName' is not null or undefined
            if (genreName === null || genreName === undefined) {
                throw new RequiredError('genreName','Required parameter genreName was null or undefined when calling getGenre.');
            }
            const localVarPath = `/Genres/{genreName}`
                .replace(`{${"genreName"}}`, encodeURIComponent(String(genreName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all genres from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenres: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Genres`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenresApi - functional programming interface
 * @export
 */
export const GenresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenre(genreName: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await GenresApiAxiosParamCreator(configuration).getGenre(genreName, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all genres from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenres(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await GenresApiAxiosParamCreator(configuration).getGenres(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GenresApi - factory interface
 * @export
 */
export const GenresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenre(genreName: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return GenresApiFp(configuration).getGenre(genreName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all genres from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenres(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return GenresApiFp(configuration).getGenres(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenresApi - object-oriented interface
 * @export
 * @class GenresApi
 * @extends {BaseAPI}
 */
export class GenresApi extends BaseAPI {
    /**
     * 
     * @summary Gets a genre, by name.
     * @param {string} genreName The genre name.
     * @param {string} [userId] The user id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenresApi
     */
    public getGenre(genreName: string, userId?: string, options?: any) {
        return GenresApiFp(this.configuration).getGenre(genreName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all genres from a given item, folder, or the entire library.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [searchTerm] The search term.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
     * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
     * @param {boolean} [enableUserData] Optional, include user data.
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
     * @param {string} [userId] User id.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {boolean} [enableImages] Optional, include image information in output.
     * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenresApi
     */
    public getGenres(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return GenresApiFp(this.configuration).getGenres(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HlsSegmentApi - axios parameter creator
 * @export
 */
export const HlsSegmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyAac: async (itemId: string, segmentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsAudioSegmentLegacyAac.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsAudioSegmentLegacyAac.');
            }
            const localVarPath = `/Audio/{itemId}/hls/{segmentId}/stream.aac`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyMp3: async (itemId: string, segmentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsAudioSegmentLegacyMp3.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsAudioSegmentLegacyMp3.');
            }
            const localVarPath = `/Audio/{itemId}/hls/{segmentId}/stream.mp3`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a hls video playlist.
         * @param {string} itemId The video id.
         * @param {string} playlistId The playlist id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsPlaylistLegacy: async (itemId: string, playlistId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsPlaylistLegacy.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsPlaylistLegacy.');
            }
            const localVarPath = `/Videos/{itemId}/hls/{playlistId}/stream.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a hls video segment.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {string} segmentId The segment id.
         * @param {string} segmentContainer The segment container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegmentLegacy: async (itemId: string, playlistId: string, segmentId: string, segmentContainer: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            // verify required parameter 'segmentContainer' is not null or undefined
            if (segmentContainer === null || segmentContainer === undefined) {
                throw new RequiredError('segmentContainer','Required parameter segmentContainer was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            const localVarPath = `/Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)))
                .replace(`{${"segmentContainer"}}`, encodeURIComponent(String(segmentContainer)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stops an active encoding.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEncodingProcess: async (deviceId?: string, playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Videos/ActiveEncodings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HlsSegmentApi - functional programming interface
 * @export
 */
export const HlsSegmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsAudioSegmentLegacyAac(itemId: string, segmentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsAudioSegmentLegacyAac(itemId, segmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsAudioSegmentLegacyMp3(itemId: string, segmentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsAudioSegmentLegacyMp3(itemId, segmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a hls video playlist.
         * @param {string} itemId The video id.
         * @param {string} playlistId The playlist id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsPlaylistLegacy(itemId: string, playlistId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsPlaylistLegacy(itemId, playlistId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a hls video segment.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {string} segmentId The segment id.
         * @param {string} segmentContainer The segment container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsVideoSegmentLegacy(itemId: string, playlistId: string, segmentId: string, segmentContainer: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsVideoSegmentLegacy(itemId, playlistId, segmentId, segmentContainer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Stops an active encoding.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopEncodingProcess(deviceId?: string, playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).stopEncodingProcess(deviceId, playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HlsSegmentApi - factory interface
 * @export
 */
export const HlsSegmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyAac(itemId: string, segmentId: string, options?: any): AxiosPromise<any> {
            return HlsSegmentApiFp(configuration).getHlsAudioSegmentLegacyAac(itemId, segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyMp3(itemId: string, segmentId: string, options?: any): AxiosPromise<any> {
            return HlsSegmentApiFp(configuration).getHlsAudioSegmentLegacyMp3(itemId, segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a hls video playlist.
         * @param {string} itemId The video id.
         * @param {string} playlistId The playlist id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsPlaylistLegacy(itemId: string, playlistId: string, options?: any): AxiosPromise<any> {
            return HlsSegmentApiFp(configuration).getHlsPlaylistLegacy(itemId, playlistId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a hls video segment.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {string} segmentId The segment id.
         * @param {string} segmentContainer The segment container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegmentLegacy(itemId: string, playlistId: string, segmentId: string, segmentContainer: string, options?: any): AxiosPromise<any> {
            return HlsSegmentApiFp(configuration).getHlsVideoSegmentLegacy(itemId, playlistId, segmentId, segmentContainer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stops an active encoding.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEncodingProcess(deviceId?: string, playSessionId?: string, options?: any): AxiosPromise<void> {
            return HlsSegmentApiFp(configuration).stopEncodingProcess(deviceId, playSessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HlsSegmentApi - object-oriented interface
 * @export
 * @class HlsSegmentApi
 * @extends {BaseAPI}
 */
export class HlsSegmentApi extends BaseAPI {
    /**
     * 
     * @summary Gets the specified audio segment for an audio item.
     * @param {string} itemId The item id.
     * @param {string} segmentId The segment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsAudioSegmentLegacyAac(itemId: string, segmentId: string, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsAudioSegmentLegacyAac(itemId, segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the specified audio segment for an audio item.
     * @param {string} itemId The item id.
     * @param {string} segmentId The segment id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsAudioSegmentLegacyMp3(itemId: string, segmentId: string, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsAudioSegmentLegacyMp3(itemId, segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a hls video playlist.
     * @param {string} itemId The video id.
     * @param {string} playlistId The playlist id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsPlaylistLegacy(itemId: string, playlistId: string, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsPlaylistLegacy(itemId, playlistId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a hls video segment.
     * @param {string} itemId The item id.
     * @param {string} playlistId The playlist id.
     * @param {string} segmentId The segment id.
     * @param {string} segmentContainer The segment container.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsVideoSegmentLegacy(itemId: string, playlistId: string, segmentId: string, segmentContainer: string, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsVideoSegmentLegacy(itemId, playlistId, segmentId, segmentContainer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stops an active encoding.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [playSessionId] The play session id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public stopEncodingProcess(deviceId?: string, playSessionId?: string, options?: any) {
        return HlsSegmentApiFp(this.configuration).stopEncodingProcess(deviceId, playSessionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling deleteItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage2: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling deleteItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage: async (userId: string, imageType: ImageType, index: number, itemType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteUserImage.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteUserImage.');
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new RequiredError('itemType','Required parameter itemType was null or undefined when calling deleteUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{itemType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"itemType"}}`, encodeURIComponent(String(itemType)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage2: async (userId: string, imageType: ImageType, index: number, itemType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteUserImage2.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteUserImage2.');
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new RequiredError('itemType','Required parameter itemType was null or undefined when calling deleteUserImage2.');
            }
            const localVarPath = `/Users/{userId}/Images/{itemType}/{index}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"itemType"}}`, encodeURIComponent(String(itemType)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getArtistImage.');
            }
            const localVarPath = `/Artists/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getGenreImage.');
            }
            const localVarPath = `/Genres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage: async (itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2: async (itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2_1: async (itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getItemImage2_1.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get item image infos.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImageInfos: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImageInfos.');
            }
            const localVarPath = `/Items/{itemId}/Images`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenreImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getMusicGenreImage.');
            }
            const localVarPath = `/MusicGenres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getPersonImage.');
            }
            const localVarPath = `/Persons/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudioImage: async (name: string, imageType: ImageType, tag: string, format: string, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getStudioImage.');
            }
            const localVarPath = `/Studios/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserImage: async (userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getUserImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headArtistImage.');
            }
            const localVarPath = `/Artists/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenreImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headGenreImage.');
            }
            const localVarPath = `/Genres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage: async (itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2: async (itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2_2: async (itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headItemImage2_2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicGenreImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headMusicGenreImage.');
            }
            const localVarPath = `/MusicGenres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headPersonImage.');
            }
            const localVarPath = `/Persons/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudioImage: async (name: string, imageType: ImageType, tag: string, format: string, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headStudioImage.');
            }
            const localVarPath = `/Studios/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUserImage: async (userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling headUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headUserImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage: async (userId: string, imageType: ImageType, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling postUserImage.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling postUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage2: async (userId: string, imageType: ImageType, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postUserImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling postUserImage2.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling postUserImage2.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}/{index}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling setItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling setItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling setItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage2: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling setItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling setItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling setItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the index for an item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Old image index.
         * @param {number} [newIndex] New image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemImageIndex: async (itemId: string, imageType: ImageType, imageIndex: number, newIndex?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItemImageIndex.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling updateItemImageIndex.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling updateItemImageIndex.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}/Index`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (newIndex !== undefined) {
                localVarQueryParameter['newIndex'] = newIndex;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteItemImage(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteItemImage2(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserImage(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteUserImage(userId, imageType, index, itemType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserImage2(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteUserImage2(userId, imageType, index, itemType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getArtistImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImage(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImage(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImage2(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImage2(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImage2_1(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImage2_1(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get item image infos.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImageInfos(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageInfo>>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImageInfos(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getMusicGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getPersonImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudioImage(name: string, imageType: ImageType, tag: string, format: string, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getStudioImage(name, imageType, tag, format, imageIndex, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headArtistImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headArtistImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemImage(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headItemImage(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemImage2(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headItemImage2(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemImage2_2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headItemImage2_2(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMusicGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headMusicGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headPersonImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headPersonImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headStudioImage(name: string, imageType: ImageType, tag: string, format: string, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headStudioImage(name, imageType, tag, format, imageIndex, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserImage(userId: string, imageType: ImageType, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).postUserImage(userId, imageType, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserImage2(userId: string, imageType: ImageType, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).postUserImage2(userId, imageType, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).setItemImage(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).setItemImage2(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the index for an item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Old image index.
         * @param {number} [newIndex] New image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemImageIndex(itemId: string, imageType: ImageType, imageIndex: number, newIndex?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).updateItemImageIndex(itemId, imageType, imageIndex, newIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteItemImage(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteItemImage2(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteUserImage(userId, imageType, index, itemType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage2(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteUserImage2(userId, imageType, index, itemType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getArtistImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getItemImage(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getItemImage2(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2_1(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getItemImage2_1(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get item image infos.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImageInfos(itemId: string, options?: any): AxiosPromise<Array<ImageInfo>> {
            return ImageApiFp(configuration).getItemImageInfos(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getMusicGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getPersonImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudioImage(name: string, imageType: ImageType, tag: string, format: string, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getStudioImage(name, imageType, tag, format, imageIndex, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headArtistImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headItemImage(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headItemImage2(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2_2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headItemImage2_2(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headMusicGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headPersonImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudioImage(name: string, imageType: ImageType, tag: string, format: string, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headStudioImage(name, imageType, tag, format, imageIndex, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage(userId: string, imageType: ImageType, index: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).postUserImage(userId, imageType, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage2(userId: string, imageType: ImageType, index: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).postUserImage2(userId, imageType, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).setItemImage(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).setItemImage2(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the index for an item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Old image index.
         * @param {number} [newIndex] New image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemImageIndex(itemId: string, imageType: ImageType, imageIndex: number, newIndex?: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).updateItemImageIndex(itemId, imageType, imageIndex, newIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * 
     * @summary Delete an item\'s image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex The image index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any) {
        return ImageApiFp(this.configuration).deleteItemImage(itemId, imageType, imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an item\'s image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex The image index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any) {
        return ImageApiFp(this.configuration).deleteItemImage2(itemId, imageType, imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the user\'s image.
     * @param {string} userId User Id.
     * @param {ImageType} imageType (Unused) Image type.
     * @param {number} index (Unused) Image index.
     * @param {string} itemType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteUserImage(userId: string, imageType: ImageType, index: number, itemType: string, options?: any) {
        return ImageApiFp(this.configuration).deleteUserImage(userId, imageType, index, itemType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the user\'s image.
     * @param {string} userId User Id.
     * @param {ImageType} imageType (Unused) Image type.
     * @param {number} index (Unused) Image index.
     * @param {string} itemType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteUserImage2(userId: string, imageType: ImageType, index: number, itemType: string, options?: any) {
        return ImageApiFp(this.configuration).deleteUserImage2(userId, imageType, index, itemType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get artist image by name.
     * @param {string} name Artist name.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getArtistImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).getArtistImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get genre image by name.
     * @param {string} name Genre name.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).getGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImage(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).getItemImage(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImage2(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).getItemImage2(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} maxWidth The maximum image width to return.
     * @param {number} maxHeight The maximum image height to return.
     * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} format Determines the output format of the image - original,gif,jpg,png.
     * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
     * @param {number} unplayedCount Optional. Unplayed count overlay to render.
     * @param {number} imageIndex Image index.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImage2_1(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).getItemImage2_1(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get item image infos.
     * @param {string} itemId Item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImageInfos(itemId: string, options?: any) {
        return ImageApiFp(this.configuration).getItemImageInfos(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get music genre image by name.
     * @param {string} name Music genre name.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getMusicGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).getMusicGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get person image by name.
     * @param {string} name Person name.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getPersonImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).getPersonImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get studio image by name.
     * @param {string} name Studio name.
     * @param {ImageType} imageType Image type.
     * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} format Determines the output format of the image - original,gif,jpg,png.
     * @param {number} imageIndex Image index.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getStudioImage(name: string, imageType: ImageType, tag: string, format: string, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).getStudioImage(name, imageType, tag, format, imageIndex, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user profile image.
     * @param {string} userId User id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).getUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get artist image by name.
     * @param {string} name Artist name.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headArtistImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).headArtistImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get genre image by name.
     * @param {string} name Genre name.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).headGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headItemImage(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).headItemImage(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headItemImage2(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).headItemImage2(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} maxWidth The maximum image width to return.
     * @param {number} maxHeight The maximum image height to return.
     * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} format Determines the output format of the image - original,gif,jpg,png.
     * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
     * @param {number} unplayedCount Optional. Unplayed count overlay to render.
     * @param {number} imageIndex Image index.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headItemImage2_2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).headItemImage2_2(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get music genre image by name.
     * @param {string} name Music genre name.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headMusicGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).headMusicGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get person image by name.
     * @param {string} name Person name.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headPersonImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).headPersonImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get studio image by name.
     * @param {string} name Studio name.
     * @param {ImageType} imageType Image type.
     * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} format Determines the output format of the image - original,gif,jpg,png.
     * @param {number} imageIndex Image index.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headStudioImage(name: string, imageType: ImageType, tag: string, format: string, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).headStudioImage(name, imageType, tag, format, imageIndex, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user profile image.
     * @param {string} userId User id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Image index.
     * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param {string} [format] Determines the output format of the image - original,gif,jpg,png.
     * @param {number} [maxWidth] The maximum image width to return.
     * @param {number} [maxHeight] The maximum image height to return.
     * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
     * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
     * @param {number} [width] The fixed image width to return.
     * @param {number} [height] The fixed image height to return.
     * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
     * @param {number} [blur] Optional. Blur image.
     * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
     * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any) {
        return ImageApiFp(this.configuration).headUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the user image.
     * @param {string} userId User Id.
     * @param {ImageType} imageType (Unused) Image type.
     * @param {number} index (Unused) Image index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postUserImage(userId: string, imageType: ImageType, index: number, options?: any) {
        return ImageApiFp(this.configuration).postUserImage(userId, imageType, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the user image.
     * @param {string} userId User Id.
     * @param {ImageType} imageType (Unused) Image type.
     * @param {number} index (Unused) Image index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postUserImage2(userId: string, imageType: ImageType, index: number, options?: any) {
        return ImageApiFp(this.configuration).postUserImage2(userId, imageType, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set item image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex (Unused) Image index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public setItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any) {
        return ImageApiFp(this.configuration).setItemImage(itemId, imageType, imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set item image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex (Unused) Image index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public setItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any) {
        return ImageApiFp(this.configuration).setItemImage2(itemId, imageType, imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the index for an item image.
     * @param {string} itemId Item id.
     * @param {ImageType} imageType Image type.
     * @param {number} imageIndex Old image index.
     * @param {number} [newIndex] New image index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public updateItemImageIndex(itemId: string, imageType: ImageType, imageIndex: number, newIndex?: number, options?: any) {
        return ImageApiFp(this.configuration).updateItemImageIndex(itemId, imageType, imageIndex, newIndex, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageByNameApi - axios parameter creator
 * @export
 */
export const ImageByNameApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get General Image.
         * @param {string} name The name of the image.
         * @param {string} type Image Type (primary, backdrop, logo, etc).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImage: async (name: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getGeneralImage.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getGeneralImage.');
            }
            const localVarPath = `/Images/General/{name}/{type}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Images/General`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get media info image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImage: async (theme: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            if (theme === null || theme === undefined) {
                throw new RequiredError('theme','Required parameter theme was null or undefined when calling getMediaInfoImage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMediaInfoImage.');
            }
            const localVarPath = `/Images/MediaInfo/{theme}/{name}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all media info images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Images/MediaInfo`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get rating image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImage: async (theme: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            if (theme === null || theme === undefined) {
                throw new RequiredError('theme','Required parameter theme was null or undefined when calling getRatingImage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRatingImage.');
            }
            const localVarPath = `/Images/Ratings/{theme}/{name}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Images/Ratings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageByNameApi - functional programming interface
 * @export
 */
export const ImageByNameApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get General Image.
         * @param {string} name The name of the image.
         * @param {string} type Image Type (primary, backdrop, logo, etc).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralImage(name: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getGeneralImage(name, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralImages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageByNameInfo>>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getGeneralImages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get media info image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaInfoImage(theme: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getMediaInfoImage(theme, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all media info images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaInfoImages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageByNameInfo>>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getMediaInfoImages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get rating image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatingImage(theme: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getRatingImage(theme, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatingImages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageByNameInfo>>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getRatingImages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageByNameApi - factory interface
 * @export
 */
export const ImageByNameApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get General Image.
         * @param {string} name The name of the image.
         * @param {string} type Image Type (primary, backdrop, logo, etc).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImage(name: string, type: string, options?: any): AxiosPromise<any> {
            return ImageByNameApiFp(configuration).getGeneralImage(name, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImages(options?: any): AxiosPromise<Array<ImageByNameInfo>> {
            return ImageByNameApiFp(configuration).getGeneralImages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get media info image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImage(theme: string, name: string, options?: any): AxiosPromise<any> {
            return ImageByNameApiFp(configuration).getMediaInfoImage(theme, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all media info images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImages(options?: any): AxiosPromise<Array<ImageByNameInfo>> {
            return ImageByNameApiFp(configuration).getMediaInfoImages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get rating image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImage(theme: string, name: string, options?: any): AxiosPromise<any> {
            return ImageByNameApiFp(configuration).getRatingImage(theme, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImages(options?: any): AxiosPromise<Array<ImageByNameInfo>> {
            return ImageByNameApiFp(configuration).getRatingImages(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageByNameApi - object-oriented interface
 * @export
 * @class ImageByNameApi
 * @extends {BaseAPI}
 */
export class ImageByNameApi extends BaseAPI {
    /**
     * 
     * @summary Get General Image.
     * @param {string} name The name of the image.
     * @param {string} type Image Type (primary, backdrop, logo, etc).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getGeneralImage(name: string, type: string, options?: any) {
        return ImageByNameApiFp(this.configuration).getGeneralImage(name, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all general images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getGeneralImages(options?: any) {
        return ImageByNameApiFp(this.configuration).getGeneralImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get media info image.
     * @param {string} theme The theme to get the image from.
     * @param {string} name The name of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getMediaInfoImage(theme: string, name: string, options?: any) {
        return ImageByNameApiFp(this.configuration).getMediaInfoImage(theme, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all media info images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getMediaInfoImages(options?: any) {
        return ImageByNameApiFp(this.configuration).getMediaInfoImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get rating image.
     * @param {string} theme The theme to get the image from.
     * @param {string} name The name of the image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getRatingImage(theme: string, name: string, options?: any) {
        return ImageByNameApiFp(this.configuration).getRatingImage(theme, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all general images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getRatingImages(options?: any) {
        return ImageByNameApiFp(this.configuration).getRatingImages(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InstantMixApi - axios parameter creator
 * @export
 */
export const InstantMixApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromAlbum: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromAlbum.');
            }
            const localVarPath = `/Albums/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromArtists: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromArtists.');
            }
            const localVarPath = `/Artists/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromItem: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromItem.');
            }
            const localVarPath = `/Items/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} name The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenre: async (name: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getInstantMixFromMusicGenre.');
            }
            const localVarPath = `/MusicGenres/{name}/InstantMix`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenres: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromMusicGenres.');
            }
            const localVarPath = `/MusicGenres/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromPlaylist: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromPlaylist.');
            }
            const localVarPath = `/Playlists/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromSong: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromSong.');
            }
            const localVarPath = `/Songs/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstantMixApi - functional programming interface
 * @export
 */
export const InstantMixApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromAlbum(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromAlbum(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromArtists(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromArtists(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromItem(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromItem(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} name The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromMusicGenre(name: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromMusicGenre(name, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromMusicGenres(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromMusicGenres(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromPlaylist(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromPlaylist(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromSong(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromSong(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InstantMixApi - factory interface
 * @export
 */
export const InstantMixApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromAlbum(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromAlbum(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromArtists(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromArtists(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromItem(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromItem(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} name The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenre(name: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromMusicGenre(name, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenres(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromMusicGenres(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromPlaylist(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromPlaylist(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromSong(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromSong(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstantMixApi - object-oriented interface
 * @export
 * @class InstantMixApi
 * @extends {BaseAPI}
 */
export class InstantMixApi extends BaseAPI {
    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {string} id The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromAlbum(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromAlbum(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {string} id The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromArtists(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromArtists(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {string} id The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromItem(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromItem(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {string} name The genre name.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromMusicGenre(name: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromMusicGenre(name, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {string} id The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromMusicGenres(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromMusicGenres(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {string} id The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromPlaylist(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromPlaylist(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {string} id The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromSong(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromSong(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemLookupApi - axios parameter creator
 * @export
 */
export const ItemLookupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Applies search criteria to an item and refreshes metadata.
         * @param {string} itemId Item id.
         * @param {RemoteSearchResult} remoteSearchResult The remote search result.
         * @param {boolean} [replaceAllImages] Optional. Whether or not to replace all images. Default: True.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applySearchCriteria: async (itemId: string, remoteSearchResult: RemoteSearchResult, replaceAllImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling applySearchCriteria.');
            }
            // verify required parameter 'remoteSearchResult' is not null or undefined
            if (remoteSearchResult === null || remoteSearchResult === undefined) {
                throw new RequiredError('remoteSearchResult','Required parameter remoteSearchResult was null or undefined when calling applySearchCriteria.');
            }
            const localVarPath = `/Items/RemoteSearch/Apply/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (replaceAllImages !== undefined) {
                localVarQueryParameter['replaceAllImages'] = replaceAllImages;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof remoteSearchResult !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(remoteSearchResult !== undefined ? remoteSearchResult : {}) : (remoteSearchResult || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get book remote search.
         * @param {BookInfoRemoteSearchQuery} bookInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookRemoteSearchResults: async (bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookInfoRemoteSearchQuery' is not null or undefined
            if (bookInfoRemoteSearchQuery === null || bookInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('bookInfoRemoteSearchQuery','Required parameter bookInfoRemoteSearchQuery was null or undefined when calling getBookRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Book`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bookInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bookInfoRemoteSearchQuery !== undefined ? bookInfoRemoteSearchQuery : {}) : (bookInfoRemoteSearchQuery || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get box set remote search.
         * @param {BoxSetInfoRemoteSearchQuery} boxSetInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoxSetRemoteSearchResults: async (boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boxSetInfoRemoteSearchQuery' is not null or undefined
            if (boxSetInfoRemoteSearchQuery === null || boxSetInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('boxSetInfoRemoteSearchQuery','Required parameter boxSetInfoRemoteSearchQuery was null or undefined when calling getBoxSetRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/BoxSet`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof boxSetInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(boxSetInfoRemoteSearchQuery !== undefined ? boxSetInfoRemoteSearchQuery : {}) : (boxSetInfoRemoteSearchQuery || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the item\'s external id info.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalIdInfos: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getExternalIdInfos.');
            }
            const localVarPath = `/Items/{itemId}/ExternalIdInfos`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get movie remote search.
         * @param {MovieInfoRemoteSearchQuery} movieInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRemoteSearchResults: async (movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'movieInfoRemoteSearchQuery' is not null or undefined
            if (movieInfoRemoteSearchQuery === null || movieInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('movieInfoRemoteSearchQuery','Required parameter movieInfoRemoteSearchQuery was null or undefined when calling getMovieRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Movie`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof movieInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(movieInfoRemoteSearchQuery !== undefined ? movieInfoRemoteSearchQuery : {}) : (movieInfoRemoteSearchQuery || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get music album remote search.
         * @param {AlbumInfoRemoteSearchQuery} albumInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicAlbumRemoteSearchResults: async (albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumInfoRemoteSearchQuery' is not null or undefined
            if (albumInfoRemoteSearchQuery === null || albumInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('albumInfoRemoteSearchQuery','Required parameter albumInfoRemoteSearchQuery was null or undefined when calling getMusicAlbumRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/MusicAlbum`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof albumInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(albumInfoRemoteSearchQuery !== undefined ? albumInfoRemoteSearchQuery : {}) : (albumInfoRemoteSearchQuery || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get music artist remote search.
         * @param {ArtistInfoRemoteSearchQuery} artistInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicArtistRemoteSearchResults: async (artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artistInfoRemoteSearchQuery' is not null or undefined
            if (artistInfoRemoteSearchQuery === null || artistInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('artistInfoRemoteSearchQuery','Required parameter artistInfoRemoteSearchQuery was null or undefined when calling getMusicArtistRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/MusicArtist`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof artistInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(artistInfoRemoteSearchQuery !== undefined ? artistInfoRemoteSearchQuery : {}) : (artistInfoRemoteSearchQuery || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get music video remote search.
         * @param {MusicVideoInfoRemoteSearchQuery} musicVideoInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicVideoRemoteSearchResults: async (musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'musicVideoInfoRemoteSearchQuery' is not null or undefined
            if (musicVideoInfoRemoteSearchQuery === null || musicVideoInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('musicVideoInfoRemoteSearchQuery','Required parameter musicVideoInfoRemoteSearchQuery was null or undefined when calling getMusicVideoRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/MusicVideo`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof musicVideoInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(musicVideoInfoRemoteSearchQuery !== undefined ? musicVideoInfoRemoteSearchQuery : {}) : (musicVideoInfoRemoteSearchQuery || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get person remote search.
         * @param {PersonLookupInfoRemoteSearchQuery} personLookupInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonRemoteSearchResults: async (personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personLookupInfoRemoteSearchQuery' is not null or undefined
            if (personLookupInfoRemoteSearchQuery === null || personLookupInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('personLookupInfoRemoteSearchQuery','Required parameter personLookupInfoRemoteSearchQuery was null or undefined when calling getPersonRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Person`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof personLookupInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(personLookupInfoRemoteSearchQuery !== undefined ? personLookupInfoRemoteSearchQuery : {}) : (personLookupInfoRemoteSearchQuery || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {string} providerName The provider name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSearchImage: async (imageUrl: string, providerName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUrl' is not null or undefined
            if (imageUrl === null || imageUrl === undefined) {
                throw new RequiredError('imageUrl','Required parameter imageUrl was null or undefined when calling getRemoteSearchImage.');
            }
            // verify required parameter 'providerName' is not null or undefined
            if (providerName === null || providerName === undefined) {
                throw new RequiredError('providerName','Required parameter providerName was null or undefined when calling getRemoteSearchImage.');
            }
            const localVarPath = `/Items/RemoteSearch/Image`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }

            if (providerName !== undefined) {
                localVarQueryParameter['providerName'] = providerName;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get series remote search.
         * @param {SeriesInfoRemoteSearchQuery} seriesInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesRemoteSearchResults: async (seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'seriesInfoRemoteSearchQuery' is not null or undefined
            if (seriesInfoRemoteSearchQuery === null || seriesInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('seriesInfoRemoteSearchQuery','Required parameter seriesInfoRemoteSearchQuery was null or undefined when calling getSeriesRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Series`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof seriesInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(seriesInfoRemoteSearchQuery !== undefined ? seriesInfoRemoteSearchQuery : {}) : (seriesInfoRemoteSearchQuery || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get trailer remote search.
         * @param {TrailerInfoRemoteSearchQuery} trailerInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailerRemoteSearchResults: async (trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trailerInfoRemoteSearchQuery' is not null or undefined
            if (trailerInfoRemoteSearchQuery === null || trailerInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('trailerInfoRemoteSearchQuery','Required parameter trailerInfoRemoteSearchQuery was null or undefined when calling getTrailerRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Trailer`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof trailerInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(trailerInfoRemoteSearchQuery !== undefined ? trailerInfoRemoteSearchQuery : {}) : (trailerInfoRemoteSearchQuery || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemLookupApi - functional programming interface
 * @export
 */
export const ItemLookupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Applies search criteria to an item and refreshes metadata.
         * @param {string} itemId Item id.
         * @param {RemoteSearchResult} remoteSearchResult The remote search result.
         * @param {boolean} [replaceAllImages] Optional. Whether or not to replace all images. Default: True.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applySearchCriteria(itemId: string, remoteSearchResult: RemoteSearchResult, replaceAllImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).applySearchCriteria(itemId, remoteSearchResult, replaceAllImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get book remote search.
         * @param {BookInfoRemoteSearchQuery} bookInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookRemoteSearchResults(bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getBookRemoteSearchResults(bookInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get box set remote search.
         * @param {BoxSetInfoRemoteSearchQuery} boxSetInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the item\'s external id info.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalIdInfos(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalIdInfo>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getExternalIdInfos(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get movie remote search.
         * @param {MovieInfoRemoteSearchQuery} movieInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMovieRemoteSearchResults(movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMovieRemoteSearchResults(movieInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get music album remote search.
         * @param {AlbumInfoRemoteSearchQuery} albumInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get music artist remote search.
         * @param {ArtistInfoRemoteSearchQuery} artistInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get music video remote search.
         * @param {MusicVideoInfoRemoteSearchQuery} musicVideoInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get person remote search.
         * @param {PersonLookupInfoRemoteSearchQuery} personLookupInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {string} providerName The provider name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteSearchImage(imageUrl: string, providerName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getRemoteSearchImage(imageUrl, providerName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get series remote search.
         * @param {SeriesInfoRemoteSearchQuery} seriesInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get trailer remote search.
         * @param {TrailerInfoRemoteSearchQuery} trailerInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemLookupApi - factory interface
 * @export
 */
export const ItemLookupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Applies search criteria to an item and refreshes metadata.
         * @param {string} itemId Item id.
         * @param {RemoteSearchResult} remoteSearchResult The remote search result.
         * @param {boolean} [replaceAllImages] Optional. Whether or not to replace all images. Default: True.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applySearchCriteria(itemId: string, remoteSearchResult: RemoteSearchResult, replaceAllImages?: boolean, options?: any): AxiosPromise<void> {
            return ItemLookupApiFp(configuration).applySearchCriteria(itemId, remoteSearchResult, replaceAllImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get book remote search.
         * @param {BookInfoRemoteSearchQuery} bookInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookRemoteSearchResults(bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getBookRemoteSearchResults(bookInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get box set remote search.
         * @param {BoxSetInfoRemoteSearchQuery} boxSetInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the item\'s external id info.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalIdInfos(itemId: string, options?: any): AxiosPromise<Array<ExternalIdInfo>> {
            return ItemLookupApiFp(configuration).getExternalIdInfos(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get movie remote search.
         * @param {MovieInfoRemoteSearchQuery} movieInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRemoteSearchResults(movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMovieRemoteSearchResults(movieInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get music album remote search.
         * @param {AlbumInfoRemoteSearchQuery} albumInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get music artist remote search.
         * @param {ArtistInfoRemoteSearchQuery} artistInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get music video remote search.
         * @param {MusicVideoInfoRemoteSearchQuery} musicVideoInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get person remote search.
         * @param {PersonLookupInfoRemoteSearchQuery} personLookupInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {string} providerName The provider name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSearchImage(imageUrl: string, providerName: string, options?: any): AxiosPromise<any> {
            return ItemLookupApiFp(configuration).getRemoteSearchImage(imageUrl, providerName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get series remote search.
         * @param {SeriesInfoRemoteSearchQuery} seriesInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get trailer remote search.
         * @param {TrailerInfoRemoteSearchQuery} trailerInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemLookupApi - object-oriented interface
 * @export
 * @class ItemLookupApi
 * @extends {BaseAPI}
 */
export class ItemLookupApi extends BaseAPI {
    /**
     * 
     * @summary Applies search criteria to an item and refreshes metadata.
     * @param {string} itemId Item id.
     * @param {RemoteSearchResult} remoteSearchResult The remote search result.
     * @param {boolean} [replaceAllImages] Optional. Whether or not to replace all images. Default: True.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public applySearchCriteria(itemId: string, remoteSearchResult: RemoteSearchResult, replaceAllImages?: boolean, options?: any) {
        return ItemLookupApiFp(this.configuration).applySearchCriteria(itemId, remoteSearchResult, replaceAllImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get book remote search.
     * @param {BookInfoRemoteSearchQuery} bookInfoRemoteSearchQuery Remote search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getBookRemoteSearchResults(bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery, options?: any) {
        return ItemLookupApiFp(this.configuration).getBookRemoteSearchResults(bookInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get box set remote search.
     * @param {BoxSetInfoRemoteSearchQuery} boxSetInfoRemoteSearchQuery Remote search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery, options?: any) {
        return ItemLookupApiFp(this.configuration).getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the item\'s external id info.
     * @param {string} itemId Item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getExternalIdInfos(itemId: string, options?: any) {
        return ItemLookupApiFp(this.configuration).getExternalIdInfos(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get movie remote search.
     * @param {MovieInfoRemoteSearchQuery} movieInfoRemoteSearchQuery Remote search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMovieRemoteSearchResults(movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery, options?: any) {
        return ItemLookupApiFp(this.configuration).getMovieRemoteSearchResults(movieInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get music album remote search.
     * @param {AlbumInfoRemoteSearchQuery} albumInfoRemoteSearchQuery Remote search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery, options?: any) {
        return ItemLookupApiFp(this.configuration).getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get music artist remote search.
     * @param {ArtistInfoRemoteSearchQuery} artistInfoRemoteSearchQuery Remote search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery, options?: any) {
        return ItemLookupApiFp(this.configuration).getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get music video remote search.
     * @param {MusicVideoInfoRemoteSearchQuery} musicVideoInfoRemoteSearchQuery Remote search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery, options?: any) {
        return ItemLookupApiFp(this.configuration).getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get person remote search.
     * @param {PersonLookupInfoRemoteSearchQuery} personLookupInfoRemoteSearchQuery Remote search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery, options?: any) {
        return ItemLookupApiFp(this.configuration).getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a remote image.
     * @param {string} imageUrl The image url.
     * @param {string} providerName The provider name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getRemoteSearchImage(imageUrl: string, providerName: string, options?: any) {
        return ItemLookupApiFp(this.configuration).getRemoteSearchImage(imageUrl, providerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get series remote search.
     * @param {SeriesInfoRemoteSearchQuery} seriesInfoRemoteSearchQuery Remote search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery, options?: any) {
        return ItemLookupApiFp(this.configuration).getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get trailer remote search.
     * @param {TrailerInfoRemoteSearchQuery} trailerInfoRemoteSearchQuery Remote search query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery, options?: any) {
        return ItemLookupApiFp(this.configuration).getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemRefreshApi - axios parameter creator
 * @export
 */
export const ItemRefreshApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Refreshes metadata for an item.
         * @param {string} itemId Item id.
         * @param {MetadataRefreshMode} [metadataRefreshMode] (Optional) Specifies the metadata refresh mode.
         * @param {MetadataRefreshMode} [imageRefreshMode] (Optional) Specifies the image refresh mode.
         * @param {boolean} [replaceAllMetadata] (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
         * @param {boolean} [replaceAllImages] (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: async (itemId: string, metadataRefreshMode?: MetadataRefreshMode, imageRefreshMode?: MetadataRefreshMode, replaceAllMetadata?: boolean, replaceAllImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling post.');
            }
            const localVarPath = `/Items/{itemId}/Refresh`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (metadataRefreshMode !== undefined) {
                localVarQueryParameter['metadataRefreshMode'] = metadataRefreshMode;
            }

            if (imageRefreshMode !== undefined) {
                localVarQueryParameter['imageRefreshMode'] = imageRefreshMode;
            }

            if (replaceAllMetadata !== undefined) {
                localVarQueryParameter['replaceAllMetadata'] = replaceAllMetadata;
            }

            if (replaceAllImages !== undefined) {
                localVarQueryParameter['replaceAllImages'] = replaceAllImages;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemRefreshApi - functional programming interface
 * @export
 */
export const ItemRefreshApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Refreshes metadata for an item.
         * @param {string} itemId Item id.
         * @param {MetadataRefreshMode} [metadataRefreshMode] (Optional) Specifies the metadata refresh mode.
         * @param {MetadataRefreshMode} [imageRefreshMode] (Optional) Specifies the image refresh mode.
         * @param {boolean} [replaceAllMetadata] (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
         * @param {boolean} [replaceAllImages] (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async post(itemId: string, metadataRefreshMode?: MetadataRefreshMode, imageRefreshMode?: MetadataRefreshMode, replaceAllMetadata?: boolean, replaceAllImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemRefreshApiAxiosParamCreator(configuration).post(itemId, metadataRefreshMode, imageRefreshMode, replaceAllMetadata, replaceAllImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemRefreshApi - factory interface
 * @export
 */
export const ItemRefreshApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Refreshes metadata for an item.
         * @param {string} itemId Item id.
         * @param {MetadataRefreshMode} [metadataRefreshMode] (Optional) Specifies the metadata refresh mode.
         * @param {MetadataRefreshMode} [imageRefreshMode] (Optional) Specifies the image refresh mode.
         * @param {boolean} [replaceAllMetadata] (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
         * @param {boolean} [replaceAllImages] (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(itemId: string, metadataRefreshMode?: MetadataRefreshMode, imageRefreshMode?: MetadataRefreshMode, replaceAllMetadata?: boolean, replaceAllImages?: boolean, options?: any): AxiosPromise<void> {
            return ItemRefreshApiFp(configuration).post(itemId, metadataRefreshMode, imageRefreshMode, replaceAllMetadata, replaceAllImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemRefreshApi - object-oriented interface
 * @export
 * @class ItemRefreshApi
 * @extends {BaseAPI}
 */
export class ItemRefreshApi extends BaseAPI {
    /**
     * 
     * @summary Refreshes metadata for an item.
     * @param {string} itemId Item id.
     * @param {MetadataRefreshMode} [metadataRefreshMode] (Optional) Specifies the metadata refresh mode.
     * @param {MetadataRefreshMode} [imageRefreshMode] (Optional) Specifies the image refresh mode.
     * @param {boolean} [replaceAllMetadata] (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
     * @param {boolean} [replaceAllImages] (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemRefreshApi
     */
    public post(itemId: string, metadataRefreshMode?: MetadataRefreshMode, imageRefreshMode?: MetadataRefreshMode, replaceAllMetadata?: boolean, replaceAllImages?: boolean, options?: any) {
        return ItemRefreshApiFp(this.configuration).post(itemId, metadataRefreshMode, imageRefreshMode, replaceAllMetadata, replaceAllImages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemUpdateApi - axios parameter creator
 * @export
 */
export const ItemUpdateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets metadata editor info for an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataEditorInfo: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getMetadataEditorInfo.');
            }
            const localVarPath = `/Items/{itemId}/MetadataEditor`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an item.
         * @param {string} itemId The item id.
         * @param {BaseItemDto} baseItemDto The new item properties.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (itemId: string, baseItemDto: BaseItemDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItem.');
            }
            // verify required parameter 'baseItemDto' is not null or undefined
            if (baseItemDto === null || baseItemDto === undefined) {
                throw new RequiredError('baseItemDto','Required parameter baseItemDto was null or undefined when calling updateItem.');
            }
            const localVarPath = `/Items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof baseItemDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(baseItemDto !== undefined ? baseItemDto : {}) : (baseItemDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an item\'s content type.
         * @param {string} itemId The item id.
         * @param {string} [contentType] The content type of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemContentType: async (itemId: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItemContentType.');
            }
            const localVarPath = `/Items/{itemId}/ContentType`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['contentType'] = contentType;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemUpdateApi - functional programming interface
 * @export
 */
export const ItemUpdateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets metadata editor info for an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataEditorInfo(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataEditorInfo>> {
            const localVarAxiosArgs = await ItemUpdateApiAxiosParamCreator(configuration).getMetadataEditorInfo(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates an item.
         * @param {string} itemId The item id.
         * @param {BaseItemDto} baseItemDto The new item properties.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(itemId: string, baseItemDto: BaseItemDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemUpdateApiAxiosParamCreator(configuration).updateItem(itemId, baseItemDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates an item\'s content type.
         * @param {string} itemId The item id.
         * @param {string} [contentType] The content type of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemContentType(itemId: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemUpdateApiAxiosParamCreator(configuration).updateItemContentType(itemId, contentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemUpdateApi - factory interface
 * @export
 */
export const ItemUpdateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets metadata editor info for an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataEditorInfo(itemId: string, options?: any): AxiosPromise<MetadataEditorInfo> {
            return ItemUpdateApiFp(configuration).getMetadataEditorInfo(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an item.
         * @param {string} itemId The item id.
         * @param {BaseItemDto} baseItemDto The new item properties.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(itemId: string, baseItemDto: BaseItemDto, options?: any): AxiosPromise<void> {
            return ItemUpdateApiFp(configuration).updateItem(itemId, baseItemDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an item\'s content type.
         * @param {string} itemId The item id.
         * @param {string} [contentType] The content type of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemContentType(itemId: string, contentType?: string, options?: any): AxiosPromise<void> {
            return ItemUpdateApiFp(configuration).updateItemContentType(itemId, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemUpdateApi - object-oriented interface
 * @export
 * @class ItemUpdateApi
 * @extends {BaseAPI}
 */
export class ItemUpdateApi extends BaseAPI {
    /**
     * 
     * @summary Gets metadata editor info for an item.
     * @param {string} itemId The item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemUpdateApi
     */
    public getMetadataEditorInfo(itemId: string, options?: any) {
        return ItemUpdateApiFp(this.configuration).getMetadataEditorInfo(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an item.
     * @param {string} itemId The item id.
     * @param {BaseItemDto} baseItemDto The new item properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemUpdateApi
     */
    public updateItem(itemId: string, baseItemDto: BaseItemDto, options?: any) {
        return ItemUpdateApiFp(this.configuration).updateItem(itemId, baseItemDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an item\'s content type.
     * @param {string} itemId The item id.
     * @param {string} [contentType] The content type of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemUpdateApi
     */
    public updateItemContentType(itemId: string, contentType?: string, options?: any) {
        return ItemUpdateApiFp(this.configuration).updateItemContentType(itemId, contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: async (uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uId' is not null or undefined
            if (uId === null || uId === undefined) {
                throw new RequiredError('uId','Required parameter uId was null or undefined when calling getItems.');
            }
            const localVarPath = `/Items`
                .replace(`{${"uId"}}`, encodeURIComponent(String(uId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['maxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['hasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['hasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['hasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['hasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['hasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['parentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['hasParentalRating'] = hasParentalRating;
            }

            if (isHd !== undefined) {
                localVarQueryParameter['isHd'] = isHd;
            }

            if (is4K !== undefined) {
                localVarQueryParameter['is4K'] = is4K;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['locationTypes'] = locationTypes;
            }

            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter['excludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['isUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['minCriticRating'] = minCriticRating;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['minPremiereDate'] = (minPremiereDate as any instanceof Date) ?
                    (minPremiereDate as any).toISOString() :
                    minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['minDateLastSaved'] = (minDateLastSaved as any instanceof Date) ?
                    (minDateLastSaved as any).toISOString() :
                    minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['minDateLastSavedForUser'] = (minDateLastSavedForUser as any instanceof Date) ?
                    (minDateLastSavedForUser as any).toISOString() :
                    minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['maxPremiereDate'] = (maxPremiereDate as any instanceof Date) ?
                    (maxPremiereDate as any).toISOString() :
                    maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['hasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['hasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['hasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['hasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['excludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (imageTypes !== undefined) {
                localVarQueryParameter['imageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (artists !== undefined) {
                localVarQueryParameter['artists'] = artists;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['artistIds'] = artistIds;
            }

            if (albumArtistIds !== undefined) {
                localVarQueryParameter['albumArtistIds'] = albumArtistIds;
            }

            if (contributingArtistIds !== undefined) {
                localVarQueryParameter['contributingArtistIds'] = contributingArtistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['albums'] = albums;
            }

            if (albumIds !== undefined) {
                localVarQueryParameter['albumIds'] = albumIds;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['videoTypes'] = videoTypes;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['minOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['isPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['hasOfficialRating'] = hasOfficialRating;
            }

            if (collapseBoxSetItems !== undefined) {
                localVarQueryParameter['collapseBoxSetItems'] = collapseBoxSetItems;
            }

            if (minWidth !== undefined) {
                localVarQueryParameter['minWidth'] = minWidth;
            }

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['seriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems2: async (uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uId' is not null or undefined
            if (uId === null || uId === undefined) {
                throw new RequiredError('uId','Required parameter uId was null or undefined when calling getItems2.');
            }
            const localVarPath = `/Users/{uId}/Items`
                .replace(`{${"uId"}}`, encodeURIComponent(String(uId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['maxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['hasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['hasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['hasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['hasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['hasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['parentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['hasParentalRating'] = hasParentalRating;
            }

            if (isHd !== undefined) {
                localVarQueryParameter['isHd'] = isHd;
            }

            if (is4K !== undefined) {
                localVarQueryParameter['is4K'] = is4K;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['locationTypes'] = locationTypes;
            }

            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter['excludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['isUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['minCriticRating'] = minCriticRating;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['minPremiereDate'] = (minPremiereDate as any instanceof Date) ?
                    (minPremiereDate as any).toISOString() :
                    minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['minDateLastSaved'] = (minDateLastSaved as any instanceof Date) ?
                    (minDateLastSaved as any).toISOString() :
                    minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['minDateLastSavedForUser'] = (minDateLastSavedForUser as any instanceof Date) ?
                    (minDateLastSavedForUser as any).toISOString() :
                    minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['maxPremiereDate'] = (maxPremiereDate as any instanceof Date) ?
                    (maxPremiereDate as any).toISOString() :
                    maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['hasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['hasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['hasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['hasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['excludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (imageTypes !== undefined) {
                localVarQueryParameter['imageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (artists !== undefined) {
                localVarQueryParameter['artists'] = artists;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['artistIds'] = artistIds;
            }

            if (albumArtistIds !== undefined) {
                localVarQueryParameter['albumArtistIds'] = albumArtistIds;
            }

            if (contributingArtistIds !== undefined) {
                localVarQueryParameter['contributingArtistIds'] = contributingArtistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['albums'] = albums;
            }

            if (albumIds !== undefined) {
                localVarQueryParameter['albumIds'] = albumIds;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['videoTypes'] = videoTypes;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['minOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['isPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['hasOfficialRating'] = hasOfficialRating;
            }

            if (collapseBoxSetItems !== undefined) {
                localVarQueryParameter['collapseBoxSetItems'] = collapseBoxSetItems;
            }

            if (minWidth !== undefined) {
                localVarQueryParameter['minWidth'] = minWidth;
            }

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['seriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} userId The user id.
         * @param {number} [startIndex] The start index.
         * @param {number} [limit] The item limit.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResumeItems: async (userId: string, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, mediaTypes?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, excludeItemTypes?: string, includeItemTypes?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getResumeItems.');
            }
            const localVarPath = `/Users/{userId}/Items/Resume`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).getItems(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems2(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).getItems2(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} userId The user id.
         * @param {number} [startIndex] The start index.
         * @param {number} [limit] The item limit.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResumeItems(userId: string, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, mediaTypes?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, excludeItemTypes?: string, includeItemTypes?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).getResumeItems(userId, startIndex, limit, searchTerm, parentId, fields, mediaTypes, enableUserData, imageTypeLimit, enableImageTypes, excludeItemTypes, includeItemTypes, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ItemsApiFp(configuration).getItems(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems2(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ItemsApiFp(configuration).getItems2(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} userId The user id.
         * @param {number} [startIndex] The start index.
         * @param {number} [limit] The item limit.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResumeItems(userId: string, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, mediaTypes?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, excludeItemTypes?: string, includeItemTypes?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ItemsApiFp(configuration).getResumeItems(userId, startIndex, limit, searchTerm, parentId, fields, mediaTypes, enableUserData, imageTypeLimit, enableImageTypes, excludeItemTypes, includeItemTypes, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * 
     * @summary Gets items based on a query.
     * @param {string} uId The user id supplied in the /Users/{uid}/Items.
     * @param {string} [userId] The user id supplied as query parameter.
     * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
     * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
     * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
     * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
     * @param {boolean} [hasTrailer] Optional filter by items with trailers.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {number} [parentIndexNumber] Optional filter by parent index number.
     * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
     * @param {boolean} [isHd] Optional filter by items that are HD or not.
     * @param {boolean} [is4K] Optional filter by items that are 4K or not.
     * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
     * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
     * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [minCriticRating] Optional filter by minimum critic rating.
     * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
     * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
     * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
     * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
     * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
     * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
     * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
     * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
     * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
     * @param {string} [searchTerm] Optional. Filter based on a search term.
     * @param {string} [sortOrder] Sort Order - Ascending,Descending.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param {boolean} [enableUserData] Optional, include user data.
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
     * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
     * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
     * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
     * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
     * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
     * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
     * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [isLocked] Optional filter by items that are locked.
     * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
     * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
     * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
     * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
     * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
     * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
     * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
     * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
     * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
     * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
     * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
     * @param {boolean} [enableImages] Optional, include image information in output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItems(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any) {
        return ItemsApiFp(this.configuration).getItems(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets items based on a query.
     * @param {string} uId The user id supplied in the /Users/{uid}/Items.
     * @param {string} [userId] The user id supplied as query parameter.
     * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
     * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
     * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
     * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
     * @param {boolean} [hasTrailer] Optional filter by items with trailers.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {number} [parentIndexNumber] Optional filter by parent index number.
     * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
     * @param {boolean} [isHd] Optional filter by items that are HD or not.
     * @param {boolean} [is4K] Optional filter by items that are 4K or not.
     * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
     * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
     * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [minCriticRating] Optional filter by minimum critic rating.
     * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
     * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
     * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
     * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
     * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
     * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
     * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
     * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
     * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
     * @param {string} [searchTerm] Optional. Filter based on a search term.
     * @param {string} [sortOrder] Sort Order - Ascending,Descending.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param {boolean} [enableUserData] Optional, include user data.
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
     * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
     * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
     * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
     * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
     * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
     * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
     * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [isLocked] Optional filter by items that are locked.
     * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
     * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
     * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
     * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
     * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
     * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
     * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
     * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
     * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
     * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
     * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
     * @param {boolean} [enableImages] Optional, include image information in output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItems2(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any) {
        return ItemsApiFp(this.configuration).getItems2(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets items based on a query.
     * @param {string} userId The user id.
     * @param {number} [startIndex] The start index.
     * @param {number} [limit] The item limit.
     * @param {string} [searchTerm] The search term.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
     * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getResumeItems(userId: string, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, mediaTypes?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, excludeItemTypes?: string, includeItemTypes?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any) {
        return ItemsApiFp(this.configuration).getResumeItems(userId, startIndex, limit, searchTerm, parentId, fields, mediaTypes, enableUserData, imageTypeLimit, enableImageTypes, excludeItemTypes, includeItemTypes, enableTotalRecordCount, enableImages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryApi - axios parameter creator
 * @export
 */
export const LibraryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an item from the library and filesystem.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItem.');
            }
            const localVarPath = `/Items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes items from the library and filesystem.
         * @param {string} [ids] The item ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems: async (ids?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all parents of an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAncestors: async (itemId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAncestors.');
            }
            const localVarPath = `/Items/{itemId}/Ancestors`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets critic review for an item.
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCriticReviews: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getCriticReviews.');
            }
            const localVarPath = `/Items/{itemId}/CriticReviews`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads item media.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getDownload.');
            }
            const localVarPath = `/Items/{itemId}/Download`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the original file of an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getFile.');
            }
            const localVarPath = `/Items/{itemId}/File`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get item counts.
         * @param {string} [userId] Optional. Get counts from a specific user\&#39;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCounts: async (userId?: string, isFavorite?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items/Counts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the library options info.
         * @param {string} [libraryContentType] Library content type.
         * @param {boolean} [isNewLibrary] Whether this is a new library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryOptionsInfo: async (libraryContentType?: string, isNewLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Libraries/AvailableOptions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (libraryContentType !== undefined) {
                localVarQueryParameter['libraryContentType'] = libraryContentType;
            }

            if (isNewLibrary !== undefined) {
                localVarQueryParameter['isNewLibrary'] = isNewLibrary;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFolders: async (isHidden?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/MediaFolders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isHidden !== undefined) {
                localVarQueryParameter['isHidden'] = isHidden;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of physical paths from virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalPaths: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/PhysicalPaths`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarAlbums2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarAlbums2.');
            }
            const localVarPath = `/Albums/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarArtists2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarArtists2.');
            }
            const localVarPath = `/Artists/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarItems.');
            }
            const localVarPath = `/Items/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarMovies2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarMovies2.');
            }
            const localVarPath = `/Movies/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarShows2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarShows2.');
            }
            const localVarPath = `/Shows/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarTrailers2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarTrailers2.');
            }
            const localVarPath = `/Trailers/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get theme songs and videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeMedia: async (itemId: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getThemeMedia.');
            }
            const localVarPath = `/Items/{itemId}/ThemeMedia`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get theme songs for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeSongs: async (itemId: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getThemeSongs.');
            }
            const localVarPath = `/Items/{itemId}/ThemeSongs`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get theme videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeVideos: async (itemId: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getThemeVideos.');
            }
            const localVarPath = `/Items/{itemId}/ThemeVideos`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedMovies: async (tmdbId?: string, imdbId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Movies/Added`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tmdbId !== undefined) {
                localVarQueryParameter['tmdbId'] = tmdbId;
            }

            if (imdbId !== undefined) {
                localVarQueryParameter['imdbId'] = imdbId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedSeries: async (tvdbId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Series/Added`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tvdbId !== undefined) {
                localVarQueryParameter['tvdbId'] = tvdbId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {Array<MediaUpdateInfoDto>} mediaUpdateInfoDto A list of updated media paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMedia: async (mediaUpdateInfoDto: Array<MediaUpdateInfoDto>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaUpdateInfoDto' is not null or undefined
            if (mediaUpdateInfoDto === null || mediaUpdateInfoDto === undefined) {
                throw new RequiredError('mediaUpdateInfoDto','Required parameter mediaUpdateInfoDto was null or undefined when calling postUpdatedMedia.');
            }
            const localVarPath = `/Library/Media/Updated`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaUpdateInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaUpdateInfoDto !== undefined ? mediaUpdateInfoDto : {}) : (mediaUpdateInfoDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMovies: async (tmdbId?: string, imdbId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Movies/Updated`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tmdbId !== undefined) {
                localVarQueryParameter['tmdbId'] = tmdbId;
            }

            if (imdbId !== undefined) {
                localVarQueryParameter['imdbId'] = imdbId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedSeries: async (tvdbId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Series/Updated`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tvdbId !== undefined) {
                localVarQueryParameter['tvdbId'] = tvdbId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Starts a library scan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Refresh`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryApi - functional programming interface
 * @export
 */
export const LibraryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an item from the library and filesystem.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).deleteItem(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes items from the library and filesystem.
         * @param {string} [ids] The item ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItems(ids?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).deleteItems(ids, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all parents of an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAncestors(itemId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getAncestors(itemId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets critic review for an item.
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCriticReviews(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getCriticReviews(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Downloads item media.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownload(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getDownload(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the original file of an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getFile(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get item counts.
         * @param {string} [userId] Optional. Get counts from a specific user\&#39;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemCounts(userId?: string, isFavorite?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemCounts>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getItemCounts(userId, isFavorite, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the library options info.
         * @param {string} [libraryContentType] Library content type.
         * @param {boolean} [isNewLibrary] Whether this is a new library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryOptionsInfo(libraryContentType?: string, isNewLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryOptionsResultDto>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getLibraryOptionsInfo(libraryContentType, isNewLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaFolders(isHidden?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getMediaFolders(isHidden, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of physical paths from virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalPaths(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getPhysicalPaths(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarAlbums2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarAlbums2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarArtists2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarArtists2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarItems(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarItems(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarMovies2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarMovies2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarShows2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarShows2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarTrailers2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarTrailers2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get theme songs and videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeMedia(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getThemeMedia(itemId, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get theme songs for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeSongs(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getThemeSongs(itemId, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get theme videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeVideos(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getThemeVideos(itemId, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAddedMovies(tmdbId?: string, imdbId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postAddedMovies(tmdbId, imdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAddedSeries(tvdbId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postAddedSeries(tvdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {Array<MediaUpdateInfoDto>} mediaUpdateInfoDto A list of updated media paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedMedia(mediaUpdateInfoDto: Array<MediaUpdateInfoDto>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postUpdatedMedia(mediaUpdateInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedMovies(tmdbId?: string, imdbId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postUpdatedMovies(tmdbId, imdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedSeries(tvdbId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postUpdatedSeries(tvdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Starts a library scan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLibrary(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).refreshLibrary(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LibraryApi - factory interface
 * @export
 */
export const LibraryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes an item from the library and filesystem.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(itemId: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).deleteItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes items from the library and filesystem.
         * @param {string} [ids] The item ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems(ids?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).deleteItems(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all parents of an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAncestors(itemId: string, userId?: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return LibraryApiFp(configuration).getAncestors(itemId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets critic review for an item.
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCriticReviews(itemId: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getCriticReviews(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads item media.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload(itemId: string, options?: any): AxiosPromise<any> {
            return LibraryApiFp(configuration).getDownload(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the original file of an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(itemId: string, options?: any): AxiosPromise<any> {
            return LibraryApiFp(configuration).getFile(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get item counts.
         * @param {string} [userId] Optional. Get counts from a specific user\&#39;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCounts(userId?: string, isFavorite?: boolean, options?: any): AxiosPromise<ItemCounts> {
            return LibraryApiFp(configuration).getItemCounts(userId, isFavorite, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the library options info.
         * @param {string} [libraryContentType] Library content type.
         * @param {boolean} [isNewLibrary] Whether this is a new library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryOptionsInfo(libraryContentType?: string, isNewLibrary?: boolean, options?: any): AxiosPromise<LibraryOptionsResultDto> {
            return LibraryApiFp(configuration).getLibraryOptionsInfo(libraryContentType, isNewLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFolders(isHidden?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getMediaFolders(isHidden, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of physical paths from virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalPaths(options?: any): AxiosPromise<Array<string>> {
            return LibraryApiFp(configuration).getPhysicalPaths(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarAlbums2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarAlbums2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarArtists2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarArtists2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarItems(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarMovies2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarMovies2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarShows2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarShows2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarTrailers2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarTrailers2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get theme songs and videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeMedia(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<AllThemeMediaResult> {
            return LibraryApiFp(configuration).getThemeMedia(itemId, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get theme songs for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeSongs(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<ThemeMediaResult> {
            return LibraryApiFp(configuration).getThemeSongs(itemId, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get theme videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeVideos(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<ThemeMediaResult> {
            return LibraryApiFp(configuration).getThemeVideos(itemId, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedMovies(tmdbId?: string, imdbId?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postAddedMovies(tmdbId, imdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedSeries(tvdbId?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postAddedSeries(tvdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {Array<MediaUpdateInfoDto>} mediaUpdateInfoDto A list of updated media paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMedia(mediaUpdateInfoDto: Array<MediaUpdateInfoDto>, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postUpdatedMedia(mediaUpdateInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMovies(tmdbId?: string, imdbId?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postUpdatedMovies(tmdbId, imdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedSeries(tvdbId?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postUpdatedSeries(tvdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Starts a library scan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary(options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).refreshLibrary(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
export class LibraryApi extends BaseAPI {
    /**
     * 
     * @summary Deletes an item from the library and filesystem.
     * @param {string} itemId The item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public deleteItem(itemId: string, options?: any) {
        return LibraryApiFp(this.configuration).deleteItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes items from the library and filesystem.
     * @param {string} [ids] The item ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public deleteItems(ids?: string, options?: any) {
        return LibraryApiFp(this.configuration).deleteItems(ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all parents of an item.
     * @param {string} itemId The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getAncestors(itemId: string, userId?: string, options?: any) {
        return LibraryApiFp(this.configuration).getAncestors(itemId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets critic review for an item.
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getCriticReviews(itemId: string, options?: any) {
        return LibraryApiFp(this.configuration).getCriticReviews(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads item media.
     * @param {string} itemId The item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getDownload(itemId: string, options?: any) {
        return LibraryApiFp(this.configuration).getDownload(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the original file of an item.
     * @param {string} itemId The item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getFile(itemId: string, options?: any) {
        return LibraryApiFp(this.configuration).getFile(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get item counts.
     * @param {string} [userId] Optional. Get counts from a specific user\&#39;s library.
     * @param {boolean} [isFavorite] Optional. Get counts of favorite items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getItemCounts(userId?: string, isFavorite?: boolean, options?: any) {
        return LibraryApiFp(this.configuration).getItemCounts(userId, isFavorite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the library options info.
     * @param {string} [libraryContentType] Library content type.
     * @param {boolean} [isNewLibrary] Whether this is a new library.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraryOptionsInfo(libraryContentType?: string, isNewLibrary?: boolean, options?: any) {
        return LibraryApiFp(this.configuration).getLibraryOptionsInfo(libraryContentType, isNewLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all user media folders.
     * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getMediaFolders(isHidden?: boolean, options?: any) {
        return LibraryApiFp(this.configuration).getMediaFolders(isHidden, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of physical paths from virtual folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getPhysicalPaths(options?: any) {
        return LibraryApiFp(this.configuration).getPhysicalPaths(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {string} itemId The item id.
     * @param {string} [excludeArtistIds] Exclude artist ids.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarAlbums2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarAlbums2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {string} itemId The item id.
     * @param {string} [excludeArtistIds] Exclude artist ids.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarArtists2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarArtists2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {string} itemId The item id.
     * @param {string} [excludeArtistIds] Exclude artist ids.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarItems(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarItems(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {string} itemId The item id.
     * @param {string} [excludeArtistIds] Exclude artist ids.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarMovies2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarMovies2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {string} itemId The item id.
     * @param {string} [excludeArtistIds] Exclude artist ids.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarShows2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarShows2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {string} itemId The item id.
     * @param {string} [excludeArtistIds] Exclude artist ids.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarTrailers2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarTrailers2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get theme songs and videos for an item.
     * @param {string} itemId The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getThemeMedia(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any) {
        return LibraryApiFp(this.configuration).getThemeMedia(itemId, userId, inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get theme songs for an item.
     * @param {string} itemId The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getThemeSongs(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any) {
        return LibraryApiFp(this.configuration).getThemeSongs(itemId, userId, inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get theme videos for an item.
     * @param {string} itemId The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getThemeVideos(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any) {
        return LibraryApiFp(this.configuration).getThemeVideos(itemId, userId, inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that new movies have been added by an external source.
     * @param {string} [tmdbId] The tmdbId.
     * @param {string} [imdbId] The imdbId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postAddedMovies(tmdbId?: string, imdbId?: string, options?: any) {
        return LibraryApiFp(this.configuration).postAddedMovies(tmdbId, imdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that new episodes of a series have been added by an external source.
     * @param {string} [tvdbId] The tvdbId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postAddedSeries(tvdbId?: string, options?: any) {
        return LibraryApiFp(this.configuration).postAddedSeries(tvdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that new movies have been added by an external source.
     * @param {Array<MediaUpdateInfoDto>} mediaUpdateInfoDto A list of updated media paths.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postUpdatedMedia(mediaUpdateInfoDto: Array<MediaUpdateInfoDto>, options?: any) {
        return LibraryApiFp(this.configuration).postUpdatedMedia(mediaUpdateInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that new movies have been added by an external source.
     * @param {string} [tmdbId] The tmdbId.
     * @param {string} [imdbId] The imdbId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postUpdatedMovies(tmdbId?: string, imdbId?: string, options?: any) {
        return LibraryApiFp(this.configuration).postUpdatedMovies(tmdbId, imdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that new episodes of a series have been added by an external source.
     * @param {string} [tvdbId] The tvdbId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postUpdatedSeries(tvdbId?: string, options?: any) {
        return LibraryApiFp(this.configuration).postUpdatedSeries(tvdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Starts a library scan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public refreshLibrary(options?: any) {
        return LibraryApiFp(this.configuration).refreshLibrary(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryStructureApi - axios parameter creator
 * @export
 */
export const LibraryStructureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a media path to a library.
         * @param {MediaPathDto} mediaPathDto The media path dto.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMediaPath: async (mediaPathDto: MediaPathDto, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaPathDto' is not null or undefined
            if (mediaPathDto === null || mediaPathDto === undefined) {
                throw new RequiredError('mediaPathDto','Required parameter mediaPathDto was null or undefined when calling addMediaPath.');
            }
            const localVarPath = `/Library/VirtualFolders/Paths`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaPathDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaPathDto !== undefined ? mediaPathDto : {}) : (mediaPathDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [collectionType] The type of the collection.
         * @param {Array<string>} [paths] The paths of the virtual folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {AddVirtualFolderDto} [addVirtualFolderDto] The library options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVirtualFolder: async (name?: string, collectionType?: string, paths?: Array<string>, refreshLibrary?: boolean, addVirtualFolderDto?: AddVirtualFolderDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (collectionType !== undefined) {
                localVarQueryParameter['collectionType'] = collectionType;
            }

            if (paths) {
                localVarQueryParameter['paths'] = paths;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof addVirtualFolderDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addVirtualFolderDto !== undefined ? addVirtualFolderDto : {}) : (addVirtualFolderDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualFolders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a media path.
         * @param {string} [name] The name of the library.
         * @param {string} [path] The path to remove.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMediaPath: async (name?: string, path?: string, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/Paths`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes a virtual folder.
         * @param {string} [name] The name of the folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVirtualFolder: async (name?: string, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Renames a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [newName] The new name.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameVirtualFolder: async (name?: string, newName?: string, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/Name`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (newName !== undefined) {
                localVarQueryParameter['newName'] = newName;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update library options.
         * @param {UpdateLibraryOptionsDto} [updateLibraryOptionsDto] The library name and options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryOptions: async (updateLibraryOptionsDto?: UpdateLibraryOptionsDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/LibraryOptions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateLibraryOptionsDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateLibraryOptionsDto !== undefined ? updateLibraryOptionsDto : {}) : (updateLibraryOptionsDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a media path.
         * @param {string} [name] The name of the library.
         * @param {MediaPathInfo} [mediaPathInfo] The path info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaPath: async (name?: string, mediaPathInfo?: MediaPathInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/Paths/Update`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaPathInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaPathInfo !== undefined ? mediaPathInfo : {}) : (mediaPathInfo || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryStructureApi - functional programming interface
 * @export
 */
export const LibraryStructureApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a media path to a library.
         * @param {MediaPathDto} mediaPathDto The media path dto.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMediaPath(mediaPathDto: MediaPathDto, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).addMediaPath(mediaPathDto, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Adds a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [collectionType] The type of the collection.
         * @param {Array<string>} [paths] The paths of the virtual folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {AddVirtualFolderDto} [addVirtualFolderDto] The library options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVirtualFolder(name?: string, collectionType?: string, paths?: Array<string>, refreshLibrary?: boolean, addVirtualFolderDto?: AddVirtualFolderDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).addVirtualFolder(name, collectionType, paths, refreshLibrary, addVirtualFolderDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualFolders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualFolderInfo>>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).getVirtualFolders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove a media path.
         * @param {string} [name] The name of the library.
         * @param {string} [path] The path to remove.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMediaPath(name?: string, path?: string, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).removeMediaPath(name, path, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes a virtual folder.
         * @param {string} [name] The name of the folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeVirtualFolder(name?: string, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).removeVirtualFolder(name, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Renames a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [newName] The new name.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameVirtualFolder(name?: string, newName?: string, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).renameVirtualFolder(name, newName, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update library options.
         * @param {UpdateLibraryOptionsDto} [updateLibraryOptionsDto] The library name and options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLibraryOptions(updateLibraryOptionsDto?: UpdateLibraryOptionsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).updateLibraryOptions(updateLibraryOptionsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a media path.
         * @param {string} [name] The name of the library.
         * @param {MediaPathInfo} [mediaPathInfo] The path info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMediaPath(name?: string, mediaPathInfo?: MediaPathInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).updateMediaPath(name, mediaPathInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LibraryStructureApi - factory interface
 * @export
 */
export const LibraryStructureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add a media path to a library.
         * @param {MediaPathDto} mediaPathDto The media path dto.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMediaPath(mediaPathDto: MediaPathDto, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).addMediaPath(mediaPathDto, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [collectionType] The type of the collection.
         * @param {Array<string>} [paths] The paths of the virtual folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {AddVirtualFolderDto} [addVirtualFolderDto] The library options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVirtualFolder(name?: string, collectionType?: string, paths?: Array<string>, refreshLibrary?: boolean, addVirtualFolderDto?: AddVirtualFolderDto, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).addVirtualFolder(name, collectionType, paths, refreshLibrary, addVirtualFolderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualFolders(options?: any): AxiosPromise<Array<VirtualFolderInfo>> {
            return LibraryStructureApiFp(configuration).getVirtualFolders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a media path.
         * @param {string} [name] The name of the library.
         * @param {string} [path] The path to remove.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMediaPath(name?: string, path?: string, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).removeMediaPath(name, path, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes a virtual folder.
         * @param {string} [name] The name of the folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVirtualFolder(name?: string, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).removeVirtualFolder(name, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Renames a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [newName] The new name.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameVirtualFolder(name?: string, newName?: string, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).renameVirtualFolder(name, newName, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update library options.
         * @param {UpdateLibraryOptionsDto} [updateLibraryOptionsDto] The library name and options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryOptions(updateLibraryOptionsDto?: UpdateLibraryOptionsDto, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).updateLibraryOptions(updateLibraryOptionsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a media path.
         * @param {string} [name] The name of the library.
         * @param {MediaPathInfo} [mediaPathInfo] The path info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaPath(name?: string, mediaPathInfo?: MediaPathInfo, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).updateMediaPath(name, mediaPathInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LibraryStructureApi - object-oriented interface
 * @export
 * @class LibraryStructureApi
 * @extends {BaseAPI}
 */
export class LibraryStructureApi extends BaseAPI {
    /**
     * 
     * @summary Add a media path to a library.
     * @param {MediaPathDto} mediaPathDto The media path dto.
     * @param {boolean} [refreshLibrary] Whether to refresh the library.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public addMediaPath(mediaPathDto: MediaPathDto, refreshLibrary?: boolean, options?: any) {
        return LibraryStructureApiFp(this.configuration).addMediaPath(mediaPathDto, refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a virtual folder.
     * @param {string} [name] The name of the virtual folder.
     * @param {string} [collectionType] The type of the collection.
     * @param {Array<string>} [paths] The paths of the virtual folder.
     * @param {boolean} [refreshLibrary] Whether to refresh the library.
     * @param {AddVirtualFolderDto} [addVirtualFolderDto] The library options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public addVirtualFolder(name?: string, collectionType?: string, paths?: Array<string>, refreshLibrary?: boolean, addVirtualFolderDto?: AddVirtualFolderDto, options?: any) {
        return LibraryStructureApiFp(this.configuration).addVirtualFolder(name, collectionType, paths, refreshLibrary, addVirtualFolderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all virtual folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public getVirtualFolders(options?: any) {
        return LibraryStructureApiFp(this.configuration).getVirtualFolders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a media path.
     * @param {string} [name] The name of the library.
     * @param {string} [path] The path to remove.
     * @param {boolean} [refreshLibrary] Whether to refresh the library.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public removeMediaPath(name?: string, path?: string, refreshLibrary?: boolean, options?: any) {
        return LibraryStructureApiFp(this.configuration).removeMediaPath(name, path, refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes a virtual folder.
     * @param {string} [name] The name of the folder.
     * @param {boolean} [refreshLibrary] Whether to refresh the library.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public removeVirtualFolder(name?: string, refreshLibrary?: boolean, options?: any) {
        return LibraryStructureApiFp(this.configuration).removeVirtualFolder(name, refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Renames a virtual folder.
     * @param {string} [name] The name of the virtual folder.
     * @param {string} [newName] The new name.
     * @param {boolean} [refreshLibrary] Whether to refresh the library.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public renameVirtualFolder(name?: string, newName?: string, refreshLibrary?: boolean, options?: any) {
        return LibraryStructureApiFp(this.configuration).renameVirtualFolder(name, newName, refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update library options.
     * @param {UpdateLibraryOptionsDto} [updateLibraryOptionsDto] The library name and options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public updateLibraryOptions(updateLibraryOptionsDto?: UpdateLibraryOptionsDto, options?: any) {
        return LibraryStructureApiFp(this.configuration).updateLibraryOptions(updateLibraryOptionsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a media path.
     * @param {string} [name] The name of the library.
     * @param {MediaPathInfo} [mediaPathInfo] The path info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public updateMediaPath(name?: string, mediaPathInfo?: MediaPathInfo, options?: any) {
        return LibraryStructureApiFp(this.configuration).updateMediaPath(name, mediaPathInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LiveTvApi - axios parameter creator
 * @export
 */
export const LiveTvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {ListingsProviderInfo} [listingsProviderInfo] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListingProvider: async (pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (pw !== undefined) {
                localVarQueryParameter['pw'] = pw;
            }

            if (validateListings !== undefined) {
                localVarQueryParameter['validateListings'] = validateListings;
            }

            if (validateLogin !== undefined) {
                localVarQueryParameter['validateLogin'] = validateLogin;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof listingsProviderInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(listingsProviderInfo !== undefined ? listingsProviderInfo : {}) : (listingsProviderInfo || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {TunerHostInfo} [tunerHostInfo] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTunerHost: async (tunerHostInfo?: TunerHostInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tunerHostInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tunerHostInfo !== undefined ? tunerHostInfo : {}) : (tunerHostInfo || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeriesTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling cancelSeriesTimer.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling cancelTimer.');
            }
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeriesTimer: async (seriesTimerInfoDto?: SeriesTimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof seriesTimerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(seriesTimerInfoDto !== undefined ? seriesTimerInfoDto : {}) : (seriesTimerInfoDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer: async (timerInfoDto?: TimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof timerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(timerInfoDto !== undefined ? timerInfoDto : {}) : (timerInfoDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListingProvider: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording: async (recordingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            if (recordingId === null || recordingId === undefined) {
                throw new RequiredError('recordingId','Required parameter recordingId was null or undefined when calling deleteRecording.');
            }
            const localVarPath = `/LiveTv/Recordings/{recordingId}`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunerHost: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTuners: async (newDevicesOnly?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Tuners/Discvover`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (newDevicesOnly !== undefined) {
                localVarQueryParameter['newDevicesOnly'] = newDevicesOnly;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel: async (channelId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getChannel.');
            }
            const localVarPath = `/LiveTv/Channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMappingOptions: async (providerId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['providerId'] = providerId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultListingProvider: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Default`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTimer: async (programId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers/Defaults`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (programId !== undefined) {
                localVarQueryParameter['programId'] = programId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get guid info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuideInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/GuideInfo`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineups: async (id?: string, type?: string, location?: string, country?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Lineups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveRecordingFile: async (recordingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            if (recordingId === null || recordingId === undefined) {
                throw new RequiredError('recordingId','Required parameter recordingId was null or undefined when calling getLiveRecordingFile.');
            }
            const localVarPath = `/LiveTv/LiveRecordings/{recordingId}/stream`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveStreamFile: async (streamId: string, container: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling getLiveStreamFile.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getLiveStreamFile.');
            }
            const localVarPath = `/LiveTv/LiveStreamFiles/{streamId}/stream.{container}`
                .replace(`{${"streamId"}}`, encodeURIComponent(String(streamId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvChannels: async (type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, sortBy?: string, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isLiked !== undefined) {
                localVarQueryParameter['isLiked'] = isLiked;
            }

            if (isDisliked !== undefined) {
                localVarQueryParameter['isDisliked'] = isDisliked;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (enableFavoriteSorting !== undefined) {
                localVarQueryParameter['enableFavoriteSorting'] = enableFavoriteSorting;
            }

            if (addCurrentProgram !== undefined) {
                localVarQueryParameter['addCurrentProgram'] = addCurrentProgram;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Info`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [genres] The genres to return guide information for.
         * @param {string} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvPrograms: async (channelIds?: string, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genres?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: string, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelIds !== undefined) {
                localVarQueryParameter['channelIds'] = channelIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (minStartDate !== undefined) {
                localVarQueryParameter['minStartDate'] = (minStartDate as any instanceof Date) ?
                    (minStartDate as any).toISOString() :
                    minStartDate;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['hasAired'] = hasAired;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (maxStartDate !== undefined) {
                localVarQueryParameter['maxStartDate'] = (maxStartDate as any instanceof Date) ?
                    (maxStartDate as any).toISOString() :
                    maxStartDate;
            }

            if (minEndDate !== undefined) {
                localVarQueryParameter['minEndDate'] = (minEndDate as any instanceof Date) ?
                    (minEndDate as any).toISOString() :
                    minEndDate;
            }

            if (maxEndDate !== undefined) {
                localVarQueryParameter['maxEndDate'] = (maxEndDate as any instanceof Date) ?
                    (maxEndDate as any).toISOString() :
                    maxEndDate;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (librarySeriesId !== undefined) {
                localVarQueryParameter['librarySeriesId'] = librarySeriesId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram: async (programId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            if (programId === null || programId === undefined) {
                throw new RequiredError('programId','Required parameter programId was null or undefined when calling getProgram.');
            }
            const localVarPath = `/LiveTv/Programs/{programId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {GetProgramsDto} [getProgramsDto] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrograms: async (getProgramsDto?: GetProgramsDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof getProgramsDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(getProgramsDto !== undefined ? getProgramsDto : {}) : (getProgramsDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedPrograms: async (userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs/Recommended`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['hasAired'] = hasAired;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecording: async (recordingId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            if (recordingId === null || recordingId === undefined) {
                throw new RequiredError('recordingId','Required parameter recordingId was null or undefined when calling getRecording.');
            }
            const localVarPath = `/LiveTv/Recordings/{recordingId}`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingFolders: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Folders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling getRecordingGroup.');
            }
            const localVarPath = `/LiveTv/Recordings/Groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroups: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordings: async (channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['isInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isLibraryItem !== undefined) {
                localVarQueryParameter['isLibraryItem'] = isLibraryItem;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingsSeries: async (channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Series`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['isInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulesDirectCountries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/SchedulesDirect/Countries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling getSeriesTimer.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimers: async (sortBy?: string, sortOrder?: SortOrder, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling getTimer.');
            }
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimers: async (channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (isScheduled !== undefined) {
                localVarQueryParameter['isScheduled'] = isScheduled;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTunerHostTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts/Types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuner: async (tunerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunerId' is not null or undefined
            if (tunerId === null || tunerId === undefined) {
                throw new RequiredError('tunerId','Required parameter tunerId was null or undefined when calling resetTuner.');
            }
            const localVarPath = `/LiveTv/Tuners/{tunerId}/Reset`
                .replace(`{${"tunerId"}}`, encodeURIComponent(String(tunerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {string} [providerId] Provider id.
         * @param {string} [tunerChannelId] Tuner channel id.
         * @param {string} [providerChannelId] Provider channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelMapping: async (providerId?: string, tunerChannelId?: string, providerChannelId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ChannelMappings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['providerId'] = providerId;
            }

            if (tunerChannelId !== undefined) {
                localVarQueryParameter['tunerChannelId'] = tunerChannelId;
            }

            if (providerChannelId !== undefined) {
                localVarQueryParameter['providerChannelId'] = providerChannelId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeriesTimer: async (timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling updateSeriesTimer.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof seriesTimerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(seriesTimerInfoDto !== undefined ? seriesTimerInfoDto : {}) : (seriesTimerInfoDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer: async (timerId: string, timerInfoDto?: TimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling updateTimer.');
            }
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof timerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(timerInfoDto !== undefined ? timerInfoDto : {}) : (timerInfoDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveTvApi - functional programming interface
 * @export
 */
export const LiveTvApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {ListingsProviderInfo} [listingsProviderInfo] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingsProviderInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).addListingProvider(pw, validateListings, validateLogin, listingsProviderInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {TunerHostInfo} [tunerHostInfo] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTunerHost(tunerHostInfo?: TunerHostInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerHostInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).addTunerHost(tunerHostInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSeriesTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).cancelSeriesTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).cancelTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSeriesTimer(seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).createSeriesTimer(seriesTimerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimer(timerInfoDto?: TimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).createTimer(timerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListingProvider(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).deleteListingProvider(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecording(recordingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).deleteRecording(recordingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTunerHost(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).deleteTunerHost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverTuners(newDevicesOnly?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TunerHostInfo>>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).discoverTuners(newDevicesOnly, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel(channelId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getChannel(channelId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelMappingOptions(providerId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelMappingOptionsDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getChannelMappingOptions(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultListingProvider(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingsProviderInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getDefaultListingProvider(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultTimer(programId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getDefaultTimer(programId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get guid info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuideInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuideInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getGuideInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLineups(id?: string, type?: string, location?: string, country?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLineups(id, type, location, country, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveRecordingFile(recordingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveRecordingFile(recordingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveStreamFile(streamId: string, container: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveStreamFile(streamId, container, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, sortBy?: string, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveTvInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [genres] The genres to return guide information for.
         * @param {string} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvPrograms(channelIds?: string, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genres?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: string, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgram(programId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getProgram(programId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {GetProgramsDto} [getProgramsDto] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrograms(getProgramsDto?: GetProgramsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getPrograms(getProgramsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecommendedPrograms(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecording(recordingId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecording(recordingId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingFolders(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingFolders(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingGroup(groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingGroups(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingGroups(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedulesDirectCountries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getSchedulesDirectCountries(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getSeriesTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getSeriesTimers(sortBy, sortOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerInfoDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getTimers(channelId, seriesTimerId, isActive, isScheduled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTunerHostTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getTunerHostTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetTuner(tunerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).resetTuner(tunerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {string} [providerId] Provider id.
         * @param {string} [tunerChannelId] Tuner channel id.
         * @param {string} [providerChannelId] Provider channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setChannelMapping(providerId?: string, tunerChannelId?: string, providerChannelId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerChannelMapping>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).setChannelMapping(providerId, tunerChannelId, providerChannelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSeriesTimer(timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).updateSeriesTimer(timerId, seriesTimerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTimer(timerId: string, timerInfoDto?: TimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).updateTimer(timerId, timerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LiveTvApi - factory interface
 * @export
 */
export const LiveTvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {ListingsProviderInfo} [listingsProviderInfo] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options?: any): AxiosPromise<ListingsProviderInfo> {
            return LiveTvApiFp(configuration).addListingProvider(pw, validateListings, validateLogin, listingsProviderInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {TunerHostInfo} [tunerHostInfo] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTunerHost(tunerHostInfo?: TunerHostInfo, options?: any): AxiosPromise<TunerHostInfo> {
            return LiveTvApiFp(configuration).addTunerHost(tunerHostInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeriesTimer(timerId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).cancelSeriesTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTimer(timerId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).cancelTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeriesTimer(seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).createSeriesTimer(seriesTimerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer(timerInfoDto?: TimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).createTimer(timerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListingProvider(id?: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).deleteListingProvider(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording(recordingId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).deleteRecording(recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunerHost(id?: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).deleteTunerHost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTuners(newDevicesOnly?: boolean, options?: any): AxiosPromise<Array<TunerHostInfo>> {
            return LiveTvApiFp(configuration).discoverTuners(newDevicesOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvApiFp(configuration).getChannel(channelId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMappingOptions(providerId?: string, options?: any): AxiosPromise<ChannelMappingOptionsDto> {
            return LiveTvApiFp(configuration).getChannelMappingOptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultListingProvider(options?: any): AxiosPromise<ListingsProviderInfo> {
            return LiveTvApiFp(configuration).getDefaultListingProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTimer(programId?: string, options?: any): AxiosPromise<SeriesTimerInfoDto> {
            return LiveTvApiFp(configuration).getDefaultTimer(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get guid info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuideInfo(options?: any): AxiosPromise<GuideInfo> {
            return LiveTvApiFp(configuration).getGuideInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineups(id?: string, type?: string, location?: string, country?: string, options?: any): AxiosPromise<Array<NameIdPair>> {
            return LiveTvApiFp(configuration).getLineups(id, type, location, country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveRecordingFile(recordingId: string, options?: any): AxiosPromise<any> {
            return LiveTvApiFp(configuration).getLiveRecordingFile(recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveStreamFile(streamId: string, container: string, options?: any): AxiosPromise<any> {
            return LiveTvApiFp(configuration).getLiveStreamFile(streamId, container, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, sortBy?: string, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvInfo(options?: any): AxiosPromise<LiveTvInfo> {
            return LiveTvApiFp(configuration).getLiveTvInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [genres] The genres to return guide information for.
         * @param {string} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvPrograms(channelIds?: string, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genres?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: string, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram(programId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvApiFp(configuration).getProgram(programId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {GetProgramsDto} [getProgramsDto] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrograms(getProgramsDto?: GetProgramsDto, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getPrograms(getProgramsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecommendedPrograms(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecording(recordingId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvApiFp(configuration).getRecording(recordingId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingFolders(userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordingFolders(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroup(groupId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).getRecordingGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroups(userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordingGroups(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulesDirectCountries(options?: any): AxiosPromise<any> {
            return LiveTvApiFp(configuration).getSchedulesDirectCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimer(timerId: string, options?: any): AxiosPromise<SeriesTimerInfoDto> {
            return LiveTvApiFp(configuration).getSeriesTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any): AxiosPromise<SeriesTimerInfoDtoQueryResult> {
            return LiveTvApiFp(configuration).getSeriesTimers(sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer(timerId: string, options?: any): AxiosPromise<TimerInfoDto> {
            return LiveTvApiFp(configuration).getTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any): AxiosPromise<TimerInfoDtoQueryResult> {
            return LiveTvApiFp(configuration).getTimers(channelId, seriesTimerId, isActive, isScheduled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTunerHostTypes(options?: any): AxiosPromise<Array<NameIdPair>> {
            return LiveTvApiFp(configuration).getTunerHostTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuner(tunerId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).resetTuner(tunerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {string} [providerId] Provider id.
         * @param {string} [tunerChannelId] Tuner channel id.
         * @param {string} [providerChannelId] Provider channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelMapping(providerId?: string, tunerChannelId?: string, providerChannelId?: string, options?: any): AxiosPromise<TunerChannelMapping> {
            return LiveTvApiFp(configuration).setChannelMapping(providerId, tunerChannelId, providerChannelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeriesTimer(timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).updateSeriesTimer(timerId, seriesTimerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer(timerId: string, timerInfoDto?: TimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).updateTimer(timerId, timerInfoDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiveTvApi - object-oriented interface
 * @export
 * @class LiveTvApi
 * @extends {BaseAPI}
 */
export class LiveTvApi extends BaseAPI {
    /**
     * 
     * @summary Adds a listings provider.
     * @param {string} [pw] Password.
     * @param {boolean} [validateListings] Validate listings.
     * @param {boolean} [validateLogin] Validate login.
     * @param {ListingsProviderInfo} [listingsProviderInfo] New listings info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options?: any) {
        return LiveTvApiFp(this.configuration).addListingProvider(pw, validateListings, validateLogin, listingsProviderInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a tuner host.
     * @param {TunerHostInfo} [tunerHostInfo] New tuner host.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public addTunerHost(tunerHostInfo?: TunerHostInfo, options?: any) {
        return LiveTvApiFp(this.configuration).addTunerHost(tunerHostInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a live tv series timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public cancelSeriesTimer(timerId: string, options?: any) {
        return LiveTvApiFp(this.configuration).cancelSeriesTimer(timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a live tv timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public cancelTimer(timerId: string, options?: any) {
        return LiveTvApiFp(this.configuration).cancelTimer(timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a live tv series timer.
     * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public createSeriesTimer(seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any) {
        return LiveTvApiFp(this.configuration).createSeriesTimer(seriesTimerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a live tv timer.
     * @param {TimerInfoDto} [timerInfoDto] New timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public createTimer(timerInfoDto?: TimerInfoDto, options?: any) {
        return LiveTvApiFp(this.configuration).createTimer(timerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete listing provider.
     * @param {string} [id] Listing provider id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteListingProvider(id?: string, options?: any) {
        return LiveTvApiFp(this.configuration).deleteListingProvider(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a live tv recording.
     * @param {string} recordingId Recording id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteRecording(recordingId: string, options?: any) {
        return LiveTvApiFp(this.configuration).deleteRecording(recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a tuner host.
     * @param {string} [id] Tuner host id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteTunerHost(id?: string, options?: any) {
        return LiveTvApiFp(this.configuration).deleteTunerHost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Discover tuners.
     * @param {boolean} [newDevicesOnly] Only discover new tuners.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public discoverTuners(newDevicesOnly?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).discoverTuners(newDevicesOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv channel.
     * @param {string} channelId Channel id.
     * @param {string} [userId] Optional. Attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getChannel(channelId: string, userId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getChannel(channelId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel mapping options.
     * @param {string} [providerId] Provider id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getChannelMappingOptions(providerId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getChannelMappingOptions(providerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets default listings provider info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getDefaultListingProvider(options?: any) {
        return LiveTvApiFp(this.configuration).getDefaultListingProvider(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the default values for a new timer.
     * @param {string} [programId] Optional. To attach default values based on a program.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getDefaultTimer(programId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getDefaultTimer(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get guid info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getGuideInfo(options?: any) {
        return LiveTvApiFp(this.configuration).getGuideInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available lineups.
     * @param {string} [id] Provider id.
     * @param {string} [type] Provider type.
     * @param {string} [location] Location.
     * @param {string} [country] Country.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLineups(id?: string, type?: string, location?: string, country?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getLineups(id, type, location, country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv recording stream.
     * @param {string} recordingId Recording id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveRecordingFile(recordingId: string, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveRecordingFile(recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv channel stream.
     * @param {string} streamId Stream id.
     * @param {string} container Container type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveStreamFile(streamId: string, container: string, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveStreamFile(streamId, container, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv channels.
     * @param {ChannelType} [type] Optional. Filter by channel type.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
     * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
     * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] \&quot;Optional. The image types to include in the output.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {string} [sortBy] Optional. Key to sort by.
     * @param {SortOrder} [sortOrder] Optional. Sort order.
     * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
     * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, sortBy?: string, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvInfo(options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv epgs.
     * @param {string} [channelIds] The channels to return guide information for.
     * @param {string} [userId] Optional. Filter by user id.
     * @param {string} [minStartDate] Optional. The minimum premiere start date.
     * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
     * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
     * @param {string} [maxStartDate] Optional. The maximum premiere start date.
     * @param {string} [minEndDate] Optional. The minimum premiere end date.
     * @param {string} [maxEndDate] Optional. The maximum premiere end date.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
     * @param {string} [sortOrder] Sort Order - Ascending,Descending.
     * @param {string} [genres] The genres to return guide information for.
     * @param {string} [genreIds] The genre ids to return guide information for.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {string} [seriesTimerId] Optional. Filter by series timer id.
     * @param {string} [librarySeriesId] Optional. Filter by library series id.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvPrograms(channelIds?: string, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genres?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: string, enableTotalRecordCount?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv program.
     * @param {string} programId Program id.
     * @param {string} [userId] Optional. Attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getProgram(programId: string, userId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getProgram(programId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv epgs.
     * @param {GetProgramsDto} [getProgramsDto] Request body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getPrograms(getProgramsDto?: GetProgramsDto, options?: any) {
        return LiveTvApiFp(this.configuration).getPrograms(getProgramsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets recommended live tv epgs.
     * @param {string} [userId] Optional. filter by user id.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
     * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [genreIds] The genres to return guide information for.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {boolean} [enableUserData] Optional. include user data.
     * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getRecommendedPrograms(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv recording.
     * @param {string} recordingId Recording id.
     * @param {string} [userId] Optional. Attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecording(recordingId: string, userId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getRecording(recordingId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets recording folders.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingFolders(userId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingFolders(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recording group.
     * @param {string} groupId Group id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingGroup(groupId: string, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recording groups.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingGroups(userId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingGroups(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recordings.
     * @param {string} [channelId] Optional. Filter by channel id.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {RecordingStatus} [status] Optional. Filter by recording status.
     * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
     * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {boolean} [isMovie] Optional. Filter for movies.
     * @param {boolean} [isSeries] Optional. Filter for series.
     * @param {boolean} [isKids] Optional. Filter for kids.
     * @param {boolean} [isSports] Optional. Filter for sports.
     * @param {boolean} [isNews] Optional. Filter for news.
     * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
     * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recording series.
     * @param {string} [channelId] Optional. Filter by channel id.
     * @param {string} [userId] Optional. Filter by user and attach user data.
     * @param {string} [groupId] Optional. Filter by recording group.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {RecordingStatus} [status] Optional. Filter by recording status.
     * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
     * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available countries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSchedulesDirectCountries(options?: any) {
        return LiveTvApiFp(this.configuration).getSchedulesDirectCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv series timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSeriesTimer(timerId: string, options?: any) {
        return LiveTvApiFp(this.configuration).getSeriesTimer(timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv series timers.
     * @param {string} [sortBy] Optional. Sort by SortName or Priority.
     * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any) {
        return LiveTvApiFp(this.configuration).getSeriesTimers(sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a timer.
     * @param {string} timerId Timer id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTimer(timerId: string, options?: any) {
        return LiveTvApiFp(this.configuration).getTimer(timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the live tv timers.
     * @param {string} [channelId] Optional. Filter by channel id.
     * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
     * @param {boolean} [isActive] Optional. Filter by timers that are active.
     * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any) {
        return LiveTvApiFp(this.configuration).getTimers(channelId, seriesTimerId, isActive, isScheduled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tuner host types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTunerHostTypes(options?: any) {
        return LiveTvApiFp(this.configuration).getTunerHostTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resets a tv tuner.
     * @param {string} tunerId Tuner id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public resetTuner(tunerId: string, options?: any) {
        return LiveTvApiFp(this.configuration).resetTuner(tunerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set channel mappings.
     * @param {string} [providerId] Provider id.
     * @param {string} [tunerChannelId] Tuner channel id.
     * @param {string} [providerChannelId] Provider channel id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public setChannelMapping(providerId?: string, tunerChannelId?: string, providerChannelId?: string, options?: any) {
        return LiveTvApiFp(this.configuration).setChannelMapping(providerId, tunerChannelId, providerChannelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a live tv series timer.
     * @param {string} timerId Timer id.
     * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public updateSeriesTimer(timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any) {
        return LiveTvApiFp(this.configuration).updateSeriesTimer(timerId, seriesTimerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a live tv timer.
     * @param {string} timerId Timer id.
     * @param {TimerInfoDto} [timerInfoDto] New timer info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public updateTimer(timerId: string, timerInfoDto?: TimerInfoDto, options?: any) {
        return LiveTvApiFp(this.configuration).updateTimer(timerId, timerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LocalizationApi - axios parameter creator
 * @export
 */
export const LocalizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets known countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/Countries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets known cultures.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCultures: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/Cultures`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets localization options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalizationOptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/Options`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets known parental ratings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentalRatings: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/ParentalRatings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocalizationApi - functional programming interface
 * @export
 */
export const LocalizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets known countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountryInfo>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getCountries(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets known cultures.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCultures(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CultureDto>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getCultures(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets localization options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalizationOptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LocalizationOption>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getLocalizationOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets known parental ratings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentalRatings(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParentalRating>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getParentalRatings(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LocalizationApi - factory interface
 * @export
 */
export const LocalizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets known countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(options?: any): AxiosPromise<Array<CountryInfo>> {
            return LocalizationApiFp(configuration).getCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets known cultures.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCultures(options?: any): AxiosPromise<Array<CultureDto>> {
            return LocalizationApiFp(configuration).getCultures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets localization options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalizationOptions(options?: any): AxiosPromise<Array<LocalizationOption>> {
            return LocalizationApiFp(configuration).getLocalizationOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets known parental ratings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentalRatings(options?: any): AxiosPromise<Array<ParentalRating>> {
            return LocalizationApiFp(configuration).getParentalRatings(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocalizationApi - object-oriented interface
 * @export
 * @class LocalizationApi
 * @extends {BaseAPI}
 */
export class LocalizationApi extends BaseAPI {
    /**
     * 
     * @summary Gets known countries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getCountries(options?: any) {
        return LocalizationApiFp(this.configuration).getCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets known cultures.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getCultures(options?: any) {
        return LocalizationApiFp(this.configuration).getCultures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets localization options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getLocalizationOptions(options?: any) {
        return LocalizationApiFp(this.configuration).getLocalizationOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets known parental ratings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getParentalRatings(options?: any) {
        return LocalizationApiFp(this.configuration).getParentalRatings(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaInfoApi - axios parameter creator
 * @export
 */
export const MediaInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Closes a media source.
         * @param {string} liveStreamId The livestream id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeLiveStream: async (liveStreamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveStreamId' is not null or undefined
            if (liveStreamId === null || liveStreamId === undefined) {
                throw new RequiredError('liveStreamId','Required parameter liveStreamId was null or undefined when calling closeLiveStream.');
            }
            const localVarPath = `/LiveStreams/Close`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tests the network with a request with the size of the bitrate.
         * @param {number} [size] The bitrate. Defaults to 102400.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBitrateTestBytes: async (size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Playback/BitrateTest`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybackInfo: async (itemId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getPlaybackInfo.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getPlaybackInfo.');
            }
            const localVarPath = `/Items/{itemId}/PlaybackInfo`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] The user id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [mediaSourceId] The media source id.
         * @param {string} [liveStreamId] The livestream id.
         * @param {boolean} [autoOpenLiveStream] Whether to auto open the livestream.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {boolean} [enableTranscoding] Whether to enable transcoding. Default: true.
         * @param {boolean} [allowVideoStreamCopy] Whether to allow to copy the video stream. Default: true.
         * @param {boolean} [allowAudioStreamCopy] Whether to allow to copy the audio stream. Default: true.
         * @param {DeviceProfileDto} [deviceProfileDto] The device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostedPlaybackInfo: async (itemId: string, userId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, mediaSourceId?: string, liveStreamId?: string, autoOpenLiveStream?: boolean, enableDirectPlay?: boolean, enableDirectStream?: boolean, enableTranscoding?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, deviceProfileDto?: DeviceProfileDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getPostedPlaybackInfo.');
            }
            const localVarPath = `/Items/{itemId}/PlaybackInfo`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (autoOpenLiveStream !== undefined) {
                localVarQueryParameter['autoOpenLiveStream'] = autoOpenLiveStream;
            }

            if (enableDirectPlay !== undefined) {
                localVarQueryParameter['enableDirectPlay'] = enableDirectPlay;
            }

            if (enableDirectStream !== undefined) {
                localVarQueryParameter['enableDirectStream'] = enableDirectStream;
            }

            if (enableTranscoding !== undefined) {
                localVarQueryParameter['enableTranscoding'] = enableTranscoding;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceProfileDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceProfileDto !== undefined ? deviceProfileDto : {}) : (deviceProfileDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Opens a media source.
         * @param {string} [openToken] The open token.
         * @param {string} [userId] The user id.
         * @param {string} [playSessionId] The play session id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [itemId] The item id.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {OpenLiveStreamDto} [openLiveStreamDto] The open live stream dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openLiveStream: async (openToken?: string, userId?: string, playSessionId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, itemId?: string, enableDirectPlay?: boolean, enableDirectStream?: boolean, openLiveStreamDto?: OpenLiveStreamDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveStreams/Open`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (openToken !== undefined) {
                localVarQueryParameter['openToken'] = openToken;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }

            if (enableDirectPlay !== undefined) {
                localVarQueryParameter['enableDirectPlay'] = enableDirectPlay;
            }

            if (enableDirectStream !== undefined) {
                localVarQueryParameter['enableDirectStream'] = enableDirectStream;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof openLiveStreamDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(openLiveStreamDto !== undefined ? openLiveStreamDto : {}) : (openLiveStreamDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaInfoApi - functional programming interface
 * @export
 */
export const MediaInfoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Closes a media source.
         * @param {string} liveStreamId The livestream id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeLiveStream(liveStreamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).closeLiveStream(liveStreamId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Tests the network with a request with the size of the bitrate.
         * @param {number} [size] The bitrate. Defaults to 102400.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBitrateTestBytes(size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).getBitrateTestBytes(size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaybackInfo(itemId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybackInfoResponse>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).getPlaybackInfo(itemId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] The user id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [mediaSourceId] The media source id.
         * @param {string} [liveStreamId] The livestream id.
         * @param {boolean} [autoOpenLiveStream] Whether to auto open the livestream.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {boolean} [enableTranscoding] Whether to enable transcoding. Default: true.
         * @param {boolean} [allowVideoStreamCopy] Whether to allow to copy the video stream. Default: true.
         * @param {boolean} [allowAudioStreamCopy] Whether to allow to copy the audio stream. Default: true.
         * @param {DeviceProfileDto} [deviceProfileDto] The device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostedPlaybackInfo(itemId: string, userId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, mediaSourceId?: string, liveStreamId?: string, autoOpenLiveStream?: boolean, enableDirectPlay?: boolean, enableDirectStream?: boolean, enableTranscoding?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, deviceProfileDto?: DeviceProfileDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybackInfoResponse>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).getPostedPlaybackInfo(itemId, userId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, mediaSourceId, liveStreamId, autoOpenLiveStream, enableDirectPlay, enableDirectStream, enableTranscoding, allowVideoStreamCopy, allowAudioStreamCopy, deviceProfileDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Opens a media source.
         * @param {string} [openToken] The open token.
         * @param {string} [userId] The user id.
         * @param {string} [playSessionId] The play session id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [itemId] The item id.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {OpenLiveStreamDto} [openLiveStreamDto] The open live stream dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openLiveStream(openToken?: string, userId?: string, playSessionId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, itemId?: string, enableDirectPlay?: boolean, enableDirectStream?: boolean, openLiveStreamDto?: OpenLiveStreamDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveStreamResponse>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).openLiveStream(openToken, userId, playSessionId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, itemId, enableDirectPlay, enableDirectStream, openLiveStreamDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MediaInfoApi - factory interface
 * @export
 */
export const MediaInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Closes a media source.
         * @param {string} liveStreamId The livestream id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeLiveStream(liveStreamId: string, options?: any): AxiosPromise<void> {
            return MediaInfoApiFp(configuration).closeLiveStream(liveStreamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tests the network with a request with the size of the bitrate.
         * @param {number} [size] The bitrate. Defaults to 102400.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBitrateTestBytes(size?: number, options?: any): AxiosPromise<any> {
            return MediaInfoApiFp(configuration).getBitrateTestBytes(size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybackInfo(itemId: string, userId: string, options?: any): AxiosPromise<PlaybackInfoResponse> {
            return MediaInfoApiFp(configuration).getPlaybackInfo(itemId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] The user id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [mediaSourceId] The media source id.
         * @param {string} [liveStreamId] The livestream id.
         * @param {boolean} [autoOpenLiveStream] Whether to auto open the livestream.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {boolean} [enableTranscoding] Whether to enable transcoding. Default: true.
         * @param {boolean} [allowVideoStreamCopy] Whether to allow to copy the video stream. Default: true.
         * @param {boolean} [allowAudioStreamCopy] Whether to allow to copy the audio stream. Default: true.
         * @param {DeviceProfileDto} [deviceProfileDto] The device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostedPlaybackInfo(itemId: string, userId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, mediaSourceId?: string, liveStreamId?: string, autoOpenLiveStream?: boolean, enableDirectPlay?: boolean, enableDirectStream?: boolean, enableTranscoding?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, deviceProfileDto?: DeviceProfileDto, options?: any): AxiosPromise<PlaybackInfoResponse> {
            return MediaInfoApiFp(configuration).getPostedPlaybackInfo(itemId, userId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, mediaSourceId, liveStreamId, autoOpenLiveStream, enableDirectPlay, enableDirectStream, enableTranscoding, allowVideoStreamCopy, allowAudioStreamCopy, deviceProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Opens a media source.
         * @param {string} [openToken] The open token.
         * @param {string} [userId] The user id.
         * @param {string} [playSessionId] The play session id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [itemId] The item id.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {OpenLiveStreamDto} [openLiveStreamDto] The open live stream dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openLiveStream(openToken?: string, userId?: string, playSessionId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, itemId?: string, enableDirectPlay?: boolean, enableDirectStream?: boolean, openLiveStreamDto?: OpenLiveStreamDto, options?: any): AxiosPromise<LiveStreamResponse> {
            return MediaInfoApiFp(configuration).openLiveStream(openToken, userId, playSessionId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, itemId, enableDirectPlay, enableDirectStream, openLiveStreamDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaInfoApi - object-oriented interface
 * @export
 * @class MediaInfoApi
 * @extends {BaseAPI}
 */
export class MediaInfoApi extends BaseAPI {
    /**
     * 
     * @summary Closes a media source.
     * @param {string} liveStreamId The livestream id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public closeLiveStream(liveStreamId: string, options?: any) {
        return MediaInfoApiFp(this.configuration).closeLiveStream(liveStreamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tests the network with a request with the size of the bitrate.
     * @param {number} [size] The bitrate. Defaults to 102400.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public getBitrateTestBytes(size?: number, options?: any) {
        return MediaInfoApiFp(this.configuration).getBitrateTestBytes(size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live playback media info for an item.
     * @param {string} itemId The item id.
     * @param {string} userId The user id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public getPlaybackInfo(itemId: string, userId: string, options?: any) {
        return MediaInfoApiFp(this.configuration).getPlaybackInfo(itemId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live playback media info for an item.
     * @param {string} itemId The item id.
     * @param {string} [userId] The user id.
     * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
     * @param {number} [startTimeTicks] The start time in ticks.
     * @param {number} [audioStreamIndex] The audio stream index.
     * @param {number} [subtitleStreamIndex] The subtitle stream index.
     * @param {number} [maxAudioChannels] The maximum number of audio channels.
     * @param {string} [mediaSourceId] The media source id.
     * @param {string} [liveStreamId] The livestream id.
     * @param {boolean} [autoOpenLiveStream] Whether to auto open the livestream.
     * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
     * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
     * @param {boolean} [enableTranscoding] Whether to enable transcoding. Default: true.
     * @param {boolean} [allowVideoStreamCopy] Whether to allow to copy the video stream. Default: true.
     * @param {boolean} [allowAudioStreamCopy] Whether to allow to copy the audio stream. Default: true.
     * @param {DeviceProfileDto} [deviceProfileDto] The device profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public getPostedPlaybackInfo(itemId: string, userId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, mediaSourceId?: string, liveStreamId?: string, autoOpenLiveStream?: boolean, enableDirectPlay?: boolean, enableDirectStream?: boolean, enableTranscoding?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, deviceProfileDto?: DeviceProfileDto, options?: any) {
        return MediaInfoApiFp(this.configuration).getPostedPlaybackInfo(itemId, userId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, mediaSourceId, liveStreamId, autoOpenLiveStream, enableDirectPlay, enableDirectStream, enableTranscoding, allowVideoStreamCopy, allowAudioStreamCopy, deviceProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Opens a media source.
     * @param {string} [openToken] The open token.
     * @param {string} [userId] The user id.
     * @param {string} [playSessionId] The play session id.
     * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
     * @param {number} [startTimeTicks] The start time in ticks.
     * @param {number} [audioStreamIndex] The audio stream index.
     * @param {number} [subtitleStreamIndex] The subtitle stream index.
     * @param {number} [maxAudioChannels] The maximum number of audio channels.
     * @param {string} [itemId] The item id.
     * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
     * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
     * @param {OpenLiveStreamDto} [openLiveStreamDto] The open live stream dto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public openLiveStream(openToken?: string, userId?: string, playSessionId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, itemId?: string, enableDirectPlay?: boolean, enableDirectStream?: boolean, openLiveStreamDto?: OpenLiveStreamDto, options?: any) {
        return MediaInfoApiFp(this.configuration).openLiveStream(openToken, userId, playSessionId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, itemId, enableDirectPlay, enableDirectStream, openLiveStreamDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MoviesApi - axios parameter creator
 * @export
 */
export const MoviesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets movie recommendations.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. The fields to return.
         * @param {number} [categoryLimit] The max number of categories to return.
         * @param {number} [itemLimit] The max number of items to return per category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRecommendations: async (userId?: string, parentId?: string, fields?: string, categoryLimit?: number, itemLimit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Movies/Recommendations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (categoryLimit !== undefined) {
                localVarQueryParameter['categoryLimit'] = categoryLimit;
            }

            if (itemLimit !== undefined) {
                localVarQueryParameter['itemLimit'] = itemLimit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MoviesApi - functional programming interface
 * @export
 */
export const MoviesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets movie recommendations.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. The fields to return.
         * @param {number} [categoryLimit] The max number of categories to return.
         * @param {number} [itemLimit] The max number of items to return per category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMovieRecommendations(userId?: string, parentId?: string, fields?: string, categoryLimit?: number, itemLimit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecommendationDto>>> {
            const localVarAxiosArgs = await MoviesApiAxiosParamCreator(configuration).getMovieRecommendations(userId, parentId, fields, categoryLimit, itemLimit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MoviesApi - factory interface
 * @export
 */
export const MoviesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets movie recommendations.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. The fields to return.
         * @param {number} [categoryLimit] The max number of categories to return.
         * @param {number} [itemLimit] The max number of items to return per category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRecommendations(userId?: string, parentId?: string, fields?: string, categoryLimit?: number, itemLimit?: number, options?: any): AxiosPromise<Array<RecommendationDto>> {
            return MoviesApiFp(configuration).getMovieRecommendations(userId, parentId, fields, categoryLimit, itemLimit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MoviesApi - object-oriented interface
 * @export
 * @class MoviesApi
 * @extends {BaseAPI}
 */
export class MoviesApi extends BaseAPI {
    /**
     * 
     * @summary Gets movie recommendations.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. The fields to return.
     * @param {number} [categoryLimit] The max number of categories to return.
     * @param {number} [itemLimit] The max number of items to return per category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoviesApi
     */
    public getMovieRecommendations(userId?: string, parentId?: string, fields?: string, categoryLimit?: number, itemLimit?: number, options?: any) {
        return MoviesApiFp(this.configuration).getMovieRecommendations(userId, parentId, fields, categoryLimit, itemLimit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MusicGenresApi - axios parameter creator
 * @export
 */
export const MusicGenresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a music genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenre: async (genreName: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'genreName' is not null or undefined
            if (genreName === null || genreName === undefined) {
                throw new RequiredError('genreName','Required parameter genreName was null or undefined when calling getMusicGenre.');
            }
            const localVarPath = `/MusicGenres/{genreName}`
                .replace(`{${"genreName"}}`, encodeURIComponent(String(genreName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all music genres from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenres: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/MusicGenres`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MusicGenresApi - functional programming interface
 * @export
 */
export const MusicGenresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a music genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicGenre(genreName: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await MusicGenresApiAxiosParamCreator(configuration).getMusicGenre(genreName, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all music genres from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicGenres(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await MusicGenresApiAxiosParamCreator(configuration).getMusicGenres(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MusicGenresApi - factory interface
 * @export
 */
export const MusicGenresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a music genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenre(genreName: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return MusicGenresApiFp(configuration).getMusicGenre(genreName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all music genres from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenres(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return MusicGenresApiFp(configuration).getMusicGenres(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MusicGenresApi - object-oriented interface
 * @export
 * @class MusicGenresApi
 * @extends {BaseAPI}
 */
export class MusicGenresApi extends BaseAPI {
    /**
     * 
     * @summary Gets a music genre, by name.
     * @param {string} genreName The genre name.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicGenresApi
     */
    public getMusicGenre(genreName: string, userId?: string, options?: any) {
        return MusicGenresApiFp(this.configuration).getMusicGenre(genreName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all music genres from a given item, folder, or the entire library.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [searchTerm] The search term.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
     * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
     * @param {boolean} [enableUserData] Optional, include user data.
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
     * @param {string} [userId] User id.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {boolean} [enableImages] Optional, include image information in output.
     * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicGenresApi
     */
    public getMusicGenres(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return MusicGenresApiFp(this.configuration).getMusicGenres(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Sends a notification to all admins.
         * @param {string} [url] The URL of the notification.
         * @param {NotificationLevel} [level] The level of the notification.
         * @param {string} [name] The name of the notification.
         * @param {string} [description] The description of the notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdminNotification: async (url?: string, level?: NotificationLevel, name?: string, description?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Notifications/Admin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets notification services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationServices: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Notifications/Services`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets notification types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Notifications/Types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a user\'s notifications.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getNotifications.');
            }
            const localVarPath = `/Notifications/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a user\'s notification summary.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsSummary: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getNotificationsSummary.');
            }
            const localVarPath = `/Notifications/{userId}/Summary`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets notifications as read.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRead: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setRead.');
            }
            const localVarPath = `/Notifications/{userId}/Read`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets notifications as unread.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUnread: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setUnread.');
            }
            const localVarPath = `/Notifications/{userId}/Unread`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Sends a notification to all admins.
         * @param {string} [url] The URL of the notification.
         * @param {NotificationLevel} [level] The level of the notification.
         * @param {string} [name] The name of the notification.
         * @param {string} [description] The description of the notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdminNotification(url?: string, level?: NotificationLevel, name?: string, description?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).createAdminNotification(url, level, name, description, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets notification services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationServices(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotificationServices(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets notification types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationTypeInfo>>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotificationTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a user\'s notifications.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationResultDto>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotifications(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a user\'s notification summary.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationsSummary(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsSummaryDto>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotificationsSummary(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets notifications as read.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRead(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).setRead(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets notifications as unread.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUnread(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).setUnread(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Sends a notification to all admins.
         * @param {string} [url] The URL of the notification.
         * @param {NotificationLevel} [level] The level of the notification.
         * @param {string} [name] The name of the notification.
         * @param {string} [description] The description of the notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdminNotification(url?: string, level?: NotificationLevel, name?: string, description?: string, options?: any): AxiosPromise<void> {
            return NotificationsApiFp(configuration).createAdminNotification(url, level, name, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets notification services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationServices(options?: any): AxiosPromise<Array<NameIdPair>> {
            return NotificationsApiFp(configuration).getNotificationServices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets notification types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTypes(options?: any): AxiosPromise<Array<NotificationTypeInfo>> {
            return NotificationsApiFp(configuration).getNotificationTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a user\'s notifications.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(userId: string, options?: any): AxiosPromise<NotificationResultDto> {
            return NotificationsApiFp(configuration).getNotifications(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a user\'s notification summary.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsSummary(userId: string, options?: any): AxiosPromise<NotificationsSummaryDto> {
            return NotificationsApiFp(configuration).getNotificationsSummary(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets notifications as read.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRead(userId: string, options?: any): AxiosPromise<void> {
            return NotificationsApiFp(configuration).setRead(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets notifications as unread.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUnread(userId: string, options?: any): AxiosPromise<void> {
            return NotificationsApiFp(configuration).setUnread(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @summary Sends a notification to all admins.
     * @param {string} [url] The URL of the notification.
     * @param {NotificationLevel} [level] The level of the notification.
     * @param {string} [name] The name of the notification.
     * @param {string} [description] The description of the notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public createAdminNotification(url?: string, level?: NotificationLevel, name?: string, description?: string, options?: any) {
        return NotificationsApiFp(this.configuration).createAdminNotification(url, level, name, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets notification services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotificationServices(options?: any) {
        return NotificationsApiFp(this.configuration).getNotificationServices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets notification types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotificationTypes(options?: any) {
        return NotificationsApiFp(this.configuration).getNotificationTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a user\'s notifications.
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotifications(userId: string, options?: any) {
        return NotificationsApiFp(this.configuration).getNotifications(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a user\'s notification summary.
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotificationsSummary(userId: string, options?: any) {
        return NotificationsApiFp(this.configuration).getNotificationsSummary(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets notifications as read.
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public setRead(userId: string, options?: any) {
        return NotificationsApiFp(this.configuration).setRead(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets notifications as unread.
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public setUnread(userId: string, options?: any) {
        return NotificationsApiFp(this.configuration).setUnread(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PackageApi - axios parameter creator
 * @export
 */
export const PackageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a package installation.
         * @param {string} packageId Installation Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPackageInstallation: async (packageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling cancelPackageInstallation.');
            }
            const localVarPath = `/Packages/Installing/{packageId}`
                .replace(`{${"packageId"}}`, encodeURIComponent(String(packageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a package by name or assembly GUID.
         * @param {string} name The name of the package.
         * @param {string} [assemblyGuid] The GUID of the associated assembly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageInfo: async (name: string, assemblyGuid?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPackageInfo.');
            }
            const localVarPath = `/Packages/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (assemblyGuid !== undefined) {
                localVarQueryParameter['assemblyGuid'] = assemblyGuid;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available packages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Packages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Repositories`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Installs a package.
         * @param {string} name Package name.
         * @param {string} [assemblyGuid] GUID of the associated assembly.
         * @param {string} [version] Optional version. Defaults to latest version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installPackage: async (name: string, assemblyGuid?: string, version?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling installPackage.');
            }
            const localVarPath = `/Packages/Installed/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (assemblyGuid !== undefined) {
                localVarQueryParameter['assemblyGuid'] = assemblyGuid;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the enabled and existing package repositories.
         * @param {Array<RepositoryInfo>} [repositoryInfo] The list of package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRepositories: async (repositoryInfo?: Array<RepositoryInfo>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Repositories`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof repositoryInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(repositoryInfo !== undefined ? repositoryInfo : {}) : (repositoryInfo || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackageApi - functional programming interface
 * @export
 */
export const PackageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a package installation.
         * @param {string} packageId Installation Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPackageInstallation(packageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).cancelPackageInstallation(packageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a package by name or assembly GUID.
         * @param {string} name The name of the package.
         * @param {string} [assemblyGuid] The GUID of the associated assembly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackageInfo(name: string, assemblyGuid?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageInfo>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).getPackageInfo(name, assemblyGuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available packages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PackageInfo>>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).getPackages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryInfo>>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).getRepositories(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Installs a package.
         * @param {string} name Package name.
         * @param {string} [assemblyGuid] GUID of the associated assembly.
         * @param {string} [version] Optional version. Defaults to latest version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installPackage(name: string, assemblyGuid?: string, version?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).installPackage(name, assemblyGuid, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the enabled and existing package repositories.
         * @param {Array<RepositoryInfo>} [repositoryInfo] The list of package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRepositories(repositoryInfo?: Array<RepositoryInfo>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).setRepositories(repositoryInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PackageApi - factory interface
 * @export
 */
export const PackageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Cancels a package installation.
         * @param {string} packageId Installation Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPackageInstallation(packageId: string, options?: any): AxiosPromise<void> {
            return PackageApiFp(configuration).cancelPackageInstallation(packageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a package by name or assembly GUID.
         * @param {string} name The name of the package.
         * @param {string} [assemblyGuid] The GUID of the associated assembly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageInfo(name: string, assemblyGuid?: string, options?: any): AxiosPromise<PackageInfo> {
            return PackageApiFp(configuration).getPackageInfo(name, assemblyGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available packages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages(options?: any): AxiosPromise<Array<PackageInfo>> {
            return PackageApiFp(configuration).getPackages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositories(options?: any): AxiosPromise<Array<RepositoryInfo>> {
            return PackageApiFp(configuration).getRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Installs a package.
         * @param {string} name Package name.
         * @param {string} [assemblyGuid] GUID of the associated assembly.
         * @param {string} [version] Optional version. Defaults to latest version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installPackage(name: string, assemblyGuid?: string, version?: string, options?: any): AxiosPromise<void> {
            return PackageApiFp(configuration).installPackage(name, assemblyGuid, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the enabled and existing package repositories.
         * @param {Array<RepositoryInfo>} [repositoryInfo] The list of package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRepositories(repositoryInfo?: Array<RepositoryInfo>, options?: any): AxiosPromise<void> {
            return PackageApiFp(configuration).setRepositories(repositoryInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PackageApi - object-oriented interface
 * @export
 * @class PackageApi
 * @extends {BaseAPI}
 */
export class PackageApi extends BaseAPI {
    /**
     * 
     * @summary Cancels a package installation.
     * @param {string} packageId Installation Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public cancelPackageInstallation(packageId: string, options?: any) {
        return PackageApiFp(this.configuration).cancelPackageInstallation(packageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a package by name or assembly GUID.
     * @param {string} name The name of the package.
     * @param {string} [assemblyGuid] The GUID of the associated assembly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getPackageInfo(name: string, assemblyGuid?: string, options?: any) {
        return PackageApiFp(this.configuration).getPackageInfo(name, assemblyGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available packages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getPackages(options?: any) {
        return PackageApiFp(this.configuration).getPackages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all package repositories.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRepositories(options?: any) {
        return PackageApiFp(this.configuration).getRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Installs a package.
     * @param {string} name Package name.
     * @param {string} [assemblyGuid] GUID of the associated assembly.
     * @param {string} [version] Optional version. Defaults to latest version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public installPackage(name: string, assemblyGuid?: string, version?: string, options?: any) {
        return PackageApiFp(this.configuration).installPackage(name, assemblyGuid, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the enabled and existing package repositories.
     * @param {Array<RepositoryInfo>} [repositoryInfo] The list of package repositories.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public setRepositories(repositoryInfo?: Array<RepositoryInfo>, options?: any) {
        return PackageApiFp(this.configuration).setRepositories(repositoryInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonsApi - axios parameter creator
 * @export
 */
export const PersonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get person by name.
         * @param {string} name Person name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (name: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPerson.');
            }
            const localVarPath = `/Persons/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all persons from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Persons`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonsApi - functional programming interface
 * @export
 */
export const PersonsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get person by name.
         * @param {string} name Person name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(name: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await PersonsApiAxiosParamCreator(configuration).getPerson(name, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all persons from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersons(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await PersonsApiAxiosParamCreator(configuration).getPersons(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PersonsApi - factory interface
 * @export
 */
export const PersonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get person by name.
         * @param {string} name Person name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(name: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return PersonsApiFp(configuration).getPerson(name, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all persons from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return PersonsApiFp(configuration).getPersons(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonsApi - object-oriented interface
 * @export
 * @class PersonsApi
 * @extends {BaseAPI}
 */
export class PersonsApi extends BaseAPI {
    /**
     * 
     * @summary Get person by name.
     * @param {string} name Person name.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPerson(name: string, userId?: string, options?: any) {
        return PersonsApiFp(this.configuration).getPerson(name, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all persons from a given item, folder, or the entire library.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [searchTerm] The search term.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
     * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
     * @param {boolean} [enableUserData] Optional, include user data.
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
     * @param {string} [userId] User id.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {boolean} [enableImages] Optional, include image information in output.
     * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersons(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return PersonsApiFp(this.configuration).getPersons(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaylistsApi - axios parameter creator
 * @export
 */
export const PlaylistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds items to a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [ids] Item id, comma delimited.
         * @param {string} [userId] The userId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPlaylist: async (playlistId: string, ids?: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling addToPlaylist.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new playlist.
         * @param {CreatePlaylistDto} createPlaylistDto The create playlist payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: async (createPlaylistDto: CreatePlaylistDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPlaylistDto' is not null or undefined
            if (createPlaylistDto === null || createPlaylistDto === undefined) {
                throw new RequiredError('createPlaylistDto','Required parameter createPlaylistDto was null or undefined when calling createPlaylist.');
            }
            const localVarPath = `/Playlists`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createPlaylistDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createPlaylistDto !== undefined ? createPlaylistDto : {}) : (createPlaylistDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the original items of a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} userId User id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistItems: async (playlistId: string, userId: string, startIndex?: number, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getPlaylistItems.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getPlaylistItems.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Moves a playlist item.
         * @param {string} playlistId The playlist id.
         * @param {string} itemId The item id.
         * @param {number} newIndex The new index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveItem: async (playlistId: string, itemId: string, newIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling moveItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling moveItem.');
            }
            // verify required parameter 'newIndex' is not null or undefined
            if (newIndex === null || newIndex === undefined) {
                throw new RequiredError('newIndex','Required parameter newIndex was null or undefined when calling moveItem.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items/{itemId}/Move/{newIndex}`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"newIndex"}}`, encodeURIComponent(String(newIndex)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes items from a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [entryIds] The item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromPlaylist: async (playlistId: string, entryIds?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling removeFromPlaylist.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (entryIds !== undefined) {
                localVarQueryParameter['entryIds'] = entryIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistsApi - functional programming interface
 * @export
 */
export const PlaylistsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds items to a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [ids] Item id, comma delimited.
         * @param {string} [userId] The userId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToPlaylist(playlistId: string, ids?: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).addToPlaylist(playlistId, ids, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new playlist.
         * @param {CreatePlaylistDto} createPlaylistDto The create playlist payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaylist(createPlaylistDto: CreatePlaylistDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistCreationResult>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).createPlaylist(createPlaylistDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the original items of a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} userId User id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylistItems(playlistId: string, userId: string, startIndex?: number, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).getPlaylistItems(playlistId, userId, startIndex, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Moves a playlist item.
         * @param {string} playlistId The playlist id.
         * @param {string} itemId The item id.
         * @param {number} newIndex The new index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveItem(playlistId: string, itemId: string, newIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).moveItem(playlistId, itemId, newIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes items from a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [entryIds] The item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromPlaylist(playlistId: string, entryIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).removeFromPlaylist(playlistId, entryIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PlaylistsApi - factory interface
 * @export
 */
export const PlaylistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds items to a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [ids] Item id, comma delimited.
         * @param {string} [userId] The userId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPlaylist(playlistId: string, ids?: string, userId?: string, options?: any): AxiosPromise<void> {
            return PlaylistsApiFp(configuration).addToPlaylist(playlistId, ids, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new playlist.
         * @param {CreatePlaylistDto} createPlaylistDto The create playlist payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist(createPlaylistDto: CreatePlaylistDto, options?: any): AxiosPromise<PlaylistCreationResult> {
            return PlaylistsApiFp(configuration).createPlaylist(createPlaylistDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the original items of a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} userId User id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistItems(playlistId: string, userId: string, startIndex?: number, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return PlaylistsApiFp(configuration).getPlaylistItems(playlistId, userId, startIndex, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Moves a playlist item.
         * @param {string} playlistId The playlist id.
         * @param {string} itemId The item id.
         * @param {number} newIndex The new index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveItem(playlistId: string, itemId: string, newIndex: number, options?: any): AxiosPromise<void> {
            return PlaylistsApiFp(configuration).moveItem(playlistId, itemId, newIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes items from a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [entryIds] The item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromPlaylist(playlistId: string, entryIds?: string, options?: any): AxiosPromise<void> {
            return PlaylistsApiFp(configuration).removeFromPlaylist(playlistId, entryIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistsApi - object-oriented interface
 * @export
 * @class PlaylistsApi
 * @extends {BaseAPI}
 */
export class PlaylistsApi extends BaseAPI {
    /**
     * 
     * @summary Adds items to a playlist.
     * @param {string} playlistId The playlist id.
     * @param {string} [ids] Item id, comma delimited.
     * @param {string} [userId] The userId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public addToPlaylist(playlistId: string, ids?: string, userId?: string, options?: any) {
        return PlaylistsApiFp(this.configuration).addToPlaylist(playlistId, ids, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new playlist.
     * @param {CreatePlaylistDto} createPlaylistDto The create playlist payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public createPlaylist(createPlaylistDto: CreatePlaylistDto, options?: any) {
        return PlaylistsApiFp(this.configuration).createPlaylist(createPlaylistDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the original items of a playlist.
     * @param {string} playlistId The playlist id.
     * @param {string} userId User id.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getPlaylistItems(playlistId: string, userId: string, startIndex?: number, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any) {
        return PlaylistsApiFp(this.configuration).getPlaylistItems(playlistId, userId, startIndex, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Moves a playlist item.
     * @param {string} playlistId The playlist id.
     * @param {string} itemId The item id.
     * @param {number} newIndex The new index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public moveItem(playlistId: string, itemId: string, newIndex: number, options?: any) {
        return PlaylistsApiFp(this.configuration).moveItem(playlistId, itemId, newIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes items from a playlist.
     * @param {string} playlistId The playlist id.
     * @param {string} [entryIds] The item ids, comma delimited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public removeFromPlaylist(playlistId: string, entryIds?: string, options?: any) {
        return PlaylistsApiFp(this.configuration).removeFromPlaylist(playlistId, entryIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaystateApi - axios parameter creator
 * @export
 */
export const PlaystateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Marks an item as played for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [datePlayed] Optional. The date the item was played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markPlayedItem: async (userId: string, itemId: string, datePlayed?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling markPlayedItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling markPlayedItem.');
            }
            const localVarPath = `/Users/{userId}/PlayedItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (datePlayed !== undefined) {
                localVarQueryParameter['datePlayed'] = (datePlayed as any instanceof Date) ?
                    (datePlayed as any).toISOString() :
                    datePlayed;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Marks an item as unplayed for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUnplayedItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling markUnplayedItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling markUnplayedItem.');
            }
            const localVarPath = `/Users/{userId}/PlayedItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports a user\'s playback progress.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [volumeLevel] Scale of 0-100.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {RepeatMode} [repeatMode] The repeat mode.
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackProgress: async (userId: string, itemId: string, mediaSourceId?: string, positionTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, repeatMode?: RepeatMode, isPaused?: boolean, isMuted?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling onPlaybackProgress.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling onPlaybackProgress.');
            }
            const localVarPath = `/Users/{userId}/PlayingItems/{itemId}/Progress`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (volumeLevel !== undefined) {
                localVarQueryParameter['volumeLevel'] = volumeLevel;
            }

            if (playMethod !== undefined) {
                localVarQueryParameter['playMethod'] = playMethod;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (repeatMode !== undefined) {
                localVarQueryParameter['repeatMode'] = repeatMode;
            }

            if (isPaused !== undefined) {
                localVarQueryParameter['isPaused'] = isPaused;
            }

            if (isMuted !== undefined) {
                localVarQueryParameter['isMuted'] = isMuted;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that a user has begun playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {boolean} [canSeek] Indicates if the client can seek.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStart: async (userId: string, itemId: string, mediaSourceId?: string, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, canSeek?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling onPlaybackStart.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling onPlaybackStart.');
            }
            const localVarPath = `/Users/{userId}/PlayingItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (playMethod !== undefined) {
                localVarQueryParameter['playMethod'] = playMethod;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (canSeek !== undefined) {
                localVarQueryParameter['canSeek'] = canSeek;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that a user has stopped playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {string} [nextMediaType] The next media type that will play.
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStopped: async (userId: string, itemId: string, mediaSourceId?: string, nextMediaType?: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling onPlaybackStopped.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling onPlaybackStopped.');
            }
            const localVarPath = `/Users/{userId}/PlayingItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (nextMediaType !== undefined) {
                localVarQueryParameter['nextMediaType'] = nextMediaType;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pings a playback session.
         * @param {string} [playSessionId] Playback session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingPlaybackSession: async (playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing/Ping`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports playback progress within a session.
         * @param {PlaybackProgressInfo} [playbackProgressInfo] The playback progress info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackProgress: async (playbackProgressInfo?: PlaybackProgressInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing/Progress`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbackProgressInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbackProgressInfo !== undefined ? playbackProgressInfo : {}) : (playbackProgressInfo || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports playback has started within a session.
         * @param {PlaybackStartInfo} [playbackStartInfo] The playback start info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStart: async (playbackStartInfo?: PlaybackStartInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbackStartInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbackStartInfo !== undefined ? playbackStartInfo : {}) : (playbackStartInfo || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports playback has stopped within a session.
         * @param {PlaybackStopInfo} [playbackStopInfo] The playback stop info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStopped: async (playbackStopInfo?: PlaybackStopInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing/Stopped`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbackStopInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbackStopInfo !== undefined ? playbackStopInfo : {}) : (playbackStopInfo || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaystateApi - functional programming interface
 * @export
 */
export const PlaystateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Marks an item as played for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [datePlayed] Optional. The date the item was played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markPlayedItem(userId: string, itemId: string, datePlayed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).markPlayedItem(userId, itemId, datePlayed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Marks an item as unplayed for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markUnplayedItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).markUnplayedItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports a user\'s playback progress.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [volumeLevel] Scale of 0-100.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {RepeatMode} [repeatMode] The repeat mode.
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onPlaybackProgress(userId: string, itemId: string, mediaSourceId?: string, positionTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, repeatMode?: RepeatMode, isPaused?: boolean, isMuted?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).onPlaybackProgress(userId, itemId, mediaSourceId, positionTicks, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, isPaused, isMuted, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that a user has begun playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {boolean} [canSeek] Indicates if the client can seek.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onPlaybackStart(userId: string, itemId: string, mediaSourceId?: string, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, canSeek?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).onPlaybackStart(userId, itemId, mediaSourceId, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, canSeek, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that a user has stopped playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {string} [nextMediaType] The next media type that will play.
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onPlaybackStopped(userId: string, itemId: string, mediaSourceId?: string, nextMediaType?: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).onPlaybackStopped(userId, itemId, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Pings a playback session.
         * @param {string} [playSessionId] Playback session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingPlaybackSession(playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).pingPlaybackSession(playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports playback progress within a session.
         * @param {PlaybackProgressInfo} [playbackProgressInfo] The playback progress info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPlaybackProgress(playbackProgressInfo?: PlaybackProgressInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).reportPlaybackProgress(playbackProgressInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports playback has started within a session.
         * @param {PlaybackStartInfo} [playbackStartInfo] The playback start info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPlaybackStart(playbackStartInfo?: PlaybackStartInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).reportPlaybackStart(playbackStartInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports playback has stopped within a session.
         * @param {PlaybackStopInfo} [playbackStopInfo] The playback stop info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPlaybackStopped(playbackStopInfo?: PlaybackStopInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).reportPlaybackStopped(playbackStopInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PlaystateApi - factory interface
 * @export
 */
export const PlaystateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Marks an item as played for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [datePlayed] Optional. The date the item was played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markPlayedItem(userId: string, itemId: string, datePlayed?: string, options?: any): AxiosPromise<UserItemDataDto> {
            return PlaystateApiFp(configuration).markPlayedItem(userId, itemId, datePlayed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Marks an item as unplayed for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUnplayedItem(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return PlaystateApiFp(configuration).markUnplayedItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports a user\'s playback progress.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [volumeLevel] Scale of 0-100.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {RepeatMode} [repeatMode] The repeat mode.
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackProgress(userId: string, itemId: string, mediaSourceId?: string, positionTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, repeatMode?: RepeatMode, isPaused?: boolean, isMuted?: boolean, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).onPlaybackProgress(userId, itemId, mediaSourceId, positionTicks, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, isPaused, isMuted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that a user has begun playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {boolean} [canSeek] Indicates if the client can seek.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStart(userId: string, itemId: string, mediaSourceId?: string, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, canSeek?: boolean, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).onPlaybackStart(userId, itemId, mediaSourceId, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, canSeek, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that a user has stopped playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {string} [nextMediaType] The next media type that will play.
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStopped(userId: string, itemId: string, mediaSourceId?: string, nextMediaType?: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).onPlaybackStopped(userId, itemId, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pings a playback session.
         * @param {string} [playSessionId] Playback session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingPlaybackSession(playSessionId?: string, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).pingPlaybackSession(playSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports playback progress within a session.
         * @param {PlaybackProgressInfo} [playbackProgressInfo] The playback progress info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackProgress(playbackProgressInfo?: PlaybackProgressInfo, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).reportPlaybackProgress(playbackProgressInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports playback has started within a session.
         * @param {PlaybackStartInfo} [playbackStartInfo] The playback start info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStart(playbackStartInfo?: PlaybackStartInfo, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).reportPlaybackStart(playbackStartInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports playback has stopped within a session.
         * @param {PlaybackStopInfo} [playbackStopInfo] The playback stop info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStopped(playbackStopInfo?: PlaybackStopInfo, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).reportPlaybackStopped(playbackStopInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaystateApi - object-oriented interface
 * @export
 * @class PlaystateApi
 * @extends {BaseAPI}
 */
export class PlaystateApi extends BaseAPI {
    /**
     * 
     * @summary Marks an item as played for user.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {string} [datePlayed] Optional. The date the item was played.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public markPlayedItem(userId: string, itemId: string, datePlayed?: string, options?: any) {
        return PlaystateApiFp(this.configuration).markPlayedItem(userId, itemId, datePlayed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Marks an item as unplayed for user.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public markUnplayedItem(userId: string, itemId: string, options?: any) {
        return PlaystateApiFp(this.configuration).markUnplayedItem(userId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports a user\'s playback progress.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {string} [mediaSourceId] The id of the MediaSource.
     * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [audioStreamIndex] The audio stream index.
     * @param {number} [subtitleStreamIndex] The subtitle stream index.
     * @param {number} [volumeLevel] Scale of 0-100.
     * @param {PlayMethod} [playMethod] The play method.
     * @param {string} [liveStreamId] The live stream id.
     * @param {string} [playSessionId] The play session id.
     * @param {RepeatMode} [repeatMode] The repeat mode.
     * @param {boolean} [isPaused] Indicates if the player is paused.
     * @param {boolean} [isMuted] Indicates if the player is muted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public onPlaybackProgress(userId: string, itemId: string, mediaSourceId?: string, positionTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, repeatMode?: RepeatMode, isPaused?: boolean, isMuted?: boolean, options?: any) {
        return PlaystateApiFp(this.configuration).onPlaybackProgress(userId, itemId, mediaSourceId, positionTicks, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, isPaused, isMuted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that a user has begun playing an item.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {string} [mediaSourceId] The id of the MediaSource.
     * @param {number} [audioStreamIndex] The audio stream index.
     * @param {number} [subtitleStreamIndex] The subtitle stream index.
     * @param {PlayMethod} [playMethod] The play method.
     * @param {string} [liveStreamId] The live stream id.
     * @param {string} [playSessionId] The play session id.
     * @param {boolean} [canSeek] Indicates if the client can seek.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public onPlaybackStart(userId: string, itemId: string, mediaSourceId?: string, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, canSeek?: boolean, options?: any) {
        return PlaystateApiFp(this.configuration).onPlaybackStart(userId, itemId, mediaSourceId, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, canSeek, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that a user has stopped playing an item.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {string} [mediaSourceId] The id of the MediaSource.
     * @param {string} [nextMediaType] The next media type that will play.
     * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms.
     * @param {string} [liveStreamId] The live stream id.
     * @param {string} [playSessionId] The play session id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public onPlaybackStopped(userId: string, itemId: string, mediaSourceId?: string, nextMediaType?: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options?: any) {
        return PlaystateApiFp(this.configuration).onPlaybackStopped(userId, itemId, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pings a playback session.
     * @param {string} [playSessionId] Playback session id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public pingPlaybackSession(playSessionId?: string, options?: any) {
        return PlaystateApiFp(this.configuration).pingPlaybackSession(playSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports playback progress within a session.
     * @param {PlaybackProgressInfo} [playbackProgressInfo] The playback progress info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public reportPlaybackProgress(playbackProgressInfo?: PlaybackProgressInfo, options?: any) {
        return PlaystateApiFp(this.configuration).reportPlaybackProgress(playbackProgressInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports playback has started within a session.
     * @param {PlaybackStartInfo} [playbackStartInfo] The playback start info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public reportPlaybackStart(playbackStartInfo?: PlaybackStartInfo, options?: any) {
        return PlaystateApiFp(this.configuration).reportPlaybackStart(playbackStartInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports playback has stopped within a session.
     * @param {PlaybackStopInfo} [playbackStopInfo] The playback stop info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public reportPlaybackStopped(playbackStopInfo?: PlaybackStopInfo, options?: any) {
        return PlaystateApiFp(this.configuration).reportPlaybackStopped(playbackStopInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PluginsApi - axios parameter creator
 * @export
 */
export const PluginsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration: async (pluginId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId','Required parameter pluginId was null or undefined when calling getPluginConfiguration.');
            }
            const localVarPath = `/Plugins/{pluginId}/Configuration`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginSecurityInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Plugins/SecurityInfo`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of currently installed plugins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugins: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Plugins`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistration: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRegistration.');
            }
            const localVarPath = `/Plugins/Registrations/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationStatus: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRegistrationStatus.');
            }
            const localVarPath = `/Plugins/RegistrationRecords/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uninstalls a plugin.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallPlugin: async (pluginId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId','Required parameter pluginId was null or undefined when calling uninstallPlugin.');
            }
            const localVarPath = `/Plugins/{pluginId}`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts plugin configuration as JSON body.
         * @summary Updates plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginConfiguration: async (pluginId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId','Required parameter pluginId was null or undefined when calling updatePluginConfiguration.');
            }
            const localVarPath = `/Plugins/{pluginId}/Configuration`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates plugin security info.
         * @param {PluginSecurityInfo} pluginSecurityInfo Plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginSecurityInfo: async (pluginSecurityInfo: PluginSecurityInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginSecurityInfo' is not null or undefined
            if (pluginSecurityInfo === null || pluginSecurityInfo === undefined) {
                throw new RequiredError('pluginSecurityInfo','Required parameter pluginSecurityInfo was null or undefined when calling updatePluginSecurityInfo.');
            }
            const localVarPath = `/Plugins/SecurityInfo`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof pluginSecurityInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(pluginSecurityInfo !== undefined ? pluginSecurityInfo : {}) : (pluginSecurityInfo || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginsApi - functional programming interface
 * @export
 */
export const PluginsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginConfiguration(pluginId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getPluginConfiguration(pluginId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginSecurityInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginSecurityInfo>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getPluginSecurityInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of currently installed plugins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlugins(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PluginInfo>>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getPlugins(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistration(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getRegistration(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistrationStatus(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MBRegistrationRecord>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getRegistrationStatus(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Uninstalls a plugin.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallPlugin(pluginId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).uninstallPlugin(pluginId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Accepts plugin configuration as JSON body.
         * @summary Updates plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePluginConfiguration(pluginId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).updatePluginConfiguration(pluginId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates plugin security info.
         * @param {PluginSecurityInfo} pluginSecurityInfo Plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePluginSecurityInfo(pluginSecurityInfo: PluginSecurityInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).updatePluginSecurityInfo(pluginSecurityInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PluginsApi - factory interface
 * @export
 */
export const PluginsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration(pluginId: string, options?: any): AxiosPromise<object> {
            return PluginsApiFp(configuration).getPluginConfiguration(pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginSecurityInfo(options?: any): AxiosPromise<PluginSecurityInfo> {
            return PluginsApiFp(configuration).getPluginSecurityInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of currently installed plugins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugins(options?: any): AxiosPromise<Array<PluginInfo>> {
            return PluginsApiFp(configuration).getPlugins(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistration(name: string, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).getRegistration(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationStatus(name: string, options?: any): AxiosPromise<MBRegistrationRecord> {
            return PluginsApiFp(configuration).getRegistrationStatus(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uninstalls a plugin.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallPlugin(pluginId: string, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).uninstallPlugin(pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts plugin configuration as JSON body.
         * @summary Updates plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginConfiguration(pluginId: string, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).updatePluginConfiguration(pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates plugin security info.
         * @param {PluginSecurityInfo} pluginSecurityInfo Plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginSecurityInfo(pluginSecurityInfo: PluginSecurityInfo, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).updatePluginSecurityInfo(pluginSecurityInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluginsApi - object-oriented interface
 * @export
 * @class PluginsApi
 * @extends {BaseAPI}
 */
export class PluginsApi extends BaseAPI {
    /**
     * 
     * @summary Gets plugin configuration.
     * @param {string} pluginId Plugin id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPluginConfiguration(pluginId: string, options?: any) {
        return PluginsApiFp(this.configuration).getPluginConfiguration(pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get plugin security info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPluginSecurityInfo(options?: any) {
        return PluginsApiFp(this.configuration).getPluginSecurityInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of currently installed plugins.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPlugins(options?: any) {
        return PluginsApiFp(this.configuration).getPlugins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets registration status for a feature.
     * @param {string} name Feature name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getRegistration(name: string, options?: any) {
        return PluginsApiFp(this.configuration).getRegistration(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets registration status for a feature.
     * @param {string} name Feature name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getRegistrationStatus(name: string, options?: any) {
        return PluginsApiFp(this.configuration).getRegistrationStatus(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uninstalls a plugin.
     * @param {string} pluginId Plugin id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public uninstallPlugin(pluginId: string, options?: any) {
        return PluginsApiFp(this.configuration).uninstallPlugin(pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts plugin configuration as JSON body.
     * @summary Updates plugin configuration.
     * @param {string} pluginId Plugin id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public updatePluginConfiguration(pluginId: string, options?: any) {
        return PluginsApiFp(this.configuration).updatePluginConfiguration(pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates plugin security info.
     * @param {PluginSecurityInfo} pluginSecurityInfo Plugin security info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public updatePluginSecurityInfo(pluginSecurityInfo: PluginSecurityInfo, options?: any) {
        return PluginsApiFp(this.configuration).updatePluginSecurityInfo(pluginSecurityInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuickConnectApi - axios parameter creator
 * @export
 */
export const QuickConnectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Temporarily activates quick connect for five minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Activate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authorizes a pending quick connect request.
         * @param {string} code Quick connect code to authorize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling authorize.');
            }
            const localVarPath = `/QuickConnect/Authorize`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enables or disables quick connect.
         * @param {QuickConnectState} [status] New MediaBrowser.Model.QuickConnect.QuickConnectState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        available: async (status?: QuickConnectState, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Available`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attempts to retrieve authentication information.
         * @param {string} secret Secret previously returned from the Initiate endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect: async (secret: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'secret' is not null or undefined
            if (secret === null || secret === undefined) {
                throw new RequiredError('secret','Required parameter secret was null or undefined when calling connect.');
            }
            const localVarPath = `/QuickConnect/Connect`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deauthorize all quick connect devices for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deauthorize: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Deauthorize`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the current quick connect state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate a new quick connect request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Initiate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuickConnectApi - functional programming interface
 * @export
 */
export const QuickConnectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Temporarily activates quick connect for five minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).activate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Authorizes a pending quick connect request.
         * @param {string} code Quick connect code to authorize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).authorize(code, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Enables or disables quick connect.
         * @param {QuickConnectState} [status] New MediaBrowser.Model.QuickConnect.QuickConnectState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async available(status?: QuickConnectState, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).available(status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Attempts to retrieve authentication information.
         * @param {string} secret Secret previously returned from the Initiate endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connect(secret: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuickConnectResult>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).connect(secret, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deauthorize all quick connect devices for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deauthorize(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).deauthorize(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the current quick connect state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuickConnectState>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).getStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Initiate a new quick connect request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuickConnectResult>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).initiate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QuickConnectApi - factory interface
 * @export
 */
export const QuickConnectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Temporarily activates quick connect for five minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate(options?: any): AxiosPromise<void> {
            return QuickConnectApiFp(configuration).activate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authorizes a pending quick connect request.
         * @param {string} code Quick connect code to authorize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(code: string, options?: any): AxiosPromise<boolean> {
            return QuickConnectApiFp(configuration).authorize(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enables or disables quick connect.
         * @param {QuickConnectState} [status] New MediaBrowser.Model.QuickConnect.QuickConnectState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        available(status?: QuickConnectState, options?: any): AxiosPromise<void> {
            return QuickConnectApiFp(configuration).available(status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attempts to retrieve authentication information.
         * @param {string} secret Secret previously returned from the Initiate endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect(secret: string, options?: any): AxiosPromise<QuickConnectResult> {
            return QuickConnectApiFp(configuration).connect(secret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deauthorize all quick connect devices for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deauthorize(options?: any): AxiosPromise<number> {
            return QuickConnectApiFp(configuration).deauthorize(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the current quick connect state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<QuickConnectState> {
            return QuickConnectApiFp(configuration).getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiate a new quick connect request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiate(options?: any): AxiosPromise<QuickConnectResult> {
            return QuickConnectApiFp(configuration).initiate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuickConnectApi - object-oriented interface
 * @export
 * @class QuickConnectApi
 * @extends {BaseAPI}
 */
export class QuickConnectApi extends BaseAPI {
    /**
     * 
     * @summary Temporarily activates quick connect for five minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public activate(options?: any) {
        return QuickConnectApiFp(this.configuration).activate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authorizes a pending quick connect request.
     * @param {string} code Quick connect code to authorize.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public authorize(code: string, options?: any) {
        return QuickConnectApiFp(this.configuration).authorize(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enables or disables quick connect.
     * @param {QuickConnectState} [status] New MediaBrowser.Model.QuickConnect.QuickConnectState.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public available(status?: QuickConnectState, options?: any) {
        return QuickConnectApiFp(this.configuration).available(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attempts to retrieve authentication information.
     * @param {string} secret Secret previously returned from the Initiate endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public connect(secret: string, options?: any) {
        return QuickConnectApiFp(this.configuration).connect(secret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deauthorize all quick connect devices for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public deauthorize(options?: any) {
        return QuickConnectApiFp(this.configuration).deauthorize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the current quick connect state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public getStatus(options?: any) {
        return QuickConnectApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiate a new quick connect request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public initiate(options?: any) {
        return QuickConnectApiFp(this.configuration).initiate(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RemoteImageApi - axios parameter creator
 * @export
 */
export const RemoteImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads a remote image for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} type The image type.
         * @param {string} [imageUrl] The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteImage: async (itemId: string, type: ImageType, imageUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling downloadRemoteImage.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling downloadRemoteImage.');
            }
            const localVarPath = `/Items/{itemId}/RemoteImages/Download`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImage: async (imageUrl: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUrl' is not null or undefined
            if (imageUrl === null || imageUrl === undefined) {
                throw new RequiredError('imageUrl','Required parameter imageUrl was null or undefined when calling getRemoteImage.');
            }
            const localVarPath = `/Images/Remote`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available remote image providers for an item.
         * @param {string} itemId Item Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImageProviders: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getRemoteImageProviders.');
            }
            const localVarPath = `/Items/{itemId}/RemoteImages/Providers`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available remote images for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} [type] The image type.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [providerName] Optional. The image provider to use.
         * @param {boolean} [includeAllLanguages] Optional. Include all languages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImages: async (itemId: string, type?: ImageType, startIndex?: number, limit?: number, providerName?: string, includeAllLanguages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getRemoteImages.');
            }
            const localVarPath = `/Items/{itemId}/RemoteImages`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (providerName !== undefined) {
                localVarQueryParameter['providerName'] = providerName;
            }

            if (includeAllLanguages !== undefined) {
                localVarQueryParameter['includeAllLanguages'] = includeAllLanguages;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteImageApi - functional programming interface
 * @export
 */
export const RemoteImageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads a remote image for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} type The image type.
         * @param {string} [imageUrl] The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRemoteImage(itemId: string, type: ImageType, imageUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).downloadRemoteImage(itemId, type, imageUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteImage(imageUrl: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).getRemoteImage(imageUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available remote image providers for an item.
         * @param {string} itemId Item Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteImageProviders(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageProviderInfo>>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).getRemoteImageProviders(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available remote images for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} [type] The image type.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [providerName] Optional. The image provider to use.
         * @param {boolean} [includeAllLanguages] Optional. Include all languages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteImages(itemId: string, type?: ImageType, startIndex?: number, limit?: number, providerName?: string, includeAllLanguages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteImageResult>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).getRemoteImages(itemId, type, startIndex, limit, providerName, includeAllLanguages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RemoteImageApi - factory interface
 * @export
 */
export const RemoteImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Downloads a remote image for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} type The image type.
         * @param {string} [imageUrl] The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteImage(itemId: string, type: ImageType, imageUrl?: string, options?: any): AxiosPromise<void> {
            return RemoteImageApiFp(configuration).downloadRemoteImage(itemId, type, imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImage(imageUrl: string, options?: any): AxiosPromise<any> {
            return RemoteImageApiFp(configuration).getRemoteImage(imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available remote image providers for an item.
         * @param {string} itemId Item Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImageProviders(itemId: string, options?: any): AxiosPromise<Array<ImageProviderInfo>> {
            return RemoteImageApiFp(configuration).getRemoteImageProviders(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available remote images for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} [type] The image type.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [providerName] Optional. The image provider to use.
         * @param {boolean} [includeAllLanguages] Optional. Include all languages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImages(itemId: string, type?: ImageType, startIndex?: number, limit?: number, providerName?: string, includeAllLanguages?: boolean, options?: any): AxiosPromise<RemoteImageResult> {
            return RemoteImageApiFp(configuration).getRemoteImages(itemId, type, startIndex, limit, providerName, includeAllLanguages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemoteImageApi - object-oriented interface
 * @export
 * @class RemoteImageApi
 * @extends {BaseAPI}
 */
export class RemoteImageApi extends BaseAPI {
    /**
     * 
     * @summary Downloads a remote image for an item.
     * @param {string} itemId Item Id.
     * @param {ImageType} type The image type.
     * @param {string} [imageUrl] The image url.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public downloadRemoteImage(itemId: string, type: ImageType, imageUrl?: string, options?: any) {
        return RemoteImageApiFp(this.configuration).downloadRemoteImage(itemId, type, imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a remote image.
     * @param {string} imageUrl The image url.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public getRemoteImage(imageUrl: string, options?: any) {
        return RemoteImageApiFp(this.configuration).getRemoteImage(imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available remote image providers for an item.
     * @param {string} itemId Item Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public getRemoteImageProviders(itemId: string, options?: any) {
        return RemoteImageApiFp(this.configuration).getRemoteImageProviders(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available remote images for an item.
     * @param {string} itemId Item Id.
     * @param {ImageType} [type] The image type.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [providerName] Optional. The image provider to use.
     * @param {boolean} [includeAllLanguages] Optional. Include all languages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public getRemoteImages(itemId: string, type?: ImageType, startIndex?: number, limit?: number, providerName?: string, includeAllLanguages?: boolean, options?: any) {
        return RemoteImageApiFp(this.configuration).getRemoteImages(itemId, type, startIndex, limit, providerName, includeAllLanguages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduledTasksApi - axios parameter creator
 * @export
 */
export const ScheduledTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get task by id.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getTask.');
            }
            const localVarPath = `/ScheduledTasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tasks.
         * @param {boolean} [isHidden] Optional filter tasks that are hidden, or not.
         * @param {boolean} [isEnabled] Optional filter tasks that are enabled, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (isHidden?: boolean, isEnabled?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ScheduledTasks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isHidden !== undefined) {
                localVarQueryParameter['isHidden'] = isHidden;
            }

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = isEnabled;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTask: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling startTask.');
            }
            const localVarPath = `/ScheduledTasks/Running/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTask: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling stopTask.');
            }
            const localVarPath = `/ScheduledTasks/Running/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update specified task triggers.
         * @param {string} taskId Task Id.
         * @param {Array<TaskTriggerInfo>} taskTriggerInfo Triggers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (taskId: string, taskTriggerInfo: Array<TaskTriggerInfo>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling updateTask.');
            }
            // verify required parameter 'taskTriggerInfo' is not null or undefined
            if (taskTriggerInfo === null || taskTriggerInfo === undefined) {
                throw new RequiredError('taskTriggerInfo','Required parameter taskTriggerInfo was null or undefined when calling updateTask.');
            }
            const localVarPath = `/ScheduledTasks/{taskId}/Triggers`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof taskTriggerInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(taskTriggerInfo !== undefined ? taskTriggerInfo : {}) : (taskTriggerInfo || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledTasksApi - functional programming interface
 * @export
 */
export const ScheduledTasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get task by id.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskInfo>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).getTask(taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get tasks.
         * @param {boolean} [isHidden] Optional filter tasks that are hidden, or not.
         * @param {boolean} [isEnabled] Optional filter tasks that are enabled, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(isHidden?: boolean, isEnabled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IScheduledTaskWorker>>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).getTasks(isHidden, isEnabled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Start specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startTask(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).startTask(taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Stop specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopTask(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).stopTask(taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update specified task triggers.
         * @param {string} taskId Task Id.
         * @param {Array<TaskTriggerInfo>} taskTriggerInfo Triggers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(taskId: string, taskTriggerInfo: Array<TaskTriggerInfo>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).updateTask(taskId, taskTriggerInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ScheduledTasksApi - factory interface
 * @export
 */
export const ScheduledTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get task by id.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: any): AxiosPromise<TaskInfo> {
            return ScheduledTasksApiFp(configuration).getTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tasks.
         * @param {boolean} [isHidden] Optional filter tasks that are hidden, or not.
         * @param {boolean} [isEnabled] Optional filter tasks that are enabled, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(isHidden?: boolean, isEnabled?: boolean, options?: any): AxiosPromise<Array<IScheduledTaskWorker>> {
            return ScheduledTasksApiFp(configuration).getTasks(isHidden, isEnabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTask(taskId: string, options?: any): AxiosPromise<void> {
            return ScheduledTasksApiFp(configuration).startTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTask(taskId: string, options?: any): AxiosPromise<void> {
            return ScheduledTasksApiFp(configuration).stopTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update specified task triggers.
         * @param {string} taskId Task Id.
         * @param {Array<TaskTriggerInfo>} taskTriggerInfo Triggers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(taskId: string, taskTriggerInfo: Array<TaskTriggerInfo>, options?: any): AxiosPromise<void> {
            return ScheduledTasksApiFp(configuration).updateTask(taskId, taskTriggerInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduledTasksApi - object-oriented interface
 * @export
 * @class ScheduledTasksApi
 * @extends {BaseAPI}
 */
export class ScheduledTasksApi extends BaseAPI {
    /**
     * 
     * @summary Get task by id.
     * @param {string} taskId Task Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public getTask(taskId: string, options?: any) {
        return ScheduledTasksApiFp(this.configuration).getTask(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tasks.
     * @param {boolean} [isHidden] Optional filter tasks that are hidden, or not.
     * @param {boolean} [isEnabled] Optional filter tasks that are enabled, or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public getTasks(isHidden?: boolean, isEnabled?: boolean, options?: any) {
        return ScheduledTasksApiFp(this.configuration).getTasks(isHidden, isEnabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start specified task.
     * @param {string} taskId Task Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public startTask(taskId: string, options?: any) {
        return ScheduledTasksApiFp(this.configuration).startTask(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop specified task.
     * @param {string} taskId Task Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public stopTask(taskId: string, options?: any) {
        return ScheduledTasksApiFp(this.configuration).stopTask(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update specified task triggers.
     * @param {string} taskId Task Id.
     * @param {Array<TaskTriggerInfo>} taskTriggerInfo Triggers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public updateTask(taskId: string, taskTriggerInfo: Array<TaskTriggerInfo>, options?: any) {
        return ScheduledTasksApiFp(this.configuration).updateTask(taskId, taskTriggerInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the search hint result.
         * @param {string} searchTerm The search term to filter on.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [userId] Optional. Supply a user id to search within a user\&#39;s library or omit to search all.
         * @param {string} [includeItemTypes] If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.
         * @param {string} [excludeItemTypes] If specified, results with these item types are filtered out. This allows multiple, comma delimeted.
         * @param {string} [mediaTypes] If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.
         * @param {string} [parentId] If specified, only children of the parent are returned.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [includePeople] Optional filter whether to include people.
         * @param {boolean} [includeMedia] Optional filter whether to include media.
         * @param {boolean} [includeGenres] Optional filter whether to include genres.
         * @param {boolean} [includeStudios] Optional filter whether to include studios.
         * @param {boolean} [includeArtists] Optional filter whether to include artists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (searchTerm: string, startIndex?: number, limit?: number, userId?: string, includeItemTypes?: string, excludeItemTypes?: string, mediaTypes?: string, parentId?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, includePeople?: boolean, includeMedia?: boolean, includeGenres?: boolean, includeStudios?: boolean, includeArtists?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchTerm' is not null or undefined
            if (searchTerm === null || searchTerm === undefined) {
                throw new RequiredError('searchTerm','Required parameter searchTerm was null or undefined when calling get.');
            }
            const localVarPath = `/Search/Hints`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (includePeople !== undefined) {
                localVarQueryParameter['includePeople'] = includePeople;
            }

            if (includeMedia !== undefined) {
                localVarQueryParameter['includeMedia'] = includeMedia;
            }

            if (includeGenres !== undefined) {
                localVarQueryParameter['includeGenres'] = includeGenres;
            }

            if (includeStudios !== undefined) {
                localVarQueryParameter['includeStudios'] = includeStudios;
            }

            if (includeArtists !== undefined) {
                localVarQueryParameter['includeArtists'] = includeArtists;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the search hint result.
         * @param {string} searchTerm The search term to filter on.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [userId] Optional. Supply a user id to search within a user\&#39;s library or omit to search all.
         * @param {string} [includeItemTypes] If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.
         * @param {string} [excludeItemTypes] If specified, results with these item types are filtered out. This allows multiple, comma delimeted.
         * @param {string} [mediaTypes] If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.
         * @param {string} [parentId] If specified, only children of the parent are returned.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [includePeople] Optional filter whether to include people.
         * @param {boolean} [includeMedia] Optional filter whether to include media.
         * @param {boolean} [includeGenres] Optional filter whether to include genres.
         * @param {boolean} [includeStudios] Optional filter whether to include studios.
         * @param {boolean} [includeArtists] Optional filter whether to include artists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(searchTerm: string, startIndex?: number, limit?: number, userId?: string, includeItemTypes?: string, excludeItemTypes?: string, mediaTypes?: string, parentId?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, includePeople?: boolean, includeMedia?: boolean, includeGenres?: boolean, includeStudios?: boolean, includeArtists?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchHintResult>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).get(searchTerm, startIndex, limit, userId, includeItemTypes, excludeItemTypes, mediaTypes, parentId, isMovie, isSeries, isNews, isKids, isSports, includePeople, includeMedia, includeGenres, includeStudios, includeArtists, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets the search hint result.
         * @param {string} searchTerm The search term to filter on.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [userId] Optional. Supply a user id to search within a user\&#39;s library or omit to search all.
         * @param {string} [includeItemTypes] If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.
         * @param {string} [excludeItemTypes] If specified, results with these item types are filtered out. This allows multiple, comma delimeted.
         * @param {string} [mediaTypes] If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.
         * @param {string} [parentId] If specified, only children of the parent are returned.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [includePeople] Optional filter whether to include people.
         * @param {boolean} [includeMedia] Optional filter whether to include media.
         * @param {boolean} [includeGenres] Optional filter whether to include genres.
         * @param {boolean} [includeStudios] Optional filter whether to include studios.
         * @param {boolean} [includeArtists] Optional filter whether to include artists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(searchTerm: string, startIndex?: number, limit?: number, userId?: string, includeItemTypes?: string, excludeItemTypes?: string, mediaTypes?: string, parentId?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, includePeople?: boolean, includeMedia?: boolean, includeGenres?: boolean, includeStudios?: boolean, includeArtists?: boolean, options?: any): AxiosPromise<SearchHintResult> {
            return SearchApiFp(configuration).get(searchTerm, startIndex, limit, userId, includeItemTypes, excludeItemTypes, mediaTypes, parentId, isMovie, isSeries, isNews, isKids, isSports, includePeople, includeMedia, includeGenres, includeStudios, includeArtists, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @summary Gets the search hint result.
     * @param {string} searchTerm The search term to filter on.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [userId] Optional. Supply a user id to search within a user\&#39;s library or omit to search all.
     * @param {string} [includeItemTypes] If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.
     * @param {string} [excludeItemTypes] If specified, results with these item types are filtered out. This allows multiple, comma delimeted.
     * @param {string} [mediaTypes] If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.
     * @param {string} [parentId] If specified, only children of the parent are returned.
     * @param {boolean} [isMovie] Optional filter for movies.
     * @param {boolean} [isSeries] Optional filter for series.
     * @param {boolean} [isNews] Optional filter for news.
     * @param {boolean} [isKids] Optional filter for kids.
     * @param {boolean} [isSports] Optional filter for sports.
     * @param {boolean} [includePeople] Optional filter whether to include people.
     * @param {boolean} [includeMedia] Optional filter whether to include media.
     * @param {boolean} [includeGenres] Optional filter whether to include genres.
     * @param {boolean} [includeStudios] Optional filter whether to include studios.
     * @param {boolean} [includeArtists] Optional filter whether to include artists.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public get(searchTerm: string, startIndex?: number, limit?: number, userId?: string, includeItemTypes?: string, excludeItemTypes?: string, mediaTypes?: string, parentId?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, includePeople?: boolean, includeMedia?: boolean, includeGenres?: boolean, includeStudios?: boolean, includeArtists?: boolean, options?: any) {
        return SearchApiFp(this.configuration).get(searchTerm, startIndex, limit, userId, includeItemTypes, excludeItemTypes, mediaTypes, parentId, isMovie, isSeries, isNews, isKids, isSports, includePeople, includeMedia, includeGenres, includeStudios, includeArtists, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an additional user to a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSession: async (sessionId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling addUserToSession.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling addUserToSession.');
            }
            const localVarPath = `/Sessions/{sessionId}/User/{userId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Instructs a session to browse to an item or view.
         * @param {string} sessionId The session Id.
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayContent: async (sessionId: string, itemType: string, itemId: string, itemName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling displayContent.');
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new RequiredError('itemType','Required parameter itemType was null or undefined when calling displayContent.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling displayContent.');
            }
            // verify required parameter 'itemName' is not null or undefined
            if (itemName === null || itemName === undefined) {
                throw new RequiredError('itemName','Required parameter itemName was null or undefined when calling displayContent.');
            }
            const localVarPath = `/Sessions/{sessionId}/Viewing`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemType !== undefined) {
                localVarQueryParameter['itemType'] = itemType;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }

            if (itemName !== undefined) {
                localVarQueryParameter['itemName'] = itemName;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all auth providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/Providers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all password reset providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordResetProviders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/PasswordResetProviders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of sessions.
         * @param {string} [controllableByUserId] Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Filter by device Id.
         * @param {number} [activeWithinSeconds] Optional. Filter by sessions that were active in the last n seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (controllableByUserId?: string, deviceId?: string, activeWithinSeconds?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (controllableByUserId !== undefined) {
                localVarQueryParameter['controllableByUserId'] = controllableByUserId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (activeWithinSeconds !== undefined) {
                localVarQueryParameter['activeWithinSeconds'] = activeWithinSeconds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Instructs a session to play an item.
         * @param {string} sessionId The session id.
         * @param {PlayCommand} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} itemIds The ids of the items to play, comma delimited.
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        play: async (sessionId: string, playCommand: PlayCommand, itemIds: string, startPositionTicks?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling play.');
            }
            // verify required parameter 'playCommand' is not null or undefined
            if (playCommand === null || playCommand === undefined) {
                throw new RequiredError('playCommand','Required parameter playCommand was null or undefined when calling play.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling play.');
            }
            const localVarPath = `/Sessions/{sessionId}/Playing`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (playCommand !== undefined) {
                localVarQueryParameter['playCommand'] = playCommand;
            }

            if (itemIds !== undefined) {
                localVarQueryParameter['itemIds'] = itemIds;
            }

            if (startPositionTicks !== undefined) {
                localVarQueryParameter['startPositionTicks'] = startPositionTicks;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {string} [id] The session id.
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Photo.
         * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited.
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely..
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCapabilities: async (id?: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Capabilities`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (playableMediaTypes !== undefined) {
                localVarQueryParameter['playableMediaTypes'] = playableMediaTypes;
            }

            if (supportedCommands !== undefined) {
                localVarQueryParameter['supportedCommands'] = supportedCommands;
            }

            if (supportsMediaControl !== undefined) {
                localVarQueryParameter['supportsMediaControl'] = supportsMediaControl;
            }

            if (supportsSync !== undefined) {
                localVarQueryParameter['supportsSync'] = supportsSync;
            }

            if (supportsPersistentIdentifier !== undefined) {
                localVarQueryParameter['supportsPersistentIdentifier'] = supportsPersistentIdentifier;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {ClientCapabilities} clientCapabilities The MediaBrowser.Model.Session.ClientCapabilities.
         * @param {string} [id] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFullCapabilities: async (clientCapabilities: ClientCapabilities, id?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientCapabilities' is not null or undefined
            if (clientCapabilities === null || clientCapabilities === undefined) {
                throw new RequiredError('clientCapabilities','Required parameter clientCapabilities was null or undefined when calling postFullCapabilities.');
            }
            const localVarPath = `/Sessions/Capabilities/Full`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof clientCapabilities !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(clientCapabilities !== undefined ? clientCapabilities : {}) : (clientCapabilities || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes an additional user from a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromSession: async (sessionId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling removeUserFromSession.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling removeUserFromSession.');
            }
            const localVarPath = `/Sessions/{sessionId}/User/{userId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that a session has ended.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSessionEnded: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that a session is viewing an item.
         * @param {string} itemId The item id.
         * @param {string} [sessionId] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportViewing: async (itemId: string, sessionId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling reportViewing.');
            }
            const localVarPath = `/Sessions/Viewing`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['sessionId'] = sessionId;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issues a full general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommand} generalCommand The MediaBrowser.Model.Session.GeneralCommand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFullGeneralCommand: async (sessionId: string, generalCommand: GeneralCommand, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendFullGeneralCommand.');
            }
            // verify required parameter 'generalCommand' is not null or undefined
            if (generalCommand === null || generalCommand === undefined) {
                throw new RequiredError('generalCommand','Required parameter generalCommand was null or undefined when calling sendFullGeneralCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Command`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof generalCommand !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(generalCommand !== undefined ? generalCommand : {}) : (generalCommand || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issues a general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGeneralCommand: async (sessionId: string, command: GeneralCommandType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendGeneralCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling sendGeneralCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Command/{command}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issues a command to a client to display a message to the user.
         * @param {string} sessionId The session id.
         * @param {string} text The message test.
         * @param {string} [header] The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessageCommand: async (sessionId: string, text: string, header?: string, timeoutMs?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendMessageCommand.');
            }
            // verify required parameter 'text' is not null or undefined
            if (text === null || text === undefined) {
                throw new RequiredError('text','Required parameter text was null or undefined when calling sendMessageCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Message`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (header !== undefined) {
                localVarQueryParameter['header'] = header;
            }

            if (timeoutMs !== undefined) {
                localVarQueryParameter['timeoutMs'] = timeoutMs;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issues a playstate command to a client.
         * @param {string} sessionId The session id.
         * @param {PlaystateCommand} command The MediaBrowser.Model.Session.PlaystateCommand.
         * @param {number} [seekPositionTicks] The optional position ticks.
         * @param {string} [controllingUserId] The optional controlling user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPlaystateCommand: async (sessionId: string, command: PlaystateCommand, seekPositionTicks?: number, controllingUserId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendPlaystateCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling sendPlaystateCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Playing/{command}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (seekPositionTicks !== undefined) {
                localVarQueryParameter['seekPositionTicks'] = seekPositionTicks;
            }

            if (controllingUserId !== undefined) {
                localVarQueryParameter['controllingUserId'] = controllingUserId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issues a system command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSystemCommand: async (sessionId: string, command: GeneralCommandType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendSystemCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling sendSystemCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/System/{command}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an additional user to a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToSession(sessionId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).addUserToSession(sessionId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Instructs a session to browse to an item or view.
         * @param {string} sessionId The session Id.
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayContent(sessionId: string, itemType: string, itemId: string, itemName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).displayContent(sessionId, itemType, itemId, itemName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all auth providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthProviders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).getAuthProviders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all password reset providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordResetProviders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).getPasswordResetProviders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of sessions.
         * @param {string} [controllableByUserId] Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Filter by device Id.
         * @param {number} [activeWithinSeconds] Optional. Filter by sessions that were active in the last n seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(controllableByUserId?: string, deviceId?: string, activeWithinSeconds?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionInfo>>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).getSessions(controllableByUserId, deviceId, activeWithinSeconds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Instructs a session to play an item.
         * @param {string} sessionId The session id.
         * @param {PlayCommand} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} itemIds The ids of the items to play, comma delimited.
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async play(sessionId: string, playCommand: PlayCommand, itemIds: string, startPositionTicks?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).play(sessionId, playCommand, itemIds, startPositionTicks, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {string} [id] The session id.
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Photo.
         * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited.
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely..
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCapabilities(id?: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).postCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, supportsPersistentIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {ClientCapabilities} clientCapabilities The MediaBrowser.Model.Session.ClientCapabilities.
         * @param {string} [id] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFullCapabilities(clientCapabilities: ClientCapabilities, id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).postFullCapabilities(clientCapabilities, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes an additional user from a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromSession(sessionId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).removeUserFromSession(sessionId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that a session has ended.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportSessionEnded(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).reportSessionEnded(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that a session is viewing an item.
         * @param {string} itemId The item id.
         * @param {string} [sessionId] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportViewing(itemId: string, sessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).reportViewing(itemId, sessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Issues a full general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommand} generalCommand The MediaBrowser.Model.Session.GeneralCommand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendFullGeneralCommand(sessionId: string, generalCommand: GeneralCommand, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendFullGeneralCommand(sessionId, generalCommand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Issues a general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendGeneralCommand(sessionId: string, command: GeneralCommandType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendGeneralCommand(sessionId, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Issues a command to a client to display a message to the user.
         * @param {string} sessionId The session id.
         * @param {string} text The message test.
         * @param {string} [header] The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessageCommand(sessionId: string, text: string, header?: string, timeoutMs?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendMessageCommand(sessionId, text, header, timeoutMs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Issues a playstate command to a client.
         * @param {string} sessionId The session id.
         * @param {PlaystateCommand} command The MediaBrowser.Model.Session.PlaystateCommand.
         * @param {number} [seekPositionTicks] The optional position ticks.
         * @param {string} [controllingUserId] The optional controlling user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPlaystateCommand(sessionId: string, command: PlaystateCommand, seekPositionTicks?: number, controllingUserId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendPlaystateCommand(sessionId, command, seekPositionTicks, controllingUserId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Issues a system command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSystemCommand(sessionId: string, command: GeneralCommandType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendSystemCommand(sessionId, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds an additional user to a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSession(sessionId: string, userId: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).addUserToSession(sessionId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Instructs a session to browse to an item or view.
         * @param {string} sessionId The session Id.
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayContent(sessionId: string, itemType: string, itemId: string, itemName: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).displayContent(sessionId, itemType, itemId, itemName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all auth providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders(options?: any): AxiosPromise<Array<NameIdPair>> {
            return SessionApiFp(configuration).getAuthProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all password reset providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordResetProviders(options?: any): AxiosPromise<Array<NameIdPair>> {
            return SessionApiFp(configuration).getPasswordResetProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of sessions.
         * @param {string} [controllableByUserId] Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Filter by device Id.
         * @param {number} [activeWithinSeconds] Optional. Filter by sessions that were active in the last n seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(controllableByUserId?: string, deviceId?: string, activeWithinSeconds?: number, options?: any): AxiosPromise<Array<SessionInfo>> {
            return SessionApiFp(configuration).getSessions(controllableByUserId, deviceId, activeWithinSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Instructs a session to play an item.
         * @param {string} sessionId The session id.
         * @param {PlayCommand} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} itemIds The ids of the items to play, comma delimited.
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        play(sessionId: string, playCommand: PlayCommand, itemIds: string, startPositionTicks?: number, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).play(sessionId, playCommand, itemIds, startPositionTicks, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {string} [id] The session id.
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Photo.
         * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited.
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely..
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCapabilities(id?: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).postCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, supportsPersistentIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {ClientCapabilities} clientCapabilities The MediaBrowser.Model.Session.ClientCapabilities.
         * @param {string} [id] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFullCapabilities(clientCapabilities: ClientCapabilities, id?: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).postFullCapabilities(clientCapabilities, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes an additional user from a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromSession(sessionId: string, userId: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).removeUserFromSession(sessionId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that a session has ended.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSessionEnded(options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).reportSessionEnded(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that a session is viewing an item.
         * @param {string} itemId The item id.
         * @param {string} [sessionId] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportViewing(itemId: string, sessionId?: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).reportViewing(itemId, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issues a full general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommand} generalCommand The MediaBrowser.Model.Session.GeneralCommand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFullGeneralCommand(sessionId: string, generalCommand: GeneralCommand, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendFullGeneralCommand(sessionId, generalCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issues a general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGeneralCommand(sessionId: string, command: GeneralCommandType, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendGeneralCommand(sessionId, command, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issues a command to a client to display a message to the user.
         * @param {string} sessionId The session id.
         * @param {string} text The message test.
         * @param {string} [header] The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessageCommand(sessionId: string, text: string, header?: string, timeoutMs?: number, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendMessageCommand(sessionId, text, header, timeoutMs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issues a playstate command to a client.
         * @param {string} sessionId The session id.
         * @param {PlaystateCommand} command The MediaBrowser.Model.Session.PlaystateCommand.
         * @param {number} [seekPositionTicks] The optional position ticks.
         * @param {string} [controllingUserId] The optional controlling user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPlaystateCommand(sessionId: string, command: PlaystateCommand, seekPositionTicks?: number, controllingUserId?: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendPlaystateCommand(sessionId, command, seekPositionTicks, controllingUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issues a system command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSystemCommand(sessionId: string, command: GeneralCommandType, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendSystemCommand(sessionId, command, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary Adds an additional user to a session.
     * @param {string} sessionId The session id.
     * @param {string} userId The user id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public addUserToSession(sessionId: string, userId: string, options?: any) {
        return SessionApiFp(this.configuration).addUserToSession(sessionId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Instructs a session to browse to an item or view.
     * @param {string} sessionId The session Id.
     * @param {string} itemType The type of item to browse to.
     * @param {string} itemId The Id of the item.
     * @param {string} itemName The name of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public displayContent(sessionId: string, itemType: string, itemId: string, itemName: string, options?: any) {
        return SessionApiFp(this.configuration).displayContent(sessionId, itemType, itemId, itemName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all auth providers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getAuthProviders(options?: any) {
        return SessionApiFp(this.configuration).getAuthProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all password reset providers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getPasswordResetProviders(options?: any) {
        return SessionApiFp(this.configuration).getPasswordResetProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of sessions.
     * @param {string} [controllableByUserId] Filter by sessions that a given user is allowed to remote control.
     * @param {string} [deviceId] Filter by device Id.
     * @param {number} [activeWithinSeconds] Optional. Filter by sessions that were active in the last n seconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getSessions(controllableByUserId?: string, deviceId?: string, activeWithinSeconds?: number, options?: any) {
        return SessionApiFp(this.configuration).getSessions(controllableByUserId, deviceId, activeWithinSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Instructs a session to play an item.
     * @param {string} sessionId The session id.
     * @param {PlayCommand} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
     * @param {string} itemIds The ids of the items to play, comma delimited.
     * @param {number} [startPositionTicks] The starting position of the first item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public play(sessionId: string, playCommand: PlayCommand, itemIds: string, startPositionTicks?: number, options?: any) {
        return SessionApiFp(this.configuration).play(sessionId, playCommand, itemIds, startPositionTicks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates capabilities for a device.
     * @param {string} [id] The session id.
     * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Photo.
     * @param {string} [supportedCommands] A list of supported remote control commands, comma delimited.
     * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely..
     * @param {boolean} [supportsSync] Determines whether sync is supported.
     * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public postCapabilities(id?: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options?: any) {
        return SessionApiFp(this.configuration).postCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, supportsPersistentIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates capabilities for a device.
     * @param {ClientCapabilities} clientCapabilities The MediaBrowser.Model.Session.ClientCapabilities.
     * @param {string} [id] The session id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public postFullCapabilities(clientCapabilities: ClientCapabilities, id?: string, options?: any) {
        return SessionApiFp(this.configuration).postFullCapabilities(clientCapabilities, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes an additional user from a session.
     * @param {string} sessionId The session id.
     * @param {string} userId The user id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public removeUserFromSession(sessionId: string, userId: string, options?: any) {
        return SessionApiFp(this.configuration).removeUserFromSession(sessionId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that a session has ended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public reportSessionEnded(options?: any) {
        return SessionApiFp(this.configuration).reportSessionEnded(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that a session is viewing an item.
     * @param {string} itemId The item id.
     * @param {string} [sessionId] The session id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public reportViewing(itemId: string, sessionId?: string, options?: any) {
        return SessionApiFp(this.configuration).reportViewing(itemId, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issues a full general command to a client.
     * @param {string} sessionId The session id.
     * @param {GeneralCommand} generalCommand The MediaBrowser.Model.Session.GeneralCommand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendFullGeneralCommand(sessionId: string, generalCommand: GeneralCommand, options?: any) {
        return SessionApiFp(this.configuration).sendFullGeneralCommand(sessionId, generalCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issues a general command to a client.
     * @param {string} sessionId The session id.
     * @param {GeneralCommandType} command The command to send.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendGeneralCommand(sessionId: string, command: GeneralCommandType, options?: any) {
        return SessionApiFp(this.configuration).sendGeneralCommand(sessionId, command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issues a command to a client to display a message to the user.
     * @param {string} sessionId The session id.
     * @param {string} text The message test.
     * @param {string} [header] The message header.
     * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendMessageCommand(sessionId: string, text: string, header?: string, timeoutMs?: number, options?: any) {
        return SessionApiFp(this.configuration).sendMessageCommand(sessionId, text, header, timeoutMs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issues a playstate command to a client.
     * @param {string} sessionId The session id.
     * @param {PlaystateCommand} command The MediaBrowser.Model.Session.PlaystateCommand.
     * @param {number} [seekPositionTicks] The optional position ticks.
     * @param {string} [controllingUserId] The optional controlling user id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendPlaystateCommand(sessionId: string, command: PlaystateCommand, seekPositionTicks?: number, controllingUserId?: string, options?: any) {
        return SessionApiFp(this.configuration).sendPlaystateCommand(sessionId, command, seekPositionTicks, controllingUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issues a system command to a client.
     * @param {string} sessionId The session id.
     * @param {GeneralCommandType} command The command to send.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendSystemCommand(sessionId: string, command: GeneralCommandType, options?: any) {
        return SessionApiFp(this.configuration).sendSystemCommand(sessionId, command, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StartupApi - axios parameter creator
 * @export
 */
export const StartupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Completes the startup wizard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWizard: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/Complete`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/User`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/FirstUser`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the initial startup wizard configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartupConfiguration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/Configuration`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets remote access and UPnP.
         * @param {StartupRemoteAccessDto} startupRemoteAccessDto The startup remote access dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRemoteAccess: async (startupRemoteAccessDto: StartupRemoteAccessDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startupRemoteAccessDto' is not null or undefined
            if (startupRemoteAccessDto === null || startupRemoteAccessDto === undefined) {
                throw new RequiredError('startupRemoteAccessDto','Required parameter startupRemoteAccessDto was null or undefined when calling setRemoteAccess.');
            }
            const localVarPath = `/Startup/RemoteAccess`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof startupRemoteAccessDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(startupRemoteAccessDto !== undefined ? startupRemoteAccessDto : {}) : (startupRemoteAccessDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the initial startup wizard configuration.
         * @param {StartupConfigurationDto} startupConfigurationDto The updated startup configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInitialConfiguration: async (startupConfigurationDto: StartupConfigurationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startupConfigurationDto' is not null or undefined
            if (startupConfigurationDto === null || startupConfigurationDto === undefined) {
                throw new RequiredError('startupConfigurationDto','Required parameter startupConfigurationDto was null or undefined when calling updateInitialConfiguration.');
            }
            const localVarPath = `/Startup/Configuration`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof startupConfigurationDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(startupConfigurationDto !== undefined ? startupConfigurationDto : {}) : (startupConfigurationDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the user name and password.
         * @param {StartupUserDto} [startupUserDto] The DTO containing username and password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStartupUser: async (startupUserDto?: StartupUserDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/User`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof startupUserDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(startupUserDto !== undefined ? startupUserDto : {}) : (startupUserDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StartupApi - functional programming interface
 * @export
 */
export const StartupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Completes the startup wizard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeWizard(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).completeWizard(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartupUserDto>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).getFirstUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstUser2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartupUserDto>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).getFirstUser2(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the initial startup wizard configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartupConfiguration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartupConfigurationDto>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).getStartupConfiguration(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets remote access and UPnP.
         * @param {StartupRemoteAccessDto} startupRemoteAccessDto The startup remote access dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRemoteAccess(startupRemoteAccessDto: StartupRemoteAccessDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).setRemoteAccess(startupRemoteAccessDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the initial startup wizard configuration.
         * @param {StartupConfigurationDto} startupConfigurationDto The updated startup configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInitialConfiguration(startupConfigurationDto: StartupConfigurationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).updateInitialConfiguration(startupConfigurationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the user name and password.
         * @param {StartupUserDto} [startupUserDto] The DTO containing username and password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStartupUser(startupUserDto?: StartupUserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).updateStartupUser(startupUserDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StartupApi - factory interface
 * @export
 */
export const StartupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Completes the startup wizard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWizard(options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).completeWizard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser(options?: any): AxiosPromise<StartupUserDto> {
            return StartupApiFp(configuration).getFirstUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser2(options?: any): AxiosPromise<StartupUserDto> {
            return StartupApiFp(configuration).getFirstUser2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the initial startup wizard configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartupConfiguration(options?: any): AxiosPromise<StartupConfigurationDto> {
            return StartupApiFp(configuration).getStartupConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets remote access and UPnP.
         * @param {StartupRemoteAccessDto} startupRemoteAccessDto The startup remote access dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRemoteAccess(startupRemoteAccessDto: StartupRemoteAccessDto, options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).setRemoteAccess(startupRemoteAccessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the initial startup wizard configuration.
         * @param {StartupConfigurationDto} startupConfigurationDto The updated startup configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInitialConfiguration(startupConfigurationDto: StartupConfigurationDto, options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).updateInitialConfiguration(startupConfigurationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the user name and password.
         * @param {StartupUserDto} [startupUserDto] The DTO containing username and password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStartupUser(startupUserDto?: StartupUserDto, options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).updateStartupUser(startupUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StartupApi - object-oriented interface
 * @export
 * @class StartupApi
 * @extends {BaseAPI}
 */
export class StartupApi extends BaseAPI {
    /**
     * 
     * @summary Completes the startup wizard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public completeWizard(options?: any) {
        return StartupApiFp(this.configuration).completeWizard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the first user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public getFirstUser(options?: any) {
        return StartupApiFp(this.configuration).getFirstUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the first user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public getFirstUser2(options?: any) {
        return StartupApiFp(this.configuration).getFirstUser2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the initial startup wizard configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public getStartupConfiguration(options?: any) {
        return StartupApiFp(this.configuration).getStartupConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets remote access and UPnP.
     * @param {StartupRemoteAccessDto} startupRemoteAccessDto The startup remote access dto.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public setRemoteAccess(startupRemoteAccessDto: StartupRemoteAccessDto, options?: any) {
        return StartupApiFp(this.configuration).setRemoteAccess(startupRemoteAccessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the initial startup wizard configuration.
     * @param {StartupConfigurationDto} startupConfigurationDto The updated startup configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public updateInitialConfiguration(startupConfigurationDto: StartupConfigurationDto, options?: any) {
        return StartupApiFp(this.configuration).updateInitialConfiguration(startupConfigurationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the user name and password.
     * @param {StartupUserDto} [startupUserDto] The DTO containing username and password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public updateStartupUser(startupUserDto?: StartupUserDto, options?: any) {
        return StartupApiFp(this.configuration).updateStartupUser(startupUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudiosApi - axios parameter creator
 * @export
 */
export const StudiosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a studio by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudio: async (name: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getStudio.');
            }
            const localVarPath = `/Studios/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all studios from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudios: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Studios`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiosApi - functional programming interface
 * @export
 */
export const StudiosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a studio by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudio(name: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await StudiosApiAxiosParamCreator(configuration).getStudio(name, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all studios from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudios(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await StudiosApiAxiosParamCreator(configuration).getStudios(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StudiosApi - factory interface
 * @export
 */
export const StudiosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a studio by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudio(name: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return StudiosApiFp(configuration).getStudio(name, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all studios from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudios(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return StudiosApiFp(configuration).getStudios(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudiosApi - object-oriented interface
 * @export
 * @class StudiosApi
 * @extends {BaseAPI}
 */
export class StudiosApi extends BaseAPI {
    /**
     * 
     * @summary Gets a studio by name.
     * @param {string} name Studio name.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiosApi
     */
    public getStudio(name: string, userId?: string, options?: any) {
        return StudiosApiFp(this.configuration).getStudio(name, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all studios from a given item, folder, or the entire library.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [searchTerm] Optional. Search term.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
     * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
     * @param {boolean} [enableUserData] Optional, include user data.
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
     * @param {string} [userId] User id.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {boolean} [enableImages] Optional, include image information in output.
     * @param {boolean} [enableTotalRecordCount] Total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiosApi
     */
    public getStudios(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return StudiosApiFp(this.configuration).getStudios(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubtitleApi - axios parameter creator
 * @export
 */
export const SubtitleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an external subtitle file.
         * @param {string} itemId The item id.
         * @param {number} index The index of the subtitle file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubtitle: async (itemId: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteSubtitle.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteSubtitle.');
            }
            const localVarPath = `/Videos/{itemId}/Subtitles/{index}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads a remote subtitle.
         * @param {string} itemId The item id.
         * @param {string} subtitleId The subtitle id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteSubtitles: async (itemId: string, subtitleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling downloadRemoteSubtitles.');
            }
            // verify required parameter 'subtitleId' is not null or undefined
            if (subtitleId === null || subtitleId === undefined) {
                throw new RequiredError('subtitleId','Required parameter subtitleId was null or undefined when calling downloadRemoteSubtitles.');
            }
            const localVarPath = `/Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"subtitleId"}}`, encodeURIComponent(String(subtitleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the remote subtitles.
         * @param {string} id The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSubtitles: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRemoteSubtitles.');
            }
            const localVarPath = `/Providers/Subtitles/Subtitles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle: async (itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'startPositionTicks' is not null or undefined
            if (startPositionTicks === null || startPositionTicks === undefined) {
                throw new RequiredError('startPositionTicks','Required parameter startPositionTicks was null or undefined when calling getSubtitle.');
            }
            const localVarPath = `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/Stream.{format}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"startPositionTicks"}}`, encodeURIComponent(String(startPositionTicks)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (endPositionTicks !== undefined) {
                localVarQueryParameter['endPositionTicks'] = endPositionTicks;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (addVttTimeMap !== undefined) {
                localVarQueryParameter['addVttTimeMap'] = addVttTimeMap;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle2: async (itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'startPositionTicks' is not null or undefined
            if (startPositionTicks === null || startPositionTicks === undefined) {
                throw new RequiredError('startPositionTicks','Required parameter startPositionTicks was null or undefined when calling getSubtitle2.');
            }
            const localVarPath = `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/{startPositionTicks}/Stream.{format}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"startPositionTicks"}}`, encodeURIComponent(String(startPositionTicks)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (endPositionTicks !== undefined) {
                localVarQueryParameter['endPositionTicks'] = endPositionTicks;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (addVttTimeMap !== undefined) {
                localVarQueryParameter['addVttTimeMap'] = addVttTimeMap;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an HLS subtitle playlist.
         * @param {string} itemId The item id.
         * @param {number} index The subtitle stream index.
         * @param {string} mediaSourceId The media source id.
         * @param {number} segmentLength The subtitle segment length.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitlePlaylist: async (itemId: string, index: number, mediaSourceId: string, segmentLength: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSubtitlePlaylist.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getSubtitlePlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getSubtitlePlaylist.');
            }
            // verify required parameter 'segmentLength' is not null or undefined
            if (segmentLength === null || segmentLength === undefined) {
                throw new RequiredError('segmentLength','Required parameter segmentLength was null or undefined when calling getSubtitlePlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search remote subtitles.
         * @param {string} itemId The item id.
         * @param {string} language The language of the subtitles.
         * @param {boolean} [isPerfectMatch] Optional. Only show subtitles which are a perfect match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRemoteSubtitles: async (itemId: string, language: string, isPerfectMatch?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling searchRemoteSubtitles.');
            }
            // verify required parameter 'language' is not null or undefined
            if (language === null || language === undefined) {
                throw new RequiredError('language','Required parameter language was null or undefined when calling searchRemoteSubtitles.');
            }
            const localVarPath = `/Items/{itemId}/RemoteSearch/Subtitles/{language}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isPerfectMatch !== undefined) {
                localVarQueryParameter['isPerfectMatch'] = isPerfectMatch;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubtitleApi - functional programming interface
 * @export
 */
export const SubtitleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an external subtitle file.
         * @param {string} itemId The item id.
         * @param {number} index The index of the subtitle file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubtitle(itemId: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).deleteSubtitle(itemId, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Downloads a remote subtitle.
         * @param {string} itemId The item id.
         * @param {string} subtitleId The subtitle id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRemoteSubtitles(itemId: string, subtitleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).downloadRemoteSubtitles(itemId, subtitleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the remote subtitles.
         * @param {string} id The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteSubtitles(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getRemoteSubtitles(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtitle(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getSubtitle(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtitle2(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getSubtitle2(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an HLS subtitle playlist.
         * @param {string} itemId The item id.
         * @param {number} index The subtitle stream index.
         * @param {string} mediaSourceId The media source id.
         * @param {number} segmentLength The subtitle segment length.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtitlePlaylist(itemId: string, index: number, mediaSourceId: string, segmentLength: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getSubtitlePlaylist(itemId, index, mediaSourceId, segmentLength, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search remote subtitles.
         * @param {string} itemId The item id.
         * @param {string} language The language of the subtitles.
         * @param {boolean} [isPerfectMatch] Optional. Only show subtitles which are a perfect match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRemoteSubtitles(itemId: string, language: string, isPerfectMatch?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSubtitleInfo>>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).searchRemoteSubtitles(itemId, language, isPerfectMatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SubtitleApi - factory interface
 * @export
 */
export const SubtitleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes an external subtitle file.
         * @param {string} itemId The item id.
         * @param {number} index The index of the subtitle file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubtitle(itemId: string, index: number, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).deleteSubtitle(itemId, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads a remote subtitle.
         * @param {string} itemId The item id.
         * @param {string} subtitleId The subtitle id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteSubtitles(itemId: string, subtitleId: string, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).downloadRemoteSubtitles(itemId, subtitleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the remote subtitles.
         * @param {string} id The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSubtitles(id: string, options?: any): AxiosPromise<any> {
            return SubtitleApiFp(configuration).getRemoteSubtitles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): AxiosPromise<any> {
            return SubtitleApiFp(configuration).getSubtitle(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle2(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): AxiosPromise<any> {
            return SubtitleApiFp(configuration).getSubtitle2(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an HLS subtitle playlist.
         * @param {string} itemId The item id.
         * @param {number} index The subtitle stream index.
         * @param {string} mediaSourceId The media source id.
         * @param {number} segmentLength The subtitle segment length.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitlePlaylist(itemId: string, index: number, mediaSourceId: string, segmentLength: number, options?: any): AxiosPromise<any> {
            return SubtitleApiFp(configuration).getSubtitlePlaylist(itemId, index, mediaSourceId, segmentLength, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search remote subtitles.
         * @param {string} itemId The item id.
         * @param {string} language The language of the subtitles.
         * @param {boolean} [isPerfectMatch] Optional. Only show subtitles which are a perfect match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRemoteSubtitles(itemId: string, language: string, isPerfectMatch?: boolean, options?: any): AxiosPromise<Array<RemoteSubtitleInfo>> {
            return SubtitleApiFp(configuration).searchRemoteSubtitles(itemId, language, isPerfectMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubtitleApi - object-oriented interface
 * @export
 * @class SubtitleApi
 * @extends {BaseAPI}
 */
export class SubtitleApi extends BaseAPI {
    /**
     * 
     * @summary Deletes an external subtitle file.
     * @param {string} itemId The item id.
     * @param {number} index The index of the subtitle file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public deleteSubtitle(itemId: string, index: number, options?: any) {
        return SubtitleApiFp(this.configuration).deleteSubtitle(itemId, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads a remote subtitle.
     * @param {string} itemId The item id.
     * @param {string} subtitleId The subtitle id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public downloadRemoteSubtitles(itemId: string, subtitleId: string, options?: any) {
        return SubtitleApiFp(this.configuration).downloadRemoteSubtitles(itemId, subtitleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the remote subtitles.
     * @param {string} id The item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getRemoteSubtitles(id: string, options?: any) {
        return SubtitleApiFp(this.configuration).getRemoteSubtitles(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets subtitles in a specified format.
     * @param {string} itemId The item id.
     * @param {string} mediaSourceId The media source id.
     * @param {number} index The subtitle stream index.
     * @param {string} format The format of the returned subtitle.
     * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
     * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
     * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
     * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getSubtitle(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any) {
        return SubtitleApiFp(this.configuration).getSubtitle(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets subtitles in a specified format.
     * @param {string} itemId The item id.
     * @param {string} mediaSourceId The media source id.
     * @param {number} index The subtitle stream index.
     * @param {string} format The format of the returned subtitle.
     * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
     * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
     * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
     * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getSubtitle2(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any) {
        return SubtitleApiFp(this.configuration).getSubtitle2(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an HLS subtitle playlist.
     * @param {string} itemId The item id.
     * @param {number} index The subtitle stream index.
     * @param {string} mediaSourceId The media source id.
     * @param {number} segmentLength The subtitle segment length.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getSubtitlePlaylist(itemId: string, index: number, mediaSourceId: string, segmentLength: number, options?: any) {
        return SubtitleApiFp(this.configuration).getSubtitlePlaylist(itemId, index, mediaSourceId, segmentLength, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search remote subtitles.
     * @param {string} itemId The item id.
     * @param {string} language The language of the subtitles.
     * @param {boolean} [isPerfectMatch] Optional. Only show subtitles which are a perfect match.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public searchRemoteSubtitles(itemId: string, language: string, isPerfectMatch?: boolean, options?: any) {
        return SubtitleApiFp(this.configuration).searchRemoteSubtitles(itemId, language, isPerfectMatch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SuggestionsApi - axios parameter creator
 * @export
 */
export const SuggestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets suggestions.
         * @param {string} userId The user id.
         * @param {string} [mediaType] The media types.
         * @param {string} [type] The type.
         * @param {number} [startIndex] Optional. The start index.
         * @param {number} [limit] Optional. The limit.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions: async (userId: string, mediaType?: string, type?: string, startIndex?: number, limit?: number, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getSuggestions.');
            }
            const localVarPath = `/Users/{userId}/Suggestions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaType !== undefined) {
                localVarQueryParameter['mediaType'] = mediaType;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuggestionsApi - functional programming interface
 * @export
 */
export const SuggestionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets suggestions.
         * @param {string} userId The user id.
         * @param {string} [mediaType] The media types.
         * @param {string} [type] The type.
         * @param {number} [startIndex] Optional. The start index.
         * @param {number} [limit] Optional. The limit.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSuggestions(userId: string, mediaType?: string, type?: string, startIndex?: number, limit?: number, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await SuggestionsApiAxiosParamCreator(configuration).getSuggestions(userId, mediaType, type, startIndex, limit, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SuggestionsApi - factory interface
 * @export
 */
export const SuggestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets suggestions.
         * @param {string} userId The user id.
         * @param {string} [mediaType] The media types.
         * @param {string} [type] The type.
         * @param {number} [startIndex] Optional. The start index.
         * @param {number} [limit] Optional. The limit.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(userId: string, mediaType?: string, type?: string, startIndex?: number, limit?: number, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return SuggestionsApiFp(configuration).getSuggestions(userId, mediaType, type, startIndex, limit, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SuggestionsApi - object-oriented interface
 * @export
 * @class SuggestionsApi
 * @extends {BaseAPI}
 */
export class SuggestionsApi extends BaseAPI {
    /**
     * 
     * @summary Gets suggestions.
     * @param {string} userId The user id.
     * @param {string} [mediaType] The media types.
     * @param {string} [type] The type.
     * @param {number} [startIndex] Optional. The start index.
     * @param {number} [limit] Optional. The limit.
     * @param {boolean} [enableTotalRecordCount] Whether to enable the total record count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuggestionsApi
     */
    public getSuggestions(userId: string, mediaType?: string, type?: string, startIndex?: number, limit?: number, enableTotalRecordCount?: boolean, options?: any) {
        return SuggestionsApiFp(this.configuration).getSuggestions(userId, mediaType, type, startIndex, limit, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SyncPlayApi - axios parameter creator
 * @export
 */
export const SyncPlayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Request group wait in SyncPlay group while buffering.
         * @param {string} [when] When the request has been made by the client.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {boolean} [bufferingDone] Whether the buffering is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayBuffering: async (when?: string, positionTicks?: number, bufferingDone?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Buffering`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (when !== undefined) {
                localVarQueryParameter['when'] = (when as any instanceof Date) ?
                    (when as any).toISOString() :
                    when;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }

            if (bufferingDone !== undefined) {
                localVarQueryParameter['bufferingDone'] = bufferingDone;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayCreateGroup: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/New`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all SyncPlay groups.
         * @param {string} [filterItemId] Optional. Filter by item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayGetGroups: async (filterItemId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/List`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (filterItemId !== undefined) {
                localVarQueryParameter['filterItemId'] = filterItemId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join an existing SyncPlay group.
         * @param {string} groupId The sync play group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayJoinGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling syncPlayJoinGroup.');
            }
            const localVarPath = `/SyncPlay/Join`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave the joined SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayLeaveGroup: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Leave`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request pause in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPause: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Pause`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update session ping.
         * @param {number} [ping] The ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPing: async (ping?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Ping`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ping !== undefined) {
                localVarQueryParameter['ping'] = ping;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request play in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPlay: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Play`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request seek in SyncPlay group.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlaySeek: async (positionTicks?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Seek`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SyncPlayApi - functional programming interface
 * @export
 */
export const SyncPlayApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Request group wait in SyncPlay group while buffering.
         * @param {string} [when] When the request has been made by the client.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {boolean} [bufferingDone] Whether the buffering is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayBuffering(when?: string, positionTicks?: number, bufferingDone?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayBuffering(when, positionTicks, bufferingDone, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayCreateGroup(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayCreateGroup(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all SyncPlay groups.
         * @param {string} [filterItemId] Optional. Filter by item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayGetGroups(filterItemId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupInfoView>>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayGetGroups(filterItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Join an existing SyncPlay group.
         * @param {string} groupId The sync play group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayJoinGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayJoinGroup(groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Leave the joined SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayLeaveGroup(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayLeaveGroup(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Request pause in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayPause(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayPause(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update session ping.
         * @param {number} [ping] The ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayPing(ping?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayPing(ping, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Request play in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayPlay(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayPlay(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Request seek in SyncPlay group.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlaySeek(positionTicks?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlaySeek(positionTicks, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SyncPlayApi - factory interface
 * @export
 */
export const SyncPlayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Request group wait in SyncPlay group while buffering.
         * @param {string} [when] When the request has been made by the client.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {boolean} [bufferingDone] Whether the buffering is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayBuffering(when?: string, positionTicks?: number, bufferingDone?: boolean, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayBuffering(when, positionTicks, bufferingDone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayCreateGroup(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayCreateGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all SyncPlay groups.
         * @param {string} [filterItemId] Optional. Filter by item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayGetGroups(filterItemId?: string, options?: any): AxiosPromise<Array<GroupInfoView>> {
            return SyncPlayApiFp(configuration).syncPlayGetGroups(filterItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join an existing SyncPlay group.
         * @param {string} groupId The sync play group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayJoinGroup(groupId: string, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayJoinGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave the joined SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayLeaveGroup(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayLeaveGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request pause in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPause(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayPause(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update session ping.
         * @param {number} [ping] The ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPing(ping?: number, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayPing(ping, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request play in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPlay(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayPlay(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request seek in SyncPlay group.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlaySeek(positionTicks?: number, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlaySeek(positionTicks, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SyncPlayApi - object-oriented interface
 * @export
 * @class SyncPlayApi
 * @extends {BaseAPI}
 */
export class SyncPlayApi extends BaseAPI {
    /**
     * 
     * @summary Request group wait in SyncPlay group while buffering.
     * @param {string} [when] When the request has been made by the client.
     * @param {number} [positionTicks] The playback position in ticks.
     * @param {boolean} [bufferingDone] Whether the buffering is done.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayBuffering(when?: string, positionTicks?: number, bufferingDone?: boolean, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayBuffering(when, positionTicks, bufferingDone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new SyncPlay group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayCreateGroup(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayCreateGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all SyncPlay groups.
     * @param {string} [filterItemId] Optional. Filter by item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayGetGroups(filterItemId?: string, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayGetGroups(filterItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join an existing SyncPlay group.
     * @param {string} groupId The sync play group id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayJoinGroup(groupId: string, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayJoinGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave the joined SyncPlay group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayLeaveGroup(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayLeaveGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request pause in SyncPlay group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayPause(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayPause(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update session ping.
     * @param {number} [ping] The ping.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayPing(ping?: number, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayPing(ping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request play in SyncPlay group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayPlay(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayPlay(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request seek in SyncPlay group.
     * @param {number} [positionTicks] The playback position in ticks.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlaySeek(positionTicks?: number, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlaySeek(positionTicks, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets information about the request endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEndpointInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Endpoint`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a log file.
         * @param {string} name The name of the log file to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogFile: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getLogFile.');
            }
            const localVarPath = `/System/Logs/Log`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingSystem: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Ping`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets public information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicSystemInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Info/Public`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of available server log files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerLogs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Logs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Info`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets wake on lan information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWakeOnLanInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/WakeOnLanInfo`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPingSystem: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Ping`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restarts the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartApplication: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Restart`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Shuts down the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownApplication: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Shutdown`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets information about the request endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEndpointInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndPointInfo>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getEndpointInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a log file.
         * @param {string} name The name of the log file to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogFile(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getLogFile(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingSystem(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getPingSystem(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets public information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicSystemInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicSystemInfo>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getPublicSystemInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of available server log files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerLogs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogFile>>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getServerLogs(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getSystemInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets wake on lan information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWakeOnLanInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WakeOnLanInfo>>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getWakeOnLanInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPingSystem(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).postPingSystem(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Restarts the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartApplication(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).restartApplication(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Shuts down the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shutdownApplication(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).shutdownApplication(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets information about the request endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEndpointInfo(options?: any): AxiosPromise<EndPointInfo> {
            return SystemApiFp(configuration).getEndpointInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a log file.
         * @param {string} name The name of the log file to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogFile(name: string, options?: any): AxiosPromise<any> {
            return SystemApiFp(configuration).getLogFile(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingSystem(options?: any): AxiosPromise<string> {
            return SystemApiFp(configuration).getPingSystem(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets public information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicSystemInfo(options?: any): AxiosPromise<PublicSystemInfo> {
            return SystemApiFp(configuration).getPublicSystemInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of available server log files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerLogs(options?: any): AxiosPromise<Array<LogFile>> {
            return SystemApiFp(configuration).getServerLogs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemInfo(options?: any): AxiosPromise<SystemInfo> {
            return SystemApiFp(configuration).getSystemInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets wake on lan information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWakeOnLanInfo(options?: any): AxiosPromise<Array<WakeOnLanInfo>> {
            return SystemApiFp(configuration).getWakeOnLanInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPingSystem(options?: any): AxiosPromise<string> {
            return SystemApiFp(configuration).postPingSystem(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restarts the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartApplication(options?: any): AxiosPromise<void> {
            return SystemApiFp(configuration).restartApplication(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Shuts down the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownApplication(options?: any): AxiosPromise<void> {
            return SystemApiFp(configuration).shutdownApplication(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @summary Gets information about the request endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getEndpointInfo(options?: any) {
        return SystemApiFp(this.configuration).getEndpointInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a log file.
     * @param {string} name The name of the log file to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getLogFile(name: string, options?: any) {
        return SystemApiFp(this.configuration).getLogFile(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pings the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getPingSystem(options?: any) {
        return SystemApiFp(this.configuration).getPingSystem(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets public information about the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getPublicSystemInfo(options?: any) {
        return SystemApiFp(this.configuration).getPublicSystemInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of available server log files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getServerLogs(options?: any) {
        return SystemApiFp(this.configuration).getServerLogs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets information about the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getSystemInfo(options?: any) {
        return SystemApiFp(this.configuration).getSystemInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets wake on lan information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getWakeOnLanInfo(options?: any) {
        return SystemApiFp(this.configuration).getWakeOnLanInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pings the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public postPingSystem(options?: any) {
        return SystemApiFp(this.configuration).postPingSystem(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restarts the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public restartApplication(options?: any) {
        return SystemApiFp(this.configuration).restartApplication(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Shuts down the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public shutdownApplication(options?: any) {
        return SystemApiFp(this.configuration).shutdownApplication(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimeSyncApi - axios parameter creator
 * @export
 */
export const TimeSyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the current utc time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUtcTime: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/GetUtcTime`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeSyncApi - functional programming interface
 * @export
 */
export const TimeSyncApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the current utc time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUtcTime(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtcTimeResponse>> {
            const localVarAxiosArgs = await TimeSyncApiAxiosParamCreator(configuration).getUtcTime(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TimeSyncApi - factory interface
 * @export
 */
export const TimeSyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets the current utc time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUtcTime(options?: any): AxiosPromise<UtcTimeResponse> {
            return TimeSyncApiFp(configuration).getUtcTime(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeSyncApi - object-oriented interface
 * @export
 * @class TimeSyncApi
 * @extends {BaseAPI}
 */
export class TimeSyncApi extends BaseAPI {
    /**
     * 
     * @summary Gets the current utc time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSyncApi
     */
    public getUtcTime(options?: any) {
        return TimeSyncApiFp(this.configuration).getUtcTime(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrailersApi - axios parameter creator
 * @export
 */
export const TrailersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Finds movies and trailers similar to a given trailer.
         * @param {string} [userId] The user id.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailers: async (userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Trailers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['maxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['hasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['hasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['hasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['hasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['hasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['parentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['hasParentalRating'] = hasParentalRating;
            }

            if (isHd !== undefined) {
                localVarQueryParameter['isHd'] = isHd;
            }

            if (is4K !== undefined) {
                localVarQueryParameter['is4K'] = is4K;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['locationTypes'] = locationTypes;
            }

            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter['excludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['isUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['minCriticRating'] = minCriticRating;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['minPremiereDate'] = (minPremiereDate as any instanceof Date) ?
                    (minPremiereDate as any).toISOString() :
                    minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['minDateLastSaved'] = (minDateLastSaved as any instanceof Date) ?
                    (minDateLastSaved as any).toISOString() :
                    minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['minDateLastSavedForUser'] = (minDateLastSavedForUser as any instanceof Date) ?
                    (minDateLastSavedForUser as any).toISOString() :
                    minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['maxPremiereDate'] = (maxPremiereDate as any instanceof Date) ?
                    (maxPremiereDate as any).toISOString() :
                    maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['hasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['hasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['hasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['hasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['excludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (imageTypes !== undefined) {
                localVarQueryParameter['imageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (artists !== undefined) {
                localVarQueryParameter['artists'] = artists;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['artistIds'] = artistIds;
            }

            if (albumArtistIds !== undefined) {
                localVarQueryParameter['albumArtistIds'] = albumArtistIds;
            }

            if (contributingArtistIds !== undefined) {
                localVarQueryParameter['contributingArtistIds'] = contributingArtistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['albums'] = albums;
            }

            if (albumIds !== undefined) {
                localVarQueryParameter['albumIds'] = albumIds;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['videoTypes'] = videoTypes;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['minOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['isPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['hasOfficialRating'] = hasOfficialRating;
            }

            if (collapseBoxSetItems !== undefined) {
                localVarQueryParameter['collapseBoxSetItems'] = collapseBoxSetItems;
            }

            if (minWidth !== undefined) {
                localVarQueryParameter['minWidth'] = minWidth;
            }

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['seriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrailersApi - functional programming interface
 * @export
 */
export const TrailersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Finds movies and trailers similar to a given trailer.
         * @param {string} [userId] The user id.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrailers(userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TrailersApiAxiosParamCreator(configuration).getTrailers(userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TrailersApi - factory interface
 * @export
 */
export const TrailersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Finds movies and trailers similar to a given trailer.
         * @param {string} [userId] The user id.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailers(userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TrailersApiFp(configuration).getTrailers(userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrailersApi - object-oriented interface
 * @export
 * @class TrailersApi
 * @extends {BaseAPI}
 */
export class TrailersApi extends BaseAPI {
    /**
     * 
     * @summary Finds movies and trailers similar to a given trailer.
     * @param {string} [userId] The user id.
     * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
     * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
     * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
     * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
     * @param {boolean} [hasTrailer] Optional filter by items with trailers.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {number} [parentIndexNumber] Optional filter by parent index number.
     * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
     * @param {boolean} [isHd] Optional filter by items that are HD or not.
     * @param {boolean} [is4K] Optional filter by items that are 4K or not.
     * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param {string} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
     * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
     * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
     * @param {number} [minCommunityRating] Optional filter by minimum community rating.
     * @param {number} [minCriticRating] Optional filter by minimum critic rating.
     * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
     * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
     * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
     * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
     * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
     * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
     * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
     * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
     * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
     * @param {string} [searchTerm] Optional. Filter based on a search term.
     * @param {string} [sortOrder] Sort Order - Ascending,Descending.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {string} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
     * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
     * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param {boolean} [enableUserData] Optional, include user data.
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
     * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
     * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
     * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
     * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
     * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
     * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
     * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
     * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param {boolean} [isLocked] Optional filter by items that are locked.
     * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
     * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
     * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
     * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
     * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
     * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
     * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
     * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
     * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
     * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
     * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
     * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
     * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
     * @param {boolean} [enableImages] Optional, include image information in output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrailersApi
     */
    public getTrailers(userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any) {
        return TrailersApiFp(this.configuration).getTrailers(userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TvShowsApi - axios parameter creator
 * @export
 */
export const TvShowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets episodes for a tv season.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {number} [season] Optional filter by season number.
         * @param {string} [seasonId] Optional. Filter by season id.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {string} [startItemId] Optional. Skip through the list until a given item is found.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEpisodes: async (seriesId: string, userId?: string, fields?: string, season?: number, seasonId?: string, isMissing?: boolean, adjacentTo?: string, startItemId?: string, startIndex?: number, limit?: number, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'seriesId' is not null or undefined
            if (seriesId === null || seriesId === undefined) {
                throw new RequiredError('seriesId','Required parameter seriesId was null or undefined when calling getEpisodes.');
            }
            const localVarPath = `/Shows/{seriesId}/Episodes`
                .replace(`{${"seriesId"}}`, encodeURIComponent(String(seriesId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (seasonId !== undefined) {
                localVarQueryParameter['seasonId'] = seasonId;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (startItemId !== undefined) {
                localVarQueryParameter['startItemId'] = startItemId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of next up episodes.
         * @param {string} [userId] The user id of the user to get the next up episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {string} [seriesId] Optional. Filter by series id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total records count. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextUp: async (userId?: string, startIndex?: number, limit?: number, fields?: string, seriesId?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Shows/NextUp`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (seriesId !== undefined) {
                localVarQueryParameter['seriesId'] = seriesId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (enableImges !== undefined) {
                localVarQueryParameter['enableImges'] = enableImges;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets seasons for a tv series.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [isSpecialSeason] Optional. Filter by special season.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeasons: async (seriesId: string, userId?: string, fields?: string, isSpecialSeason?: boolean, isMissing?: boolean, adjacentTo?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'seriesId' is not null or undefined
            if (seriesId === null || seriesId === undefined) {
                throw new RequiredError('seriesId','Required parameter seriesId was null or undefined when calling getSeasons.');
            }
            const localVarPath = `/Shows/{seriesId}/Seasons`
                .replace(`{${"seriesId"}}`, encodeURIComponent(String(seriesId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (isSpecialSeason !== undefined) {
                localVarQueryParameter['isSpecialSeason'] = isSpecialSeason;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of upcoming episodes.
         * @param {string} [userId] The user id of the user to get the upcoming episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingEpisodes: async (userId?: string, startIndex?: number, limit?: number, fields?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Shows/Upcoming`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (enableImges !== undefined) {
                localVarQueryParameter['enableImges'] = enableImges;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TvShowsApi - functional programming interface
 * @export
 */
export const TvShowsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets episodes for a tv season.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {number} [season] Optional filter by season number.
         * @param {string} [seasonId] Optional. Filter by season id.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {string} [startItemId] Optional. Skip through the list until a given item is found.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEpisodes(seriesId: string, userId?: string, fields?: string, season?: number, seasonId?: string, isMissing?: boolean, adjacentTo?: string, startItemId?: string, startIndex?: number, limit?: number, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getEpisodes(seriesId, userId, fields, season, seasonId, isMissing, adjacentTo, startItemId, startIndex, limit, enableImages, imageTypeLimit, enableImageTypes, enableUserData, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of next up episodes.
         * @param {string} [userId] The user id of the user to get the next up episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {string} [seriesId] Optional. Filter by series id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total records count. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextUp(userId?: string, startIndex?: number, limit?: number, fields?: string, seriesId?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getNextUp(userId, startIndex, limit, fields, seriesId, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets seasons for a tv series.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [isSpecialSeason] Optional. Filter by special season.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeasons(seriesId: string, userId?: string, fields?: string, isSpecialSeason?: boolean, isMissing?: boolean, adjacentTo?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getSeasons(seriesId, userId, fields, isSpecialSeason, isMissing, adjacentTo, enableImages, imageTypeLimit, enableImageTypes, enableUserData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of upcoming episodes.
         * @param {string} [userId] The user id of the user to get the upcoming episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpcomingEpisodes(userId?: string, startIndex?: number, limit?: number, fields?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getUpcomingEpisodes(userId, startIndex, limit, fields, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TvShowsApi - factory interface
 * @export
 */
export const TvShowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets episodes for a tv season.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {number} [season] Optional filter by season number.
         * @param {string} [seasonId] Optional. Filter by season id.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {string} [startItemId] Optional. Skip through the list until a given item is found.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEpisodes(seriesId: string, userId?: string, fields?: string, season?: number, seasonId?: string, isMissing?: boolean, adjacentTo?: string, startItemId?: string, startIndex?: number, limit?: number, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, sortBy?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getEpisodes(seriesId, userId, fields, season, seasonId, isMissing, adjacentTo, startItemId, startIndex, limit, enableImages, imageTypeLimit, enableImageTypes, enableUserData, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of next up episodes.
         * @param {string} [userId] The user id of the user to get the next up episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {string} [seriesId] Optional. Filter by series id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total records count. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextUp(userId?: string, startIndex?: number, limit?: number, fields?: string, seriesId?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getNextUp(userId, startIndex, limit, fields, seriesId, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets seasons for a tv series.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [isSpecialSeason] Optional. Filter by special season.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeasons(seriesId: string, userId?: string, fields?: string, isSpecialSeason?: boolean, isMissing?: boolean, adjacentTo?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getSeasons(seriesId, userId, fields, isSpecialSeason, isMissing, adjacentTo, enableImages, imageTypeLimit, enableImageTypes, enableUserData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of upcoming episodes.
         * @param {string} [userId] The user id of the user to get the upcoming episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingEpisodes(userId?: string, startIndex?: number, limit?: number, fields?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getUpcomingEpisodes(userId, startIndex, limit, fields, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TvShowsApi - object-oriented interface
 * @export
 * @class TvShowsApi
 * @extends {BaseAPI}
 */
export class TvShowsApi extends BaseAPI {
    /**
     * 
     * @summary Gets episodes for a tv season.
     * @param {string} seriesId The series id.
     * @param {string} [userId] The user id.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {number} [season] Optional filter by season number.
     * @param {string} [seasonId] Optional. Filter by season id.
     * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {string} [startItemId] Optional. Skip through the list until a given item is found.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {boolean} [enableImages] Optional, include image information in output.
     * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getEpisodes(seriesId: string, userId?: string, fields?: string, season?: number, seasonId?: string, isMissing?: boolean, adjacentTo?: string, startItemId?: string, startIndex?: number, limit?: number, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, sortBy?: string, options?: any) {
        return TvShowsApiFp(this.configuration).getEpisodes(seriesId, userId, fields, season, seasonId, isMissing, adjacentTo, startItemId, startIndex, limit, enableImages, imageTypeLimit, enableImageTypes, enableUserData, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of next up episodes.
     * @param {string} [userId] The user id of the user to get the next up episodes for.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {string} [seriesId] Optional. Filter by series id.
     * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {boolean} [enableImges] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {boolean} [enableTotalRecordCount] Whether to enable the total records count. Defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getNextUp(userId?: string, startIndex?: number, limit?: number, fields?: string, seriesId?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any) {
        return TvShowsApiFp(this.configuration).getNextUp(userId, startIndex, limit, fields, seriesId, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets seasons for a tv series.
     * @param {string} seriesId The series id.
     * @param {string} [userId] The user id.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {boolean} [isSpecialSeason] Optional. Filter by special season.
     * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
     * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getSeasons(seriesId: string, userId?: string, fields?: string, isSpecialSeason?: boolean, isMissing?: boolean, adjacentTo?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options?: any) {
        return TvShowsApiFp(this.configuration).getSeasons(seriesId, userId, fields, isSpecialSeason, isMissing, adjacentTo, enableImages, imageTypeLimit, enableImageTypes, enableUserData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of upcoming episodes.
     * @param {string} [userId] The user id of the user to get the upcoming episodes for.
     * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {boolean} [enableImges] Optional. Include image information in output.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getUpcomingEpisodes(userId?: string, startIndex?: number, limit?: number, fields?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options?: any) {
        return TvShowsApiFp(this.configuration).getUpcomingEpisodes(userId, startIndex, limit, fields, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UniversalAudioApi - axios parameter creator
 * @export
 */
export const UniversalAudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalAudioStream: async (itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getUniversalAudioStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getUniversalAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/universal`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (transcodingAudioChannels !== undefined) {
                localVarQueryParameter['transcodingAudioChannels'] = transcodingAudioChannels;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (transcodingContainer !== undefined) {
                localVarQueryParameter['transcodingContainer'] = transcodingContainer;
            }

            if (transcodingProtocol !== undefined) {
                localVarQueryParameter['transcodingProtocol'] = transcodingProtocol;
            }

            if (maxAudioSampleRate !== undefined) {
                localVarQueryParameter['maxAudioSampleRate'] = maxAudioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (enableRemoteMedia !== undefined) {
                localVarQueryParameter['enableRemoteMedia'] = enableRemoteMedia;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (enableRedirection !== undefined) {
                localVarQueryParameter['enableRedirection'] = enableRedirection;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalAudioStream2: async (itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getUniversalAudioStream2.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getUniversalAudioStream2.');
            }
            const localVarPath = `/Audio/{itemId}/universal.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (transcodingAudioChannels !== undefined) {
                localVarQueryParameter['transcodingAudioChannels'] = transcodingAudioChannels;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (transcodingContainer !== undefined) {
                localVarQueryParameter['transcodingContainer'] = transcodingContainer;
            }

            if (transcodingProtocol !== undefined) {
                localVarQueryParameter['transcodingProtocol'] = transcodingProtocol;
            }

            if (maxAudioSampleRate !== undefined) {
                localVarQueryParameter['maxAudioSampleRate'] = maxAudioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (enableRemoteMedia !== undefined) {
                localVarQueryParameter['enableRemoteMedia'] = enableRemoteMedia;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (enableRedirection !== undefined) {
                localVarQueryParameter['enableRedirection'] = enableRedirection;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUniversalAudioStream: async (itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headUniversalAudioStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headUniversalAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/universal`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (transcodingAudioChannels !== undefined) {
                localVarQueryParameter['transcodingAudioChannels'] = transcodingAudioChannels;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (transcodingContainer !== undefined) {
                localVarQueryParameter['transcodingContainer'] = transcodingContainer;
            }

            if (transcodingProtocol !== undefined) {
                localVarQueryParameter['transcodingProtocol'] = transcodingProtocol;
            }

            if (maxAudioSampleRate !== undefined) {
                localVarQueryParameter['maxAudioSampleRate'] = maxAudioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (enableRemoteMedia !== undefined) {
                localVarQueryParameter['enableRemoteMedia'] = enableRemoteMedia;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (enableRedirection !== undefined) {
                localVarQueryParameter['enableRedirection'] = enableRedirection;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUniversalAudioStream2: async (itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headUniversalAudioStream2.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headUniversalAudioStream2.');
            }
            const localVarPath = `/Audio/{itemId}/universal.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (transcodingAudioChannels !== undefined) {
                localVarQueryParameter['transcodingAudioChannels'] = transcodingAudioChannels;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (transcodingContainer !== undefined) {
                localVarQueryParameter['transcodingContainer'] = transcodingContainer;
            }

            if (transcodingProtocol !== undefined) {
                localVarQueryParameter['transcodingProtocol'] = transcodingProtocol;
            }

            if (maxAudioSampleRate !== undefined) {
                localVarQueryParameter['maxAudioSampleRate'] = maxAudioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (enableRemoteMedia !== undefined) {
                localVarQueryParameter['enableRemoteMedia'] = enableRemoteMedia;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (enableRedirection !== undefined) {
                localVarQueryParameter['enableRedirection'] = enableRedirection;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UniversalAudioApi - functional programming interface
 * @export
 */
export const UniversalAudioApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniversalAudioStream(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UniversalAudioApiAxiosParamCreator(configuration).getUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniversalAudioStream2(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UniversalAudioApiAxiosParamCreator(configuration).getUniversalAudioStream2(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUniversalAudioStream(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UniversalAudioApiAxiosParamCreator(configuration).headUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUniversalAudioStream2(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UniversalAudioApiAxiosParamCreator(configuration).headUniversalAudioStream2(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UniversalAudioApi - factory interface
 * @export
 */
export const UniversalAudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalAudioStream(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): AxiosPromise<any> {
            return UniversalAudioApiFp(configuration).getUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalAudioStream2(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): AxiosPromise<any> {
            return UniversalAudioApiFp(configuration).getUniversalAudioStream2(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUniversalAudioStream(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): AxiosPromise<any> {
            return UniversalAudioApiFp(configuration).headUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUniversalAudioStream2(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): AxiosPromise<any> {
            return UniversalAudioApiFp(configuration).headUniversalAudioStream2(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UniversalAudioApi - object-oriented interface
 * @export
 * @class UniversalAudioApi
 * @extends {BaseAPI}
 */
export class UniversalAudioApi extends BaseAPI {
    /**
     * 
     * @summary Gets an audio stream.
     * @param {string} itemId The item id.
     * @param {string} container Optional. The audio container.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [userId] Optional. The user id.
     * @param {string} [audioCodec] Optional. The audio codec to transcode to.
     * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
     * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
     * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {string} [transcodingContainer] Optional. The container to transcode to.
     * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
     * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalAudioApi
     */
    public getUniversalAudioStream(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any) {
        return UniversalAudioApiFp(this.configuration).getUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream.
     * @param {string} itemId The item id.
     * @param {string} container Optional. The audio container.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [userId] Optional. The user id.
     * @param {string} [audioCodec] Optional. The audio codec to transcode to.
     * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
     * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
     * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {string} [transcodingContainer] Optional. The container to transcode to.
     * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
     * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalAudioApi
     */
    public getUniversalAudioStream2(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any) {
        return UniversalAudioApiFp(this.configuration).getUniversalAudioStream2(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream.
     * @param {string} itemId The item id.
     * @param {string} container Optional. The audio container.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [userId] Optional. The user id.
     * @param {string} [audioCodec] Optional. The audio codec to transcode to.
     * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
     * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
     * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {string} [transcodingContainer] Optional. The container to transcode to.
     * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
     * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalAudioApi
     */
    public headUniversalAudioStream(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any) {
        return UniversalAudioApiFp(this.configuration).headUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream.
     * @param {string} itemId The item id.
     * @param {string} container Optional. The audio container.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [userId] Optional. The user id.
     * @param {string} [audioCodec] Optional. The audio codec to transcode to.
     * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
     * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
     * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {string} [transcodingContainer] Optional. The container to transcode to.
     * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
     * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalAudioApi
     */
    public headUniversalAudioStream2(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any) {
        return UniversalAudioApiFp(this.configuration).headUniversalAudioStream2(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticates a user.
         * @param {string} userId The user id.
         * @param {string} pw The password as plain text.
         * @param {string} [password] The password sha1-hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser: async (userId: string, pw: string, password?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling authenticateUser.');
            }
            // verify required parameter 'pw' is not null or undefined
            if (pw === null || pw === undefined) {
                throw new RequiredError('pw','Required parameter pw was null or undefined when calling authenticateUser.');
            }
            const localVarPath = `/Users/{userId}/Authenticate`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (pw !== undefined) {
                localVarQueryParameter['pw'] = pw;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticates a user by name.
         * @param {AuthenticateUserByName} authenticateUserByName The M:Jellyfin.Api.Controllers.UserController.AuthenticateUserByName(Jellyfin.Api.Models.UserDtos.AuthenticateUserByName) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUserByName: async (authenticateUserByName: AuthenticateUserByName, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateUserByName' is not null or undefined
            if (authenticateUserByName === null || authenticateUserByName === undefined) {
                throw new RequiredError('authenticateUserByName','Required parameter authenticateUserByName was null or undefined when calling authenticateUserByName.');
            }
            const localVarPath = `/Users/AuthenticateByName`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof authenticateUserByName !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authenticateUserByName !== undefined ? authenticateUserByName : {}) : (authenticateUserByName || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticates a user with quick connect.
         * @param {QuickConnectDto} quickConnectDto The Jellyfin.Api.Models.UserDtos.QuickConnectDto request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateWithQuickConnect: async (quickConnectDto: QuickConnectDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'quickConnectDto' is not null or undefined
            if (quickConnectDto === null || quickConnectDto === undefined) {
                throw new RequiredError('quickConnectDto','Required parameter quickConnectDto was null or undefined when calling authenticateWithQuickConnect.');
            }
            const localVarPath = `/Users/AuthenticateWithQuickConnect`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof quickConnectDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(quickConnectDto !== undefined ? quickConnectDto : {}) : (quickConnectDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a user.
         * @param {CreateUserByName} [createUserByName] The create user by name request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByName: async (createUserByName?: CreateUserByName, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/New`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createUserByName !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createUserByName !== undefined ? createUserByName : {}) : (createUserByName || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a user.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/Users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiates the forgot password process for a local user.
         * @param {ForgotPasswordDto} forgotPasswordDto The forgot password request containing the entered username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (forgotPasswordDto: ForgotPasswordDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordDto' is not null or undefined
            if (forgotPasswordDto === null || forgotPasswordDto === undefined) {
                throw new RequiredError('forgotPasswordDto','Required parameter forgotPasswordDto was null or undefined when calling forgotPassword.');
            }
            const localVarPath = `/Users/ForgotPassword`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof forgotPasswordDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(forgotPasswordDto !== undefined ? forgotPasswordDto : {}) : (forgotPasswordDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeems a forgot password pin.
         * @param {string} [body] The pin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPasswordPin: async (body?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/ForgotPassword/Pin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of publicly visible users for display on a login screen.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/Public`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a user by Id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserById.');
            }
            const localVarPath = `/Users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of users.
         * @param {boolean} [isHidden] Optional filter by IsHidden&#x3D;true or false.
         * @param {boolean} [isDisabled] Optional filter by IsDisabled&#x3D;true or false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (isHidden?: boolean, isDisabled?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isHidden !== undefined) {
                localVarQueryParameter['isHidden'] = isHidden;
            }

            if (isDisabled !== undefined) {
                localVarQueryParameter['isDisabled'] = isDisabled;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user.
         * @param {string} userId The user id.
         * @param {UserDto} [userDto] The updated user model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, userDto?: UserDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            const localVarPath = `/Users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userDto !== undefined ? userDto : {}) : (userDto || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user configuration.
         * @param {string} userId The user id.
         * @param {UserConfiguration} [userConfiguration] The new user configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserConfiguration: async (userId: string, userConfiguration?: UserConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserConfiguration.');
            }
            const localVarPath = `/Users/{userId}/Configuration`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userConfiguration !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userConfiguration !== undefined ? userConfiguration : {}) : (userConfiguration || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user\'s easy password.
         * @param {string} userId The user id.
         * @param {UpdateUserEasyPassword} [updateUserEasyPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserEasyPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserEasyPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEasyPassword: async (userId: string, updateUserEasyPassword?: UpdateUserEasyPassword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserEasyPassword.');
            }
            const localVarPath = `/Users/{userId}/EasyPassword`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserEasyPassword !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserEasyPassword !== undefined ? updateUserEasyPassword : {}) : (updateUserEasyPassword || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user\'s password.
         * @param {string} userId The user id.
         * @param {UpdateUserPassword} [updateUserPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (userId: string, updateUserPassword?: UpdateUserPassword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserPassword.');
            }
            const localVarPath = `/Users/{userId}/Password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserPassword !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserPassword !== undefined ? updateUserPassword : {}) : (updateUserPassword || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user policy.
         * @param {string} userId The user id.
         * @param {UserPolicy} [userPolicy] The new user policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPolicy: async (userId: string, userPolicy?: UserPolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserPolicy.');
            }
            const localVarPath = `/Users/{userId}/Policy`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userPolicy !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userPolicy !== undefined ? userPolicy : {}) : (userPolicy || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticates a user.
         * @param {string} userId The user id.
         * @param {string} pw The password as plain text.
         * @param {string} [password] The password sha1-hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateUser(userId: string, pw: string, password?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).authenticateUser(userId, pw, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Authenticates a user by name.
         * @param {AuthenticateUserByName} authenticateUserByName The M:Jellyfin.Api.Controllers.UserController.AuthenticateUserByName(Jellyfin.Api.Models.UserDtos.AuthenticateUserByName) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateUserByName(authenticateUserByName: AuthenticateUserByName, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).authenticateUserByName(authenticateUserByName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Authenticates a user with quick connect.
         * @param {QuickConnectDto} quickConnectDto The Jellyfin.Api.Models.UserDtos.QuickConnectDto request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateWithQuickConnect(quickConnectDto: QuickConnectDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).authenticateWithQuickConnect(quickConnectDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a user.
         * @param {CreateUserByName} [createUserByName] The create user by name request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserByName(createUserByName?: CreateUserByName, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).createUserByName(createUserByName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a user.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).deleteUser(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Initiates the forgot password process for a local user.
         * @param {ForgotPasswordDto} forgotPasswordDto The forgot password request containing the entered username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgotPasswordResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).forgotPassword(forgotPasswordDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Redeems a forgot password pin.
         * @param {string} [body] The pin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPasswordPin(body?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinRedeemResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).forgotPasswordPin(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of publicly visible users for display on a login screen.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getPublicUsers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a user by Id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUserById(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of users.
         * @param {boolean} [isHidden] Optional filter by IsHidden&#x3D;true or false.
         * @param {boolean} [isDisabled] Optional filter by IsDisabled&#x3D;true or false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(isHidden?: boolean, isDisabled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUsers(isHidden, isDisabled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user.
         * @param {string} userId The user id.
         * @param {UserDto} [userDto] The updated user model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, userDto?: UserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUser(userId, userDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user configuration.
         * @param {string} userId The user id.
         * @param {UserConfiguration} [userConfiguration] The new user configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserConfiguration(userId: string, userConfiguration?: UserConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserConfiguration(userId, userConfiguration, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user\'s easy password.
         * @param {string} userId The user id.
         * @param {UpdateUserEasyPassword} [updateUserEasyPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserEasyPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserEasyPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserEasyPassword(userId: string, updateUserEasyPassword?: UpdateUserEasyPassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserEasyPassword(userId, updateUserEasyPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user\'s password.
         * @param {string} userId The user id.
         * @param {UpdateUserPassword} [updateUserPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(userId: string, updateUserPassword?: UpdateUserPassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserPassword(userId, updateUserPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user policy.
         * @param {string} userId The user id.
         * @param {UserPolicy} [userPolicy] The new user policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPolicy(userId: string, userPolicy?: UserPolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserPolicy(userId, userPolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Authenticates a user.
         * @param {string} userId The user id.
         * @param {string} pw The password as plain text.
         * @param {string} [password] The password sha1-hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(userId: string, pw: string, password?: string, options?: any): AxiosPromise<AuthenticationResult> {
            return UserApiFp(configuration).authenticateUser(userId, pw, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticates a user by name.
         * @param {AuthenticateUserByName} authenticateUserByName The M:Jellyfin.Api.Controllers.UserController.AuthenticateUserByName(Jellyfin.Api.Models.UserDtos.AuthenticateUserByName) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUserByName(authenticateUserByName: AuthenticateUserByName, options?: any): AxiosPromise<AuthenticationResult> {
            return UserApiFp(configuration).authenticateUserByName(authenticateUserByName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticates a user with quick connect.
         * @param {QuickConnectDto} quickConnectDto The Jellyfin.Api.Models.UserDtos.QuickConnectDto request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateWithQuickConnect(quickConnectDto: QuickConnectDto, options?: any): AxiosPromise<AuthenticationResult> {
            return UserApiFp(configuration).authenticateWithQuickConnect(quickConnectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a user.
         * @param {CreateUserByName} [createUserByName] The create user by name request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByName(createUserByName?: CreateUserByName, options?: any): AxiosPromise<UserDto> {
            return UserApiFp(configuration).createUserByName(createUserByName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a user.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiates the forgot password process for a local user.
         * @param {ForgotPasswordDto} forgotPasswordDto The forgot password request containing the entered username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any): AxiosPromise<ForgotPasswordResult> {
            return UserApiFp(configuration).forgotPassword(forgotPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeems a forgot password pin.
         * @param {string} [body] The pin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPasswordPin(body?: string, options?: any): AxiosPromise<PinRedeemResult> {
            return UserApiFp(configuration).forgotPasswordPin(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of publicly visible users for display on a login screen.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUsers(options?: any): AxiosPromise<Array<UserDto>> {
            return UserApiFp(configuration).getPublicUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a user by Id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: any): AxiosPromise<UserDto> {
            return UserApiFp(configuration).getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of users.
         * @param {boolean} [isHidden] Optional filter by IsHidden&#x3D;true or false.
         * @param {boolean} [isDisabled] Optional filter by IsDisabled&#x3D;true or false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(isHidden?: boolean, isDisabled?: boolean, options?: any): AxiosPromise<Array<UserDto>> {
            return UserApiFp(configuration).getUsers(isHidden, isDisabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user.
         * @param {string} userId The user id.
         * @param {UserDto} [userDto] The updated user model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, userDto?: UserDto, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUser(userId, userDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user configuration.
         * @param {string} userId The user id.
         * @param {UserConfiguration} [userConfiguration] The new user configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserConfiguration(userId: string, userConfiguration?: UserConfiguration, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserConfiguration(userId, userConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user\'s easy password.
         * @param {string} userId The user id.
         * @param {UpdateUserEasyPassword} [updateUserEasyPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserEasyPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserEasyPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEasyPassword(userId: string, updateUserEasyPassword?: UpdateUserEasyPassword, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserEasyPassword(userId, updateUserEasyPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user\'s password.
         * @param {string} userId The user id.
         * @param {UpdateUserPassword} [updateUserPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(userId: string, updateUserPassword?: UpdateUserPassword, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserPassword(userId, updateUserPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user policy.
         * @param {string} userId The user id.
         * @param {UserPolicy} [userPolicy] The new user policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPolicy(userId: string, userPolicy?: UserPolicy, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserPolicy(userId, userPolicy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Authenticates a user.
     * @param {string} userId The user id.
     * @param {string} pw The password as plain text.
     * @param {string} [password] The password sha1-hash.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticateUser(userId: string, pw: string, password?: string, options?: any) {
        return UserApiFp(this.configuration).authenticateUser(userId, pw, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticates a user by name.
     * @param {AuthenticateUserByName} authenticateUserByName The M:Jellyfin.Api.Controllers.UserController.AuthenticateUserByName(Jellyfin.Api.Models.UserDtos.AuthenticateUserByName) request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticateUserByName(authenticateUserByName: AuthenticateUserByName, options?: any) {
        return UserApiFp(this.configuration).authenticateUserByName(authenticateUserByName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticates a user with quick connect.
     * @param {QuickConnectDto} quickConnectDto The Jellyfin.Api.Models.UserDtos.QuickConnectDto request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticateWithQuickConnect(quickConnectDto: QuickConnectDto, options?: any) {
        return UserApiFp(this.configuration).authenticateWithQuickConnect(quickConnectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a user.
     * @param {CreateUserByName} [createUserByName] The create user by name request body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserByName(createUserByName?: CreateUserByName, options?: any) {
        return UserApiFp(this.configuration).createUserByName(createUserByName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a user.
     * @param {string} userId The user id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userId: string, options?: any) {
        return UserApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiates the forgot password process for a local user.
     * @param {ForgotPasswordDto} forgotPasswordDto The forgot password request containing the entered username.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public forgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any) {
        return UserApiFp(this.configuration).forgotPassword(forgotPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeems a forgot password pin.
     * @param {string} [body] The pin.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public forgotPasswordPin(body?: string, options?: any) {
        return UserApiFp(this.configuration).forgotPasswordPin(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of publicly visible users for display on a login screen.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getPublicUsers(options?: any) {
        return UserApiFp(this.configuration).getPublicUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a user by Id.
     * @param {string} userId The user id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(userId: string, options?: any) {
        return UserApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of users.
     * @param {boolean} [isHidden] Optional filter by IsHidden&#x3D;true or false.
     * @param {boolean} [isDisabled] Optional filter by IsDisabled&#x3D;true or false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(isHidden?: boolean, isDisabled?: boolean, options?: any) {
        return UserApiFp(this.configuration).getUsers(isHidden, isDisabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user.
     * @param {string} userId The user id.
     * @param {UserDto} [userDto] The updated user model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(userId: string, userDto?: UserDto, options?: any) {
        return UserApiFp(this.configuration).updateUser(userId, userDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user configuration.
     * @param {string} userId The user id.
     * @param {UserConfiguration} [userConfiguration] The new user configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserConfiguration(userId: string, userConfiguration?: UserConfiguration, options?: any) {
        return UserApiFp(this.configuration).updateUserConfiguration(userId, userConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user\'s easy password.
     * @param {string} userId The user id.
     * @param {UpdateUserEasyPassword} [updateUserEasyPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserEasyPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserEasyPassword) request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserEasyPassword(userId: string, updateUserEasyPassword?: UpdateUserEasyPassword, options?: any) {
        return UserApiFp(this.configuration).updateUserEasyPassword(userId, updateUserEasyPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user\'s password.
     * @param {string} userId The user id.
     * @param {UpdateUserPassword} [updateUserPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserPassword) request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPassword(userId: string, updateUserPassword?: UpdateUserPassword, options?: any) {
        return UserApiFp(this.configuration).updateUserPassword(userId, updateUserPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user policy.
     * @param {string} userId The user id.
     * @param {UserPolicy} [userPolicy] The new user policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPolicy(userId: string, userPolicy?: UserPolicy, options?: any) {
        return UserApiFp(this.configuration).updateUserPolicy(userId, userPolicy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserLibraryApi - axios parameter creator
 * @export
 */
export const UserLibraryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a user\'s saved personal rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserItemRating: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserItemRating.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteUserItemRating.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/Rating`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets intros to play before the main media item plays.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntros: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getIntros.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getIntros.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/Intros`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an item from a user\'s library.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItem.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets latest media.
         * @param {string} userId User id.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, SortName, Studios, Taglines.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [isPlayed] Filter by items that are played, or not.
         * @param {boolean} [enableImages] Optional. include image information in output.
         * @param {number} [imageTypeLimit] Optional. the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {number} [limit] Return item limit.
         * @param {boolean} [groupItems] Whether or not to group items into a parent container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMedia: async (userId: string, parentId?: string, fields?: string, includeItemTypes?: string, isPlayed?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, limit?: number, groupItems?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getLatestMedia.');
            }
            const localVarPath = `/Users/{userId}/Items/Latest`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (groupItems !== undefined) {
                localVarQueryParameter['groupItems'] = groupItems;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets local trailers for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalTrailers: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getLocalTrailers.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getLocalTrailers.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/LocalTrailers`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the root folder from a user\'s library.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootFolder: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getRootFolder.');
            }
            const localVarPath = `/Users/{userId}/Items/Root`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets special features for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecialFeatures: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getSpecialFeatures.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSpecialFeatures.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/SpecialFeatures`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Marks an item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markFavoriteItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling markFavoriteItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling markFavoriteItem.');
            }
            const localVarPath = `/Users/{userId}/FavoriteItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unmarks item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmarkFavoriteItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling unmarkFavoriteItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling unmarkFavoriteItem.');
            }
            const localVarPath = `/Users/{userId}/FavoriteItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user\'s rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {boolean} [likes] Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Guid,System.Guid,System.Nullable{System.Boolean}) is likes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserItemRating: async (userId: string, itemId: string, likes?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserItemRating.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateUserItemRating.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/Rating`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (likes !== undefined) {
                localVarQueryParameter['likes'] = likes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserLibraryApi - functional programming interface
 * @export
 */
export const UserLibraryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a user\'s saved personal rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserItemRating(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).deleteUserItemRating(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets intros to play before the main media item plays.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntros(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getIntros(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an item from a user\'s library.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets latest media.
         * @param {string} userId User id.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, SortName, Studios, Taglines.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [isPlayed] Filter by items that are played, or not.
         * @param {boolean} [enableImages] Optional. include image information in output.
         * @param {number} [imageTypeLimit] Optional. the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {number} [limit] Return item limit.
         * @param {boolean} [groupItems] Whether or not to group items into a parent container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestMedia(userId: string, parentId?: string, fields?: string, includeItemTypes?: string, isPlayed?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, limit?: number, groupItems?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getLatestMedia(userId, parentId, fields, includeItemTypes, isPlayed, enableImages, imageTypeLimit, enableImageTypes, enableUserData, limit, groupItems, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets local trailers for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalTrailers(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getLocalTrailers(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the root folder from a user\'s library.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootFolder(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getRootFolder(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets special features for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecialFeatures(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getSpecialFeatures(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Marks an item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markFavoriteItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).markFavoriteItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Unmarks item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unmarkFavoriteItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).unmarkFavoriteItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user\'s rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {boolean} [likes] Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Guid,System.Guid,System.Nullable{System.Boolean}) is likes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserItemRating(userId: string, itemId: string, likes?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).updateUserItemRating(userId, itemId, likes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserLibraryApi - factory interface
 * @export
 */
export const UserLibraryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes a user\'s saved personal rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserItemRating(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).deleteUserItemRating(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets intros to play before the main media item plays.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntros(userId: string, itemId: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return UserLibraryApiFp(configuration).getIntros(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an item from a user\'s library.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(userId: string, itemId: string, options?: any): AxiosPromise<BaseItemDto> {
            return UserLibraryApiFp(configuration).getItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets latest media.
         * @param {string} userId User id.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, SortName, Studios, Taglines.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [isPlayed] Filter by items that are played, or not.
         * @param {boolean} [enableImages] Optional. include image information in output.
         * @param {number} [imageTypeLimit] Optional. the max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {number} [limit] Return item limit.
         * @param {boolean} [groupItems] Whether or not to group items into a parent container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMedia(userId: string, parentId?: string, fields?: string, includeItemTypes?: string, isPlayed?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, limit?: number, groupItems?: boolean, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return UserLibraryApiFp(configuration).getLatestMedia(userId, parentId, fields, includeItemTypes, isPlayed, enableImages, imageTypeLimit, enableImageTypes, enableUserData, limit, groupItems, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets local trailers for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalTrailers(userId: string, itemId: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return UserLibraryApiFp(configuration).getLocalTrailers(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the root folder from a user\'s library.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootFolder(userId: string, options?: any): AxiosPromise<BaseItemDto> {
            return UserLibraryApiFp(configuration).getRootFolder(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets special features for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecialFeatures(userId: string, itemId: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return UserLibraryApiFp(configuration).getSpecialFeatures(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Marks an item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markFavoriteItem(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).markFavoriteItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unmarks item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmarkFavoriteItem(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).unmarkFavoriteItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user\'s rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {boolean} [likes] Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Guid,System.Guid,System.Nullable{System.Boolean}) is likes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserItemRating(userId: string, itemId: string, likes?: boolean, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).updateUserItemRating(userId, itemId, likes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserLibraryApi - object-oriented interface
 * @export
 * @class UserLibraryApi
 * @extends {BaseAPI}
 */
export class UserLibraryApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a user\'s saved personal rating for an item.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public deleteUserItemRating(userId: string, itemId: string, options?: any) {
        return UserLibraryApiFp(this.configuration).deleteUserItemRating(userId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets intros to play before the main media item plays.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getIntros(userId: string, itemId: string, options?: any) {
        return UserLibraryApiFp(this.configuration).getIntros(userId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an item from a user\'s library.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getItem(userId: string, itemId: string, options?: any) {
        return UserLibraryApiFp(this.configuration).getItem(userId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets latest media.
     * @param {string} userId User id.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, SortName, Studios, Taglines.
     * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param {boolean} [isPlayed] Filter by items that are played, or not.
     * @param {boolean} [enableImages] Optional. include image information in output.
     * @param {number} [imageTypeLimit] Optional. the max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {boolean} [enableUserData] Optional. include user data.
     * @param {number} [limit] Return item limit.
     * @param {boolean} [groupItems] Whether or not to group items into a parent container.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getLatestMedia(userId: string, parentId?: string, fields?: string, includeItemTypes?: string, isPlayed?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, limit?: number, groupItems?: boolean, options?: any) {
        return UserLibraryApiFp(this.configuration).getLatestMedia(userId, parentId, fields, includeItemTypes, isPlayed, enableImages, imageTypeLimit, enableImageTypes, enableUserData, limit, groupItems, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets local trailers for an item.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getLocalTrailers(userId: string, itemId: string, options?: any) {
        return UserLibraryApiFp(this.configuration).getLocalTrailers(userId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the root folder from a user\'s library.
     * @param {string} userId User id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getRootFolder(userId: string, options?: any) {
        return UserLibraryApiFp(this.configuration).getRootFolder(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets special features for an item.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getSpecialFeatures(userId: string, itemId: string, options?: any) {
        return UserLibraryApiFp(this.configuration).getSpecialFeatures(userId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Marks an item as a favorite.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public markFavoriteItem(userId: string, itemId: string, options?: any) {
        return UserLibraryApiFp(this.configuration).markFavoriteItem(userId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unmarks item as a favorite.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public unmarkFavoriteItem(userId: string, itemId: string, options?: any) {
        return UserLibraryApiFp(this.configuration).unmarkFavoriteItem(userId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user\'s rating for an item.
     * @param {string} userId User id.
     * @param {string} itemId Item id.
     * @param {boolean} [likes] Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Guid,System.Guid,System.Nullable{System.Boolean}) is likes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public updateUserItemRating(userId: string, itemId: string, likes?: boolean, options?: any) {
        return UserLibraryApiFp(this.configuration).updateUserItemRating(userId, itemId, likes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserViewsApi - axios parameter creator
 * @export
 */
export const UserViewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user view grouping options.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupingOptions: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getGroupingOptions.');
            }
            const localVarPath = `/Users/{userId}/GroupingOptions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user views.
         * @param {string} userId User id.
         * @param {boolean} [includeExternalContent] Whether or not to include external views such as channels or live tv.
         * @param {string} [presetViews] Preset views.
         * @param {boolean} [includeHidden] Whether or not to include hidden content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserViews: async (userId: string, includeExternalContent?: boolean, presetViews?: string, includeHidden?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserViews.');
            }
            const localVarPath = `/Users/{userId}/Views`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (includeExternalContent !== undefined) {
                localVarQueryParameter['includeExternalContent'] = includeExternalContent;
            }

            if (presetViews !== undefined) {
                localVarQueryParameter['presetViews'] = presetViews;
            }

            if (includeHidden !== undefined) {
                localVarQueryParameter['includeHidden'] = includeHidden;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserViewsApi - functional programming interface
 * @export
 */
export const UserViewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user view grouping options.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupingOptions(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpecialViewOptionDto>>> {
            const localVarAxiosArgs = await UserViewsApiAxiosParamCreator(configuration).getGroupingOptions(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get user views.
         * @param {string} userId User id.
         * @param {boolean} [includeExternalContent] Whether or not to include external views such as channels or live tv.
         * @param {string} [presetViews] Preset views.
         * @param {boolean} [includeHidden] Whether or not to include hidden content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserViews(userId: string, includeExternalContent?: boolean, presetViews?: string, includeHidden?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await UserViewsApiAxiosParamCreator(configuration).getUserViews(userId, includeExternalContent, presetViews, includeHidden, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserViewsApi - factory interface
 * @export
 */
export const UserViewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get user view grouping options.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupingOptions(userId: string, options?: any): AxiosPromise<Array<SpecialViewOptionDto>> {
            return UserViewsApiFp(configuration).getGroupingOptions(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user views.
         * @param {string} userId User id.
         * @param {boolean} [includeExternalContent] Whether or not to include external views such as channels or live tv.
         * @param {string} [presetViews] Preset views.
         * @param {boolean} [includeHidden] Whether or not to include hidden content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserViews(userId: string, includeExternalContent?: boolean, presetViews?: string, includeHidden?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return UserViewsApiFp(configuration).getUserViews(userId, includeExternalContent, presetViews, includeHidden, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserViewsApi - object-oriented interface
 * @export
 * @class UserViewsApi
 * @extends {BaseAPI}
 */
export class UserViewsApi extends BaseAPI {
    /**
     * 
     * @summary Get user view grouping options.
     * @param {string} userId User id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserViewsApi
     */
    public getGroupingOptions(userId: string, options?: any) {
        return UserViewsApiFp(this.configuration).getGroupingOptions(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user views.
     * @param {string} userId User id.
     * @param {boolean} [includeExternalContent] Whether or not to include external views such as channels or live tv.
     * @param {string} [presetViews] Preset views.
     * @param {boolean} [includeHidden] Whether or not to include hidden content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserViewsApi
     */
    public getUserViews(userId: string, includeExternalContent?: boolean, presetViews?: string, includeHidden?: boolean, options?: any) {
        return UserViewsApiFp(this.configuration).getUserViews(userId, includeExternalContent, presetViews, includeHidden, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideoAttachmentsApi - axios parameter creator
 * @export
 */
export const VideoAttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get video attachment.
         * @param {string} videoId Video ID.
         * @param {string} mediaSourceId Media Source ID.
         * @param {number} index Attachment Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment: async (videoId: string, mediaSourceId: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            if (videoId === null || videoId === undefined) {
                throw new RequiredError('videoId','Required parameter videoId was null or undefined when calling getAttachment.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getAttachment.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getAttachment.');
            }
            const localVarPath = `/Videos/{videoId}/{mediaSourceId}/Attachments/{index}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoAttachmentsApi - functional programming interface
 * @export
 */
export const VideoAttachmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get video attachment.
         * @param {string} videoId Video ID.
         * @param {string} mediaSourceId Media Source ID.
         * @param {number} index Attachment Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachment(videoId: string, mediaSourceId: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideoAttachmentsApiAxiosParamCreator(configuration).getAttachment(videoId, mediaSourceId, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VideoAttachmentsApi - factory interface
 * @export
 */
export const VideoAttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get video attachment.
         * @param {string} videoId Video ID.
         * @param {string} mediaSourceId Media Source ID.
         * @param {number} index Attachment Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(videoId: string, mediaSourceId: string, index: number, options?: any): AxiosPromise<any> {
            return VideoAttachmentsApiFp(configuration).getAttachment(videoId, mediaSourceId, index, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideoAttachmentsApi - object-oriented interface
 * @export
 * @class VideoAttachmentsApi
 * @extends {BaseAPI}
 */
export class VideoAttachmentsApi extends BaseAPI {
    /**
     * 
     * @summary Get video attachment.
     * @param {string} videoId Video ID.
     * @param {string} mediaSourceId Media Source ID.
     * @param {number} index Attachment Index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoAttachmentsApi
     */
    public getAttachment(videoId: string, mediaSourceId: string, index: number, options?: any) {
        return VideoAttachmentsApiFp(this.configuration).getAttachment(videoId, mediaSourceId, index, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideoHlsApi - axios parameter creator
 * @export
 */
export const VideoHlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a hls live stream.
         * @param {string} itemId The item id.
         * @param {string} [container] The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {number} [maxWidth] Optional. The max width.
         * @param {number} [maxHeight] Optional. The max height.
         * @param {boolean} [enableSubtitlesInManifest] Optional. Whether to enable subtitles in the manifest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveHlsStream: async (itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, maxWidth?: number, maxHeight?: number, enableSubtitlesInManifest?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getLiveHlsStream.');
            }
            const localVarPath = `/Videos/{itemId}/live.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (container !== undefined) {
                localVarQueryParameter['container'] = container;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (enableSubtitlesInManifest !== undefined) {
                localVarQueryParameter['enableSubtitlesInManifest'] = enableSubtitlesInManifest;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoHlsApi - functional programming interface
 * @export
 */
export const VideoHlsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a hls live stream.
         * @param {string} itemId The item id.
         * @param {string} [container] The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {number} [maxWidth] Optional. The max width.
         * @param {number} [maxHeight] Optional. The max height.
         * @param {boolean} [enableSubtitlesInManifest] Optional. Whether to enable subtitles in the manifest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveHlsStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, maxWidth?: number, maxHeight?: number, enableSubtitlesInManifest?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideoHlsApiAxiosParamCreator(configuration).getLiveHlsStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VideoHlsApi - factory interface
 * @export
 */
export const VideoHlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a hls live stream.
         * @param {string} itemId The item id.
         * @param {string} [container] The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {number} [maxWidth] Optional. The max width.
         * @param {number} [maxHeight] Optional. The max height.
         * @param {boolean} [enableSubtitlesInManifest] Optional. Whether to enable subtitles in the manifest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveHlsStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, maxWidth?: number, maxHeight?: number, enableSubtitlesInManifest?: boolean, options?: any): AxiosPromise<any> {
            return VideoHlsApiFp(configuration).getLiveHlsStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideoHlsApi - object-oriented interface
 * @export
 * @class VideoHlsApi
 * @extends {BaseAPI}
 */
export class VideoHlsApi extends BaseAPI {
    /**
     * 
     * @summary Gets a hls live stream.
     * @param {string} itemId The item id.
     * @param {string} [container] The audio container.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {number} [maxWidth] Optional. The max width.
     * @param {number} [maxHeight] Optional. The max height.
     * @param {boolean} [enableSubtitlesInManifest] Optional. Whether to enable subtitles in the manifest.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoHlsApi
     */
    public getLiveHlsStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, maxWidth?: number, maxHeight?: number, enableSubtitlesInManifest?: boolean, options?: any) {
        return VideoHlsApiFp(this.configuration).getLiveHlsStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideosApi - axios parameter creator
 * @export
 */
export const VideosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Removes alternate video sources.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlternateSources: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteAlternateSources.');
            }
            const localVarPath = `/Videos/{itemId}/AlternateSources`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets additional parts for a video.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdditionalPart: async (itemId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAdditionalPart.');
            }
            const localVarPath = `/Videos/{itemId}/AdditionalParts`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVideoStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getVideoStream.');
            }
            const localVarPath = `/Videos/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStreamWithExt: async (itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVideoStreamWithExt.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getVideoStreamWithExt.');
            }
            // verify required parameter 'stream' is not null or undefined
            if (stream === null || stream === undefined) {
                throw new RequiredError('stream','Required parameter stream was null or undefined when calling getVideoStreamWithExt.');
            }
            const localVarPath = `/Videos/{itemId}/{stream}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)))
                .replace(`{${"stream"}}`, encodeURIComponent(String(stream)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headVideoStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headVideoStream.');
            }
            const localVarPath = `/Videos/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStreamWithExt: async (itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headVideoStreamWithExt.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headVideoStreamWithExt.');
            }
            // verify required parameter 'stream' is not null or undefined
            if (stream === null || stream === undefined) {
                throw new RequiredError('stream','Required parameter stream was null or undefined when calling headVideoStreamWithExt.');
            }
            const localVarPath = `/Videos/{itemId}/{stream}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)))
                .replace(`{${"stream"}}`, encodeURIComponent(String(stream)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merges videos into a single record.
         * @param {string} itemIds Item id list. This allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeVersions: async (itemIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling mergeVersions.');
            }
            const localVarPath = `/Videos/MergeVersions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemIds !== undefined) {
                localVarQueryParameter['itemIds'] = itemIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideosApi - functional programming interface
 * @export
 */
export const VideosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Removes alternate video sources.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlternateSources(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).deleteAlternateSources(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets additional parts for a video.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdditionalPart(itemId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).getAdditionalPart(itemId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).getVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoStreamWithExt(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).getVideoStreamWithExt(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).headVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headVideoStreamWithExt(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).headVideoStreamWithExt(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Merges videos into a single record.
         * @param {string} itemIds Item id list. This allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeVersions(itemIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).mergeVersions(itemIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VideosApi - factory interface
 * @export
 */
export const VideosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Removes alternate video sources.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlternateSources(itemId: string, options?: any): AxiosPromise<void> {
            return VideosApiFp(configuration).deleteAlternateSources(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets additional parts for a video.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdditionalPart(itemId: string, userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return VideosApiFp(configuration).getAdditionalPart(itemId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return VideosApiFp(configuration).getVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStreamWithExt(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return VideosApiFp(configuration).getVideoStreamWithExt(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return VideosApiFp(configuration).headVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStreamWithExt(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return VideosApiFp(configuration).headVideoStreamWithExt(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merges videos into a single record.
         * @param {string} itemIds Item id list. This allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeVersions(itemIds: string, options?: any): AxiosPromise<void> {
            return VideosApiFp(configuration).mergeVersions(itemIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
export class VideosApi extends BaseAPI {
    /**
     * 
     * @summary Removes alternate video sources.
     * @param {string} itemId The item id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public deleteAlternateSources(itemId: string, options?: any) {
        return VideosApiFp(this.configuration).deleteAlternateSources(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets additional parts for a video.
     * @param {string} itemId The item id.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public getAdditionalPart(itemId: string, userId?: string, options?: any) {
        return VideosApiFp(this.configuration).getAdditionalPart(itemId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream.
     * @param {string} itemId The item id.
     * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public getVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return VideosApiFp(this.configuration).getVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream.
     * @param {string} itemId The item id.
     * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @param {string} stream 
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public getVideoStreamWithExt(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return VideosApiFp(this.configuration).getVideoStreamWithExt(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream.
     * @param {string} itemId The item id.
     * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public headVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return VideosApiFp(this.configuration).headVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream.
     * @param {string} itemId The item id.
     * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @param {string} stream 
     * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @param {string} [params] The streaming parameters.
     * @param {string} [tag] The tag.
     * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
     * @param {string} [playSessionId] The play session id.
     * @param {string} [segmentContainer] The segment container.
     * @param {number} [segmentLength] The segment lenght.
     * @param {number} [minSegments] The minimum number of segments.
     * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
     * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
     * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
     * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
     * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
     * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
     * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
     * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
     * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
     * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
     * @param {number} [maxRefFrames] Optional.
     * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
     * @param {boolean} [requireAvc] Optional. Whether to require avc.
     * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
     * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
     * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
     * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
     * @param {string} [liveStreamId] The live stream id.
     * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
     * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
     * @param {string} [transcodingReasons] Optional. The transcoding reason.
     * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public headVideoStreamWithExt(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any) {
        return VideosApiFp(this.configuration).headVideoStreamWithExt(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merges videos into a single record.
     * @param {string} itemIds Item id list. This allows multiple, comma delimited.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public mergeVersions(itemIds: string, options?: any) {
        return VideosApiFp(this.configuration).mergeVersions(itemIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * YearsApi - axios parameter creator
 * @export
 */
export const YearsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a year.
         * @param {number} year The year.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYear: async (year: number, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getYear.');
            }
            const localVarPath = `/Years/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get years.
         * @param {number} [startIndex] Skips over a given number of items within the results. Use for paging.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User Id.
         * @param {boolean} [recursive] Search recursively.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYears: async (startIndex?: number, limit?: number, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, mediaTypes?: string, sortBy?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, recursive?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Years`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * YearsApi - functional programming interface
 * @export
 */
export const YearsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a year.
         * @param {number} year The year.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYear(year: number, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await YearsApiAxiosParamCreator(configuration).getYear(year, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get years.
         * @param {number} [startIndex] Skips over a given number of items within the results. Use for paging.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User Id.
         * @param {boolean} [recursive] Search recursively.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYears(startIndex?: number, limit?: number, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, mediaTypes?: string, sortBy?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, recursive?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await YearsApiAxiosParamCreator(configuration).getYears(startIndex, limit, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, mediaTypes, sortBy, enableUserData, imageTypeLimit, enableImageTypes, userId, recursive, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * YearsApi - factory interface
 * @export
 */
export const YearsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a year.
         * @param {number} year The year.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYear(year: number, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return YearsApiFp(configuration).getYear(year, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get years.
         * @param {number} [startIndex] Skips over a given number of items within the results. Use for paging.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {string} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User Id.
         * @param {boolean} [recursive] Search recursively.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYears(startIndex?: number, limit?: number, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, mediaTypes?: string, sortBy?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, recursive?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return YearsApiFp(configuration).getYears(startIndex, limit, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, mediaTypes, sortBy, enableUserData, imageTypeLimit, enableImageTypes, userId, recursive, enableImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * YearsApi - object-oriented interface
 * @export
 * @class YearsApi
 * @extends {BaseAPI}
 */
export class YearsApi extends BaseAPI {
    /**
     * 
     * @summary Gets a year.
     * @param {number} year The year.
     * @param {string} [userId] Optional. Filter by user id, and attach user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YearsApi
     */
    public getYear(year: number, userId?: string, options?: any) {
        return YearsApiFp(this.configuration).getYear(year, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get years.
     * @param {number} [startIndex] Skips over a given number of items within the results. Use for paging.
     * @param {number} [limit] Optional. The maximum number of records to return.
     * @param {string} [sortOrder] Sort Order - Ascending,Descending.
     * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @param {string} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @param {string} [excludeItemTypes] Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
     * @param {string} [includeItemTypes] Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
     * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
     * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @param {boolean} [enableUserData] Optional. Include user data.
     * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
     * @param {string} [enableImageTypes] Optional. The image types to include in the output.
     * @param {string} [userId] User Id.
     * @param {boolean} [recursive] Search recursively.
     * @param {boolean} [enableImages] Optional. Include image information in output.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YearsApi
     */
    public getYears(startIndex?: number, limit?: number, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, mediaTypes?: string, sortBy?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, recursive?: boolean, enableImages?: boolean, options?: any) {
        return YearsApiFp(this.configuration).getYears(startIndex, limit, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, mediaTypes, sortBy, enableUserData, imageTypeLimit, enableImageTypes, userId, recursive, enableImages, options).then((request) => request(this.axios, this.basePath));
    }
}


